From 499e1465050a637069920ac671ca1e0d9c8671e7 Mon Sep 17 00:00:00 2001
From: "Darryl L. Pierce" <dpierce@redhat.com>
Date: Wed, 25 Jul 2012 12:11:31 -0400
Subject: [PATCH] Relocated all swig .i files to the include directory.

Updated the build systems to use the new locations. Updated all other .i
files to not use relative paths when referencing them.
---
 qpid/cpp/CMakeLists.txt                   |   7 +
 qpid/cpp/Makefile.am                      |   5 +-
 qpid/cpp/bindings/qmf/python/Makefile.am  |   2 +-
 qpid/cpp/bindings/qmf/python/python.i     |   2 +-
 qpid/cpp/bindings/qmf/qmfengine.i         |  59 ----
 qpid/cpp/bindings/qmf/ruby/Makefile.am    |   2 +-
 qpid/cpp/bindings/qmf/ruby/ruby.i         |   2 +-
 qpid/cpp/bindings/qmf2/python/Makefile.am |   2 +-
 qpid/cpp/bindings/qmf2/python/python.i    |   4 +-
 qpid/cpp/bindings/qmf2/qmf2.i             |  66 -----
 qpid/cpp/bindings/qmf2/ruby/Makefile.am   |   2 +-
 qpid/cpp/bindings/qmf2/ruby/ruby.i        |   4 +-
 qpid/cpp/bindings/qpid/Makefile.am        |   2 +-
 qpid/cpp/bindings/qpid/perl/perl.i        |   4 +-
 qpid/cpp/bindings/qpid/python/Makefile.am |   2 +-
 qpid/cpp/bindings/qpid/python/python.i    |   4 +-
 qpid/cpp/bindings/qpid/qpid.i             |  70 -----
 qpid/cpp/bindings/qpid/ruby/Makefile.am   |   2 +-
 qpid/cpp/bindings/qpid/ruby/ruby.i        |   4 +-
 qpid/cpp/bindings/swig_perl_typemaps.i    | 330 ----------------------
 qpid/cpp/bindings/swig_python_typemaps.i  | 446 ------------------------------
 qpid/cpp/bindings/swig_ruby_typemaps.i    | 368 ------------------------
 qpid/cpp/include/qmf2.i                   |  66 +++++
 qpid/cpp/include/qmfengine.i              |  59 ++++
 qpid/cpp/include/qpid.i                   |  70 +++++
 qpid/cpp/include/swig_perl_typemaps.i     | 330 ++++++++++++++++++++++
 qpid/cpp/include/swig_python_typemaps.i   | 446 ++++++++++++++++++++++++++++++
 qpid/cpp/include/swig_ruby_typemaps.i     | 368 ++++++++++++++++++++++++
 28 files changed, 1368 insertions(+), 1360 deletions(-)
 delete mode 100644 qpid/cpp/bindings/qmf/qmfengine.i
 delete mode 100644 qpid/cpp/bindings/qmf2/qmf2.i
 delete mode 100644 qpid/cpp/bindings/qpid/qpid.i
 delete mode 100644 qpid/cpp/bindings/swig_perl_typemaps.i
 delete mode 100644 qpid/cpp/bindings/swig_python_typemaps.i
 delete mode 100644 qpid/cpp/bindings/swig_ruby_typemaps.i
 create mode 100644 qpid/cpp/include/qmf2.i
 create mode 100644 qpid/cpp/include/qmfengine.i
 create mode 100644 qpid/cpp/include/qpid.i
 create mode 100644 qpid/cpp/include/swig_perl_typemaps.i
 create mode 100644 qpid/cpp/include/swig_python_typemaps.i
 create mode 100644 qpid/cpp/include/swig_ruby_typemaps.i

diff --git a/qpid/cpp/CMakeLists.txt b/qpid/cpp/CMakeLists.txt
index 4c83540..2a8e426 100644
--- a/qpid/cpp/CMakeLists.txt
+++ b/qpid/cpp/CMakeLists.txt
@@ -61,6 +61,13 @@ set (QPIDD_CONF_FILE ${QPID_INSTALL_CONFDIR}/qpidd.conf CACHE STRING
 
 install(FILES  LICENSE NOTICE  DESTINATION ${CMAKE_INSTALL_PREFIX})
 install(FILES  xml/cluster.xml DESTINATION ${QPID_INSTALL_DATADIR})
+install(FILES  include/qpid.i
+               include/qmfengine.i
+               include/qmf2.i
+               include/swig_perl_typemaps.i
+               include/swig_python_typemaps.i
+               include/swig_ruby_typemaps.i
+        DESTINATION ${QPID_INSTALL_INCLUDEDIR})
 
 if (WIN32)
    set (CMAKE_DEBUG_POSTFIX "d")
diff --git a/qpid/cpp/Makefile.am b/qpid/cpp/Makefile.am
index 9f4b8e2..d026dfc 100644
--- a/qpid/cpp/Makefile.am
+++ b/qpid/cpp/Makefile.am
@@ -25,8 +25,9 @@ ACLOCAL_AMFLAGS = -I m4
 EXTRA_DIST = \
   LICENSE NOTICE README.txt SSL RELEASE_NOTES DESIGN \
   xml/cluster.xml INSTALL-WINDOWS CMakeLists.txt BuildInstallSettings.cmake \
-  packaging/NSIS QPID_VERSION.txt bindings/swig_python_typemaps.i \
-  bindings/swig_ruby_typemaps.i bindings/swig_perl_typemaps.i
+  packaging/NSIS QPID_VERSION.txt include/swig_python_typemaps.i \
+  include/swig_ruby_typemaps.i include/swig_perl_typemaps.i \
+  include/qpid.i include/qmfengine.i include/qmf2.i
 
 SUBDIRS = managementgen etc src docs/api docs/man examples bindings/qmf bindings/qpid bindings/qmf2
 
diff --git a/qpid/cpp/bindings/qmf/python/Makefile.am b/qpid/cpp/bindings/qmf/python/Makefile.am
index bcef8c6..07f3c10 100644
--- a/qpid/cpp/bindings/qmf/python/Makefile.am
+++ b/qpid/cpp/bindings/qmf/python/Makefile.am
@@ -29,7 +29,7 @@ EXTRA_DIST = CMakeLists.txt python.i
 BUILT_SOURCES = $(generated_file_list)
 SWIG_FLAGS = -w362,401
 
-$(generated_file_list): $(srcdir)/python.i $(srcdir)/../qmfengine.i
+$(generated_file_list): $(srcdir)/python.i
 	$(SWIG) -c++ -python $(SWIG_FLAGS) $(INCLUDES) $(QPID_CXXFLAGS) -I$(top_srcdir)/src/qmf -I/usr/include -o qmfengine.cpp $(srcdir)/python.i
 
 pylibdir = $(pyexecdir)
diff --git a/qpid/cpp/bindings/qmf/python/python.i b/qpid/cpp/bindings/qmf/python/python.i
index 5e25d15..1f075b8 100644
--- a/qpid/cpp/bindings/qmf/python/python.i
+++ b/qpid/cpp/bindings/qmf/python/python.i
@@ -139,5 +139,5 @@
 
 
 
-%include "../qmfengine.i"
+%include "qmfengine.i"
 
diff --git a/qpid/cpp/bindings/qmf/qmfengine.i b/qpid/cpp/bindings/qmf/qmfengine.i
deleted file mode 100644
index eb35011..0000000
--- a/qpid/cpp/bindings/qmf/qmfengine.i
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-%{
-
-#include "qmf/engine/Agent.h"
-#include "qmf/engine/Console.h"
-#include "qmf/engine/ResilientConnection.h"
-
-%}
-
-%include <qmf/engine/QmfEngineImportExport.h>
-%include <qmf/engine/Query.h>
-%include <qmf/engine/Message.h>
-%include <qmf/engine/Agent.h>
-%include <qmf/engine/Console.h>
-%include <qmf/engine/ConnectionSettings.h>
-%include <qmf/engine/ResilientConnection.h>
-%include <qmf/engine/Typecode.h>
-%include <qmf/engine/Schema.h>
-%include <qmf/engine/Value.h>
-%include <qmf/engine/ObjectId.h>
-%include <qmf/engine/Object.h>
-%include <qmf/engine/Event.h>
-
-
-%inline {
-
-using namespace std;
-using namespace qmf::engine;
-
-namespace qmf {
-namespace engine {
-
-}
-}
-}
-
-
-%{
-
-%};
-
diff --git a/qpid/cpp/bindings/qmf/ruby/Makefile.am b/qpid/cpp/bindings/qmf/ruby/Makefile.am
index 1c7f67e..33393ae 100644
--- a/qpid/cpp/bindings/qmf/ruby/Makefile.am
+++ b/qpid/cpp/bindings/qmf/ruby/Makefile.am
@@ -29,7 +29,7 @@ rubylibdir = $(RUBY_LIB)
 
 dist_rubylib_DATA = qmf.rb
 
-qmfengine.cpp: $(srcdir)/ruby.i $(srcdir)/../qmfengine.i
+qmfengine.cpp: $(srcdir)/ruby.i
 	$(SWIG) -ruby -c++ $(SWIG_FLAGS) $(INCLUDES) $(QPID_CXXFLAGS) -I/usr/include -o qmfengine.cpp $(srcdir)/ruby.i
 
 rubylibarchdir = $(RUBY_LIB_ARCH)
diff --git a/qpid/cpp/bindings/qmf/ruby/ruby.i b/qpid/cpp/bindings/qmf/ruby/ruby.i
index 0101861..70deb64 100644
--- a/qpid/cpp/bindings/qmf/ruby/ruby.i
+++ b/qpid/cpp/bindings/qmf/ruby/ruby.i
@@ -102,5 +102,5 @@
 }
 
 
-%include "../qmfengine.i"
+%include "qmfengine.i"
 
diff --git a/qpid/cpp/bindings/qmf2/python/Makefile.am b/qpid/cpp/bindings/qmf2/python/Makefile.am
index 591c140..8277b44 100644
--- a/qpid/cpp/bindings/qmf2/python/Makefile.am
+++ b/qpid/cpp/bindings/qmf2/python/Makefile.am
@@ -29,7 +29,7 @@ EXTRA_DIST = CMakeLists.txt python.i
 BUILT_SOURCES = $(generated_file_list)
 SWIG_FLAGS = -w362,401
 
-$(generated_file_list): $(srcdir)/python.i $(srcdir)/../qmf2.i $(srcdir)/../../swig_python_typemaps.i
+$(generated_file_list): $(srcdir)/python.i
 	$(SWIG) -c++ -python $(SWIG_FLAGS) $(INCLUDES) $(QPID_CXXFLAGS) -I/usr/include -o cqmf2.cpp $(srcdir)/python.i
 
 pylibdir = $(pyexecdir)
diff --git a/qpid/cpp/bindings/qmf2/python/python.i b/qpid/cpp/bindings/qmf2/python/python.i
index 02dd163..54a6226 100644
--- a/qpid/cpp/bindings/qmf2/python/python.i
+++ b/qpid/cpp/bindings/qmf2/python/python.i
@@ -19,7 +19,7 @@
 
 %module cqmf2
 %include "std_string.i"
-%include "../../swig_python_typemaps.i"
+%include "swig_python_typemaps.i"
 
 /* Define the general-purpose exception handling */
 %exception {
@@ -37,5 +37,5 @@
     }
 }
 
-%include "../qmf2.i"
+%include "qmf2.i"
 
diff --git a/qpid/cpp/bindings/qmf2/qmf2.i b/qpid/cpp/bindings/qmf2/qmf2.i
deleted file mode 100644
index 0f573fe..0000000
--- a/qpid/cpp/bindings/qmf2/qmf2.i
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-%{
-
-#include <qmf/exceptions.h>
-#include <qmf/AgentEvent.h>
-#include <qmf/Agent.h>
-#include <qmf/AgentSession.h>
-#include <qmf/ConsoleEvent.h>
-#include <qmf/ConsoleSession.h>
-#include <qmf/DataAddr.h>
-#include <qmf/Data.h>
-#include <qmf/Query.h>
-#include <qmf/Schema.h>
-#include <qmf/SchemaId.h>
-#include <qmf/SchemaMethod.h>
-#include <qmf/SchemaProperty.h>
-#include <qmf/SchemaTypes.h>
-#include <qmf/Subscription.h>
-
-%}
-
-%include <qpid/ImportExport.h>
-%include <qpid/messaging/ImportExport.h>
-%include <qpid/messaging/Duration.h>
-
-%include <qmf/ImportExport.h>
-%include <qmf/exceptions.h>
-%include <qmf/AgentEvent.h>
-%include <qmf/Agent.h>
-%include <qmf/AgentSession.h>
-%include <qmf/ConsoleEvent.h>
-%include <qmf/ConsoleSession.h>
-%include <qmf/DataAddr.h>
-%include <qmf/Data.h>
-%include <qmf/Query.h>
-%include <qmf/Schema.h>
-%include <qmf/SchemaId.h>
-%include <qmf/SchemaMethod.h>
-%include <qmf/SchemaProperty.h>
-%include <qmf/SchemaTypes.h>
-%include <qmf/Subscription.h>
-
-%{
-
-using namespace qmf;
-
-%};
-
diff --git a/qpid/cpp/bindings/qmf2/ruby/Makefile.am b/qpid/cpp/bindings/qmf2/ruby/Makefile.am
index a03bd6d..f681401 100644
--- a/qpid/cpp/bindings/qmf2/ruby/Makefile.am
+++ b/qpid/cpp/bindings/qmf2/ruby/Makefile.am
@@ -27,7 +27,7 @@ SWIG_FLAGS = -w362,401
 
 rubylibdir = $(RUBY_LIB)
 
-cqmf2.cpp: $(srcdir)/ruby.i $(srcdir)/../qmf2.i $(srcdir)/../../swig_ruby_typemaps.i
+cqmf2.cpp: $(srcdir)/ruby.i
 	$(SWIG) -ruby -c++ $(SWIG_FLAGS) $(INCLUDES) $(QPID_CXXFLAGS) -I/usr/include -o cqmf2.cpp $(srcdir)/ruby.i
 
 rubylibarchdir = $(RUBY_LIB_ARCH)
diff --git a/qpid/cpp/bindings/qmf2/ruby/ruby.i b/qpid/cpp/bindings/qmf2/ruby/ruby.i
index 1070c65..848d651 100644
--- a/qpid/cpp/bindings/qmf2/ruby/ruby.i
+++ b/qpid/cpp/bindings/qmf2/ruby/ruby.i
@@ -19,7 +19,7 @@
 
 %module cqmf2
 %include "std_string.i"
-%include "../../swig_ruby_typemaps.i"
+%include "swig_ruby_typemaps.i"
 
 /* Define the general-purpose exception handling */
 %exception {
@@ -32,4 +32,4 @@
     }
 }
 
-%include "../qmf2.i"
+%include "qmf2.i"
diff --git a/qpid/cpp/bindings/qpid/Makefile.am b/qpid/cpp/bindings/qpid/Makefile.am
index ae81696..2ea4af6 100644
--- a/qpid/cpp/bindings/qpid/Makefile.am
+++ b/qpid/cpp/bindings/qpid/Makefile.am
@@ -39,7 +39,7 @@ EXTRA_DIST += perl/perl.i perl/CMakeLists.txt
 BUILT_SOURCES = perl/cqpid_perl.cpp
 SWIG_FLAGS = -w362,401
 
-perl/cqpid_perl.cpp: $(srcdir)/perl/perl.i $(srcdir)/qpid.i $(srcdir)/../swig_perl_typemaps.i
+perl/cqpid_perl.cpp: $(srcdir)/perl/perl.i
 	$(SWIG) -perl -c++ $(SWIG_FLAGS) $(INCLUDES) $(QPID_CXXFLAGS) -I/usr/include -o perl/cqpid_perl.cpp $(srcdir)/perl/perl.i
 
 perl/Makefile: perl/cqpid_perl.cpp
diff --git a/qpid/cpp/bindings/qpid/perl/perl.i b/qpid/cpp/bindings/qpid/perl/perl.i
index 38ac917..dd56b9d 100644
--- a/qpid/cpp/bindings/qpid/perl/perl.i
+++ b/qpid/cpp/bindings/qpid/perl/perl.i
@@ -19,7 +19,7 @@
 
 %module cqpid_perl
 %include "std_string.i"
-%include "../../swig_perl_typemaps.i"
+%include "swig_perl_typemaps.i"
 
 /* Define the general-purpose exception handling */
 %exception {
@@ -31,5 +31,5 @@
     }
 }
 
-%include "../qpid.i"
+%include "qpid.i"
 
diff --git a/qpid/cpp/bindings/qpid/python/Makefile.am b/qpid/cpp/bindings/qpid/python/Makefile.am
index 432fe7e..fcd70e8 100644
--- a/qpid/cpp/bindings/qpid/python/Makefile.am
+++ b/qpid/cpp/bindings/qpid/python/Makefile.am
@@ -29,7 +29,7 @@ EXTRA_DIST = CMakeLists.txt python.i
 BUILT_SOURCES = $(generated_file_list)
 SWIG_FLAGS = -w362,401
 
-$(generated_file_list): $(srcdir)/python.i $(srcdir)/../qpid.i $(srcdir)/../../swig_python_typemaps.i
+$(generated_file_list): $(srcdir)/python.i
 	$(SWIG) -c++ -python $(SWIG_FLAGS) $(INCLUDES) $(QPID_CXXFLAGS) -I$(top_srcdir)/src/qmf -I/usr/include -o cqpid.cpp $(srcdir)/python.i
 
 pylibdir = $(pyexecdir)
diff --git a/qpid/cpp/bindings/qpid/python/python.i b/qpid/cpp/bindings/qpid/python/python.i
index 4d8a64b..2bdc783 100644
--- a/qpid/cpp/bindings/qpid/python/python.i
+++ b/qpid/cpp/bindings/qpid/python/python.i
@@ -19,7 +19,7 @@
 
 %module cqpid
 %include "std_string.i"
-%include "../../swig_python_typemaps.i"
+%include "swig_python_typemaps.i"
 
 /* Needed for get/setPriority methods.  Surprising SWIG 1.3.40 doesn't
  * convert uint8_t by default. */
@@ -159,7 +159,7 @@ QPID_EXCEPTION(UnauthorizedAccess, SessionError)
 %rename(_setTtl) qpid::messaging::Message::setTtl;
 
 
-%include "../qpid.i"
+%include "qpid.i"
 
 %extend qpid::messaging::Connection {
     %pythoncode %{
diff --git a/qpid/cpp/bindings/qpid/qpid.i b/qpid/cpp/bindings/qpid/qpid.i
deleted file mode 100644
index 352bafa..0000000
--- a/qpid/cpp/bindings/qpid/qpid.i
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-%{
-
-#include <qpid/messaging/exceptions.h>
-#include <qpid/messaging/Address.h>
-#include <qpid/messaging/Connection.h>
-#include <qpid/messaging/Session.h>
-#include <qpid/messaging/Receiver.h>
-#include <qpid/messaging/Sender.h>
-#include <qpid/messaging/Message.h>
-#include <qpid/messaging/Duration.h>
-#include <qpid/messaging/FailoverUpdates.h>
-
-//
-// Wrapper functions for map-decode and list-decode.  This allows us to avoid
-// the complexity of output parameter mapping.
-//
-qpid::types::Variant::Map& decodeMap(const qpid::messaging::Message& msg) {
-    static qpid::types::Variant::Map map;
-    map.clear();
-    qpid::messaging::decode(msg, map);
-    return map;
-}
-
-qpid::types::Variant::List& decodeList(const qpid::messaging::Message& msg) {
-    static qpid::types::Variant::List list;
-    list.clear();
-    qpid::messaging::decode(msg, list);
-    return list;
-}
-
-%}
-
-%include <qpid/ImportExport.h>
-%include <qpid/messaging/ImportExport.h>
-%include <qpid/messaging/Address.h>
-%include <qpid/messaging/Duration.h>
-%include <qpid/messaging/Message.h>
-%include <qpid/messaging/Receiver.h>
-%include <qpid/messaging/Sender.h>
-%include <qpid/messaging/Session.h>
-%include <qpid/messaging/Connection.h>
-%include <qpid/messaging/FailoverUpdates.h>
-
-qpid::types::Variant::Map& decodeMap(const qpid::messaging::Message&);
-qpid::types::Variant::List& decodeList(const qpid::messaging::Message&);
-
-
-%{
-
-%};
-
diff --git a/qpid/cpp/bindings/qpid/ruby/Makefile.am b/qpid/cpp/bindings/qpid/ruby/Makefile.am
index a2a5dd7..e8bc89e 100644
--- a/qpid/cpp/bindings/qpid/ruby/Makefile.am
+++ b/qpid/cpp/bindings/qpid/ruby/Makefile.am
@@ -27,7 +27,7 @@ SWIG_FLAGS = -w362,401
 
 rubylibdir = $(RUBY_LIB)
 
-cqpid.cpp: $(srcdir)/ruby.i $(srcdir)/../qpid.i $(srcdir)/../../swig_ruby_typemaps.i
+cqpid.cpp: $(srcdir)/ruby.i
 	$(SWIG) -ruby -c++ $(SWIG_FLAGS) $(INCLUDES) $(QPID_CXXFLAGS) -I/usr/include -o cqpid.cpp $(srcdir)/ruby.i
 
 rubylibarchdir = $(RUBY_LIB_ARCH)
diff --git a/qpid/cpp/bindings/qpid/ruby/ruby.i b/qpid/cpp/bindings/qpid/ruby/ruby.i
index 76463f7..b9644b9 100644
--- a/qpid/cpp/bindings/qpid/ruby/ruby.i
+++ b/qpid/cpp/bindings/qpid/ruby/ruby.i
@@ -19,7 +19,7 @@
 
 %module cqpid
 %include "std_string.i"
-%include "../../swig_ruby_typemaps.i"
+%include "swig_ruby_typemaps.i"
 
 /* Define the general-purpose exception handling */
 %exception {
@@ -32,5 +32,5 @@
     }
 }
 
-%include "../qpid.i"
+%include "qpid.i"
 
diff --git a/qpid/cpp/bindings/swig_perl_typemaps.i b/qpid/cpp/bindings/swig_perl_typemaps.i
deleted file mode 100644
index 831576a..0000000
--- a/qpid/cpp/bindings/swig_perl_typemaps.i
+++ /dev/null
@@ -1,330 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-%wrapper %{
-
-#include <stdarg.h>
-
-    SV* MapToPerl(const qpid::types::Variant::Map*);
-    SV* ListToPerl(const qpid::types::Variant::List*);
-    void PerlToMap(SV*, qpid::types::Variant::Map*);
-    void PerlToList(SV*, qpid::types::Variant::List*);
-
-    qpid::types::Variant PerlToVariant(SV* value) {
-        if (SvROK(value)) {
-            if (SvTYPE(SvRV(value)) == SVt_PVHV) {
-                qpid::types::Variant::Map map;
-                PerlToMap(value, &map);
-                return qpid::types::Variant(map);
-            }
-            else if (SvTYPE(SvRV(value)) == SVt_PVAV) {
-                qpid::types::Variant::List list;
-                PerlToList(value, &list);
-                return qpid::types::Variant(list);
-            }
-        }
-        else {
-            if (SvIOK(value)) {
-                return qpid::types::Variant((int64_t) SvIV(value));
-             }
-            else if (SvNOK(value)) {
-                return qpid::types::Variant((float)SvNV(value));
-            }
-            else if (SvPOK(value)) {
-                return qpid::types::Variant(std::string(SvPV_nolen(value)));
-            }
-        }
-        return qpid::types::Variant();
-    }
-
-    SV* VariantToPerl(const qpid::types::Variant* v) {
-        SV* result = newSV(0);
-        try {
-            switch (v->getType()) {
-            case qpid::types::VAR_VOID: {
-                sv_setiv(result, (IV)0);
-                break;
-            }
-            case qpid::types::VAR_BOOL : {
-                result = boolSV(v->asBool());
-                break;
-            }
-            case qpid::types::VAR_UINT8 :
-            case qpid::types::VAR_UINT16 :
-            case qpid::types::VAR_UINT32 : {
-                sv_setuv(result, (UV)v->asUint32());
-                break;
-            }
-            case qpid::types::VAR_UINT64 : {
-                sv_setuv(result, (UV)v->asUint64());
-                break;
-            }
-            case qpid::types::VAR_INT8 : 
-            case qpid::types::VAR_INT16 :
-            case qpid::types::VAR_INT32 : {
-                sv_setiv(result, (IV)v->asInt32());
-                break;
-            }
-            case qpid::types::VAR_INT64 : {
-                sv_setiv(result, (IV)v->asInt64());
-                break;
-            }
-            case qpid::types::VAR_FLOAT : {
-                sv_setnv(result, (double)v->asFloat());
-                break;
-            }
-            case qpid::types::VAR_DOUBLE : {
-                sv_setnv(result, (double)v->asDouble());
-                break;
-            }
-            case qpid::types::VAR_STRING : {
-                const std::string val(v->asString());
-                result = newSVpvn(val.c_str(), val.size());
-                break;
-            }
-            case qpid::types::VAR_MAP : {
-                result = MapToPerl(&(v->asMap()));
-                break;
-            }
-            case qpid::types::VAR_LIST : {
-                result = ListToPerl(&(v->asList()));
-                break;
-            }
-            case qpid::types::VAR_UUID : {
-            }
-            }
-        } catch (qpid::types::Exception& ex) {
-            Perl_croak(aTHX_ ex.what());
-        }
-
-        return result;
-    }
-
-    SV* MapToPerl(const qpid::types::Variant::Map* map) {
-        SV *result = newSV(0);
-        HV *hv = (HV *)sv_2mortal((SV *)newHV());
-        qpid::types::Variant::Map::const_iterator iter;
-        for (iter = map->begin(); iter != map->end(); iter++) {
-            const std::string key(iter->first);
-            SV* perlval = VariantToPerl(&(iter->second));
-            hv_store(hv, key.c_str(), key.size(), perlval, 0);
-        }
-        SvSetSV(result, newRV_noinc((SV *)hv));
-        return result;
-    }
-
-    SV* ListToPerl(const qpid::types::Variant::List* list) {
-        SV* result = newSV(0);
-        AV* av  = (AV *)sv_2mortal((SV *)newAV());
-        qpid::types::Variant::List::const_iterator iter;
-        for (iter = list->begin(); iter != list->end(); iter++) {
-            SV* perlval = VariantToPerl(&(*iter));
-            av_push(av, perlval);
-        }
-        SvSetSV(result, newRV_noinc((SV *)av));
-        return result;
-    }
-
-    void PerlToMap(SV* hash, qpid::types::Variant::Map* map) {
-        map->clear();
-        HV* hv = (HV *)SvRV(hash);
-        HE* he;
-        while((he = hv_iternext(hv)) != NULL) {
-            SV* svkey = HeSVKEY_force(he);
-            SV* svval = HeVAL(he);
-            (*map)[std::string(SvPV_nolen(svkey))] = PerlToVariant(svval);
-        }
-    }
-
-    void PerlToList(SV* ary, qpid::types::Variant::List* list) {
-        list->clear();
-        AV * av = (AV *)SvRV(ary);
-        I32 len = av_len(av) + 1;
-        if (len > 0) {
-            for (I32 i = 0; i < len; i++) {
-                list->push_back(PerlToVariant(*av_fetch(av, i, 0)));
-            }
-        }
-    }
-%}
-
-%typemap (in) void * {
-    $1 = (void *)SvIV($input);
-}
-
-%typemap (out) void * {
-    sv_setiv($result, (IV)$1);
-    argvi++;
-}
-
-%typemap (in) uint16_t, uint32_t, uint64_t {
-    if (SvIOK($input)) {
-        $1 = ($1_ltype)SvUV($input);
-    }
-    else {
-        SWIG_exception_fail(SWIG_ValueError, "not an integer");
-    }
-}
-
-%typemap (out) uint16_t, uint32_t, uint64_t {
-    sv_setuv($result, (UV)$1);
-    argvi++;
-}
-
-%typemap (in) int32_t, int64_t {
-    if (SvIOK($input)) {
-        $1 = ($1_ltype)SvIV($input);
-    }
-    else {
-        SWIG_exception_fail(SWIG_ValueError, "not an integer");
-    }
-}
-
-%typemap (out) int32_t, int64_t {
-    sv_setiv($result, (IV)$1);
-    argvi++;
-}
-
-%typemap(in) bool {
-    $1 = (bool)SvTRUE($input);
-}
-
-%typemap (out) bool {
-    $result = boolSV($1);
-    argvi++;
-}
-
-
-%typemap (typecheck, precedence=SWIG_TYPECHECK_UINT64) uint64_t {
-    $1 = SvIOK($input) ? 1 : 0;
-}
-
-%typemap (typecheck, precedence=SWIG_TYPECHECK_UINT32) uint32_t {
-    $1 = SvIOK($input) ? 1 : 0;
-}
-
-
-/*
- * Variant types: C++ --> Perl
- */
-%typemap(out) qpid::types::Variant::Map {
-    $result = MapToPerl(&$1);
-    argvi++;
-}
-
-%typemap(out) qpid::types::Variant::Map& {
-    $result = MapToPerl($1);
-    argvi++;
-}
-
-%typemap(out) qpid::types::Variant::List {
-    $result = ListToPerl(&$1);
-    argvi++;
-}
-
-%typemap(out) qpid::types::Variant::List& {
-    $result = ListToPerl($1);
-    argvi++;
-}
-
-%typemap(out) qpid::types::Variant& {
-    $result = VariantToPerl($1);
-    argvi++;
-}
-
-
-/*
- * Variant types: Perl --> C++
- */
-%typemap(in) qpid::types::Variant& {
-    $1 = new qpid::types::Variant(PerlToVariant($input));
-}
-
-%typemap(in) qpid::types::Variant::Map& {
-    $1 = new qpid::types::Variant::Map();
-    PerlToMap($input, $1);
-
-}
-
-%typemap(in) qpid::types::Variant::List& {
-    $1 = new qpid::types::Variant::List();
-    PerlToList($input, $1);
-
-}
-
-%typemap(in) const qpid::types::Variant::Map const & {
-    $1 = new qpid::types::Variant::Map();
-    PerlToMap($input, $1);
-}
-
-%typemap(in) const qpid::types::Variant::List const & {
-    $1 = new qpid::types::Variant::List();
-    PerlToList($input, $1);
-}
-
-%typemap(freearg) qpid::types::Variant& {
-    delete $1;
-}
-
-%typemap(freearg) qpid::types::Variant::Map& {
-    delete $1;
-}
-
-%typemap(freearg) qpid::types::Variant::List& {
-    delete $1;
-}
-
-
-/*
- * Variant types: typecheck maps
- */
-%typemap(typecheck) qpid::types::Variant::Map& {
-    $1 = (SvTYPE(SvRV($input)) == SVt_PVHV) ? 1 : 0;
-}
-
-%typemap(typecheck) qpid::types::Variant::List& {
-    $1 = (SvTYPE(SvRV($input)) == SVt_PVAV) ? 1 : 0;
-}
-
-%typemap(typecheck) qpid::types::Variant& {
-    $1 = (SvIOK($input) ||
-          SvNOK($input) ||
-          SvPOK($input) ) ? 1 : 0;
-}
-
-%typemap(typecheck) const qpid::types::Variant::Map const & {
-    $1 = (SvTYPE(SvRV($input)) == SVt_PVHV) ? 1 : 0;
-}
-
-%typemap(typecheck) const qpid::types::Variant::List const & {
-    $1 = (SvTYPE(SvRV($input)) == SVt_PVAV) ? 1 : 0;
-}
-
-%typemap(typecheck) const qpid::types::Variant const & {
-    $1 = (SvIOK($input) ||
-          SvNOK($input) ||
-          SvPOK($input) ) ? 1 : 0;
-}
-
-/* No boolean type for perl. 
-   Boolean is simply and integer in perl
-*/
-%typecheck(SWIG_TYPECHECK_BOOL) bool {
-    $1 = (SvIOK($input)) ? 1 : 0;
-}
diff --git a/qpid/cpp/bindings/swig_python_typemaps.i b/qpid/cpp/bindings/swig_python_typemaps.i
deleted file mode 100644
index 25a4e46..0000000
--- a/qpid/cpp/bindings/swig_python_typemaps.i
+++ /dev/null
@@ -1,446 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-/* For UUID objects, to convert them to Python uuid.UUID objects,
- * we'll need a reference to the uuid module.
- */
-%{
-static PyObject* pUuidModule;
-%}
-
-%init %{
-  /* Instead of directly referencing the uuid module (which is not available
-   * on older versions of Python), reference the wrapper defined in
-   * qpid.datatypes.
-   */
-  pUuidModule = PyImport_ImportModule("qpid.datatypes");
-
-  /* Although it is not required, we'll publish the uuid module in our
-   * module, as if this module was a python module and we called
-   * "import uuid"
-   */
-  Py_INCREF(pUuidModule);
-  PyModule_AddObject(m, "uuid", pUuidModule);
-%}
-
-
-%wrapper %{
-
-#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
-typedef int Py_ssize_t;
-#define PY_SSIZE_T_MAX INT_MAX
-#define PY_SSIZE_T_MIN INT_MIN
-#endif
-
-
-    PyObject* MapToPy(const qpid::types::Variant::Map*);
-    PyObject* ListToPy(const qpid::types::Variant::List*);
-    PyObject* UuidToPy(const qpid::types::Uuid*);
-    void PyToMap(PyObject*, qpid::types::Variant::Map*);
-    void PyToList(PyObject*, qpid::types::Variant::List*);
-
-    qpid::types::Variant PyToVariant(PyObject* value) {
-        if (PyBool_Check(value))   return qpid::types::Variant(bool(PyInt_AS_LONG(value) ? true : false));
-        if (PyFloat_Check(value))  return qpid::types::Variant(PyFloat_AS_DOUBLE(value));
-        if (PyInt_Check(value))    return qpid::types::Variant(int64_t(PyInt_AS_LONG(value)));
-        if (PyLong_Check(value))   return qpid::types::Variant(int64_t(PyLong_AsLongLong(value)));
-        if (PyString_Check(value)) return qpid::types::Variant(std::string(PyString_AS_STRING(value)));
-        if (PyDict_Check(value)) {
-            qpid::types::Variant::Map map;
-            PyToMap(value, &map);
-            return qpid::types::Variant(map);
-        }
-        if (PyList_Check(value)) {
-            qpid::types::Variant::List list;
-            PyToList(value, &list);
-            return qpid::types::Variant(list);
-        }
-        return qpid::types::Variant();
-    }
-
-    PyObject* VariantToPy(const qpid::types::Variant* v) {
-        PyObject* result;
-        try {
-            switch (v->getType()) {
-            case qpid::types::VAR_VOID: {
-                result = Py_None;
-                break;
-            }
-            case qpid::types::VAR_BOOL : {
-                result = v->asBool() ? Py_True : Py_False;
-                break;
-            }
-            case qpid::types::VAR_UINT8 :
-            case qpid::types::VAR_UINT16 :
-            case qpid::types::VAR_UINT32 : {
-                result = PyInt_FromLong((long) v->asUint32());
-                break;
-            }
-            case qpid::types::VAR_UINT64 : {
-                result = PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) v->asUint64());
-                break;
-            }
-            case qpid::types::VAR_INT8 : 
-            case qpid::types::VAR_INT16 :
-            case qpid::types::VAR_INT32 : {
-                result = PyInt_FromLong((long) v->asInt32());
-                break;
-            }
-            case qpid::types::VAR_INT64 : {
-                result = PyLong_FromLongLong((PY_LONG_LONG) v->asInt64());
-                break;
-            }
-            case qpid::types::VAR_FLOAT : {
-                result = PyFloat_FromDouble((double) v->asFloat());
-                break;
-            }
-            case qpid::types::VAR_DOUBLE : {
-                result = PyFloat_FromDouble((double) v->asDouble());
-                break;
-            }
-            case qpid::types::VAR_STRING : {
-                const std::string val(v->asString());
-                result = PyString_FromStringAndSize(val.c_str(), val.size());
-                break;
-            }
-            case qpid::types::VAR_MAP : {
-                result = MapToPy(&(v->asMap()));
-                break;
-            }
-            case qpid::types::VAR_LIST : {
-                result = ListToPy(&(v->asList()));
-                break;
-            }
-            case qpid::types::VAR_UUID : {
-                qpid::types::Uuid uuid = v->asUuid();
-                result = UuidToPy(&uuid);
-                break;
-            }
-            }
-        } catch (qpid::types::Exception& ex) {
-            PyErr_SetString(PyExc_RuntimeError, ex.what());
-            result = 0;
-        }
-
-        return result;
-    }
-
-    PyObject* MapToPy(const qpid::types::Variant::Map* map) {
-        PyObject* result = PyDict_New();
-        qpid::types::Variant::Map::const_iterator iter;
-        for (iter = map->begin(); iter != map->end(); iter++) {
-            const std::string key(iter->first);
-            PyObject* pyval = VariantToPy(&(iter->second));
-            if (pyval == 0)
-                return 0;
-            PyDict_SetItem(result, PyString_FromStringAndSize(key.c_str(), key.size()), pyval);
-        }
-        return result;
-    }
-
-    PyObject* ListToPy(const qpid::types::Variant::List* list) {
-        PyObject* result = PyList_New(list->size());
-        qpid::types::Variant::List::const_iterator iter;
-        Py_ssize_t idx(0);
-        for (iter = list->begin(); iter != list->end(); iter++) {
-            PyObject* pyval = VariantToPy(&(*iter));
-            if (pyval == 0)
-                return 0;
-            PyList_SetItem(result, idx, pyval);
-            idx++;
-        }
-        return result;
-    }
-
-    PyObject* UuidToPy(const qpid::types::Uuid * uuid) {
-        PyObject* pUuidClass = PyObject_GetAttrString(pUuidModule, "UUID");
-        if (!pUuidClass) {
-          // Failed to get UUID class
-          return 0;
-        }
-
-        PyObject* pArgs = PyTuple_New(0);
-        PyObject* pKw = PyDict_New();
-        PyObject* pData = PyString_FromStringAndSize(
-          (const char*)(uuid->data()), 16);
-        PyDict_SetItemString(pKw, "bytes", pData);
-
-        PyObject* result = PyObject_Call(pUuidClass, pArgs, pKw);
-
-        Py_DECREF(pData);
-        Py_DECREF(pKw);
-        Py_DECREF(pArgs);
-        Py_DECREF(pUuidClass);
-
-        return result;
-    }
-
-
-    void PyToMap(PyObject* obj, qpid::types::Variant::Map* map) {
-        map->clear();
-        Py_ssize_t iter(0);
-        PyObject *key;
-        PyObject *val;
-        while (PyDict_Next(obj, &iter, &key, &val))
-            (*map)[std::string(PyString_AS_STRING(key))] = PyToVariant(val);
-    }
-
-    void PyToList(PyObject* obj, qpid::types::Variant::List* list) {
-        list->clear();
-        Py_ssize_t count(PyList_Size(obj));
-        for (Py_ssize_t idx = 0; idx < count; idx++)
-            list->push_back(PyToVariant(PyList_GetItem(obj, idx)));
-    }
-
-%}
-
-
-/* unsigned32 Convert from Python --> C */
-%typemap(in) uint32_t {
-    if (PyInt_Check($input)) {
-        $1 = (uint32_t) PyInt_AsUnsignedLongMask($input);
-    } else if (PyLong_Check($input)) {
-        $1 = (uint32_t) PyLong_AsUnsignedLong($input);
-    } else {
-        SWIG_exception_fail(SWIG_ValueError, "unknown integer type");
-    }
-}
-
-/* unsinged32 Convert from C --> Python */
-%typemap(out) uint32_t {
-    $result = PyInt_FromLong((long)$1);
-}
-
-
-/* unsigned16 Convert from Python --> C */
-%typemap(in) uint16_t {
-    if (PyInt_Check($input)) {
-        $1 = (uint16_t) PyInt_AsUnsignedLongMask($input);
-    } else if (PyLong_Check($input)) {
-        $1 = (uint16_t) PyLong_AsUnsignedLong($input);
-    } else {
-        SWIG_exception_fail(SWIG_ValueError, "unknown integer type");
-    }
-}
-
-/* unsigned16 Convert from C --> Python */
-%typemap(out) uint16_t {
-    $result = PyInt_FromLong((long)$1);
-}
-
-
-/* signed32 Convert from Python --> C */
-%typemap(in) int32_t {
-    if (PyInt_Check($input)) {
-        $1 = (int32_t) PyInt_AsLong($input);
-    } else if (PyLong_Check($input)) {
-        $1 = (int32_t) PyLong_AsLong($input);
-    } else {
-        SWIG_exception_fail(SWIG_ValueError, "unknown integer type");
-    }
-}
-
-/* signed32 Convert from C --> Python */
-%typemap(out) int32_t {
-    $result = PyInt_FromLong((long)$1);
-}
-
-
-/* unsigned64 Convert from Python --> C */
-%typemap(in) uint64_t {
-%#ifdef HAVE_LONG_LONG
-    if (PyLong_Check($input)) {
-        $1 = (uint64_t)PyLong_AsUnsignedLongLong($input);
-    } else if (PyInt_Check($input)) {
-        $1 = (uint64_t)PyInt_AsUnsignedLongLongMask($input);
-    } else
-%#endif
-    {
-        SWIG_exception_fail(SWIG_ValueError, "unsupported integer size - uint64_t input too large");
-    }
-}
-
-/* unsigned64 Convert from C --> Python */
-%typemap(out) uint64_t {
-%#ifdef HAVE_LONG_LONG
-    $result = PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG)$1);
-%#else
-    SWIG_exception_fail(SWIG_ValueError, "unsupported integer size - uint64_t output too large");
-%#endif
-}
-
-/* signed64 Convert from Python --> C */
-%typemap(in) int64_t {
-%#ifdef HAVE_LONG_LONG
-    if (PyLong_Check($input)) {
-        $1 = (int64_t)PyLong_AsLongLong($input);
-    } else if (PyInt_Check($input)) {
-        $1 = (int64_t)PyInt_AsLong($input);
-    } else
-%#endif
-    {
-        SWIG_exception_fail(SWIG_ValueError, "unsupported integer size - int64_t input too large");
-    }
-}
-
-/* signed64 Convert from C --> Python */
-%typemap(out) int64_t {
-%#ifdef HAVE_LONG_LONG
-    $result = PyLong_FromLongLong((PY_LONG_LONG)$1);
-%#else
-    SWIG_exception_fail(SWIG_ValueError, "unsupported integer size - int64_t output too large");
-%#endif
-}
-
-
-/* Convert from Python --> C */
-%typemap(in) void * {
-    $1 = (void *)$input;
-}
-
-/* Convert from C --> Python */
-%typemap(out) void * {
-    $result = (PyObject *) $1;
-    Py_INCREF($result);
-}
-
-/*
- * Variant types: C++ --> Python
- */
-%typemap(out) qpid::types::Variant::Map {
-    $result = MapToPy(&$1);
-}
-
-%typemap(out) qpid::types::Variant::Map& {
-    $result = MapToPy($1);
-}
-
-%typemap(out) qpid::types::Variant::List {
-    $result = ListToPy(&$1);
-}
-
-%typemap(out) qpid::types::Variant::List& {
-    $result = ListToPy($1);
-}
-
-%typemap(out) qpid::types::Variant& {
-    $result = VariantToPy($1);
-}
-
-/*
- * UUID type: C++ --> Python
- */
-%typemap(out) qpid::types::UUID & {
-    $result = UuidToPy($1);
-}
-
-
-/*
- * Variant types: Ruby --> C++
- */
-%typemap(in) qpid::types::Variant& {
-    $1 = new qpid::types::Variant(PyToVariant($input));
-}
-
-%typemap(in) qpid::types::Variant::Map& {
-    $1 = new qpid::types::Variant::Map();
-    PyToMap($input, $1);
-}
-
-%typemap(in) qpid::types::Variant::List& {
-    $1 = new qpid::types::Variant::List();
-    PyToList($input, $1);
-}
-
-%typemap(in) const qpid::types::Variant::Map const & {
-    $1 = new qpid::types::Variant::Map();
-    PyToMap($input, $1);
-}
-
-%typemap(in) const qpid::types::Variant::List const & {
-    $1 = new qpid::types::Variant::List();
-    PyToList($input, $1);
-}
-
-%typemap(freearg) qpid::types::Variant& {
-    delete $1;
-}
-
-%typemap(freearg) qpid::types::Variant::Map& {
-    delete $1;
-}
-
-%typemap(freearg) qpid::types::Variant::List& {
-    delete $1;
-}
-
-
-/*
- * Variant types: typecheck maps
- */
-%typemap(typecheck) qpid::types::Variant::Map& {
-    $1 = PyDict_Check($input) ? 1 : 0;
-}
-
-%typemap(typecheck)  qpid::types::Variant::List& {
-    $1 = PyList_Check($input) ? 1 : 0;
-}
-
-%typemap(typecheck) qpid::types::Variant& {
-    $1 = (PyFloat_Check($input)  ||
-          PyString_Check($input) ||
-          PyInt_Check($input)    ||
-          PyLong_Check($input)   ||
-          PyDict_Check($input)   ||
-          PyList_Check($input)   ||
-          PyBool_Check($input)) ? 1 : 0;
-}
-
-%typemap(typecheck) const qpid::types::Variant::Map const & {
-    $1 = PyDict_Check($input) ? 1 : 0;
-}
-
-%typemap(typecheck) const qpid::types::Variant::List const & {
-    $1 = PyList_Check($input) ? 1 : 0;
-}
-
-%typemap(typecheck) const qpid::types::Variant const & {
-    $1 = (PyFloat_Check($input)  ||
-          PyString_Check($input) ||
-          PyInt_Check($input)    ||
-          PyLong_Check($input)   ||
-          PyDict_Check($input)   ||
-          PyList_Check($input)   ||
-          PyBool_Check($input)) ? 1 : 0;
-}
-
-%typemap(typecheck) bool {
-    $1 = PyBool_Check($input) ? 1 : 0;
-}
-
-
-
-%typemap (typecheck, precedence=SWIG_TYPECHECK_UINT64) uint64_t {
-    $1 = PyLong_Check($input) ? 1 : 0;
-}
-
-%typemap (typecheck, precedence=SWIG_TYPECHECK_UINT32) uint32_t {
-    $1 = PyInt_Check($input) ? 1 : 0;
-}
-
diff --git a/qpid/cpp/bindings/swig_ruby_typemaps.i b/qpid/cpp/bindings/swig_ruby_typemaps.i
deleted file mode 100644
index 1a07cc8..0000000
--- a/qpid/cpp/bindings/swig_ruby_typemaps.i
+++ /dev/null
@@ -1,368 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-%wrapper %{
-
-#include <stdarg.h>
-
-    VALUE MapToRb(const qpid::types::Variant::Map*);
-    VALUE ListToRb(const qpid::types::Variant::List*);
-    void RbToMap(VALUE, qpid::types::Variant::Map*);
-    void RbToList(VALUE, qpid::types::Variant::List*);
-
-    qpid::types::Variant RbToVariant(VALUE value) {
-        switch (TYPE(value)) {
-        case T_FLOAT:   return qpid::types::Variant(NUM2DBL(value));
-        case T_STRING:  return qpid::types::Variant(StringValuePtr(value));
-        case T_FIXNUM:  return qpid::types::Variant((int64_t) FIX2LONG(value));
-        case T_BIGNUM:  return qpid::types::Variant((int64_t) NUM2LL(value));
-        case T_TRUE:    return qpid::types::Variant(true);
-        case T_FALSE:   return qpid::types::Variant(false);
-        case T_HASH: {
-            qpid::types::Variant::Map map;
-            RbToMap(value, &map);
-            return qpid::types::Variant(map);
-        }
-        case T_ARRAY: {
-            qpid::types::Variant::List list;
-            RbToList(value, &list);
-            return qpid::types::Variant(list);
-        }
-        default: return qpid::types::Variant();
-        }
-    }
-
-    VALUE VariantToRb(const qpid::types::Variant* v) {
-        VALUE result = Qnil;
-        try {
-            switch (v->getType()) {
-            case qpid::types::VAR_VOID: {
-                result = Qnil;
-                break;
-            }
-            case qpid::types::VAR_BOOL : {
-                result = v->asBool() ? Qtrue : Qfalse;
-                break;
-            }
-            case qpid::types::VAR_UINT8 :
-            case qpid::types::VAR_UINT16 :
-            case qpid::types::VAR_UINT32 : {
-                result = UINT2NUM(v->asUint32());
-                break;
-            }
-            case qpid::types::VAR_UINT64 : {
-                result = ULL2NUM(v->asUint64());
-                break;
-            }
-            case qpid::types::VAR_INT8 : 
-            case qpid::types::VAR_INT16 :
-            case qpid::types::VAR_INT32 : {
-                result = INT2NUM(v->asInt32());
-                break;
-            }
-            case qpid::types::VAR_INT64 : {
-                result = LL2NUM(v->asInt64());
-                break;
-            }
-            case qpid::types::VAR_FLOAT : {
-                result = rb_float_new((double) v->asFloat());
-                break;
-            }
-            case qpid::types::VAR_DOUBLE : {
-                result = rb_float_new(v->asDouble());
-                break;
-            }
-            case qpid::types::VAR_STRING : {
-                const std::string val(v->asString());
-                result = rb_str_new(val.c_str(), val.size());
-                break;
-            }
-            case qpid::types::VAR_MAP : {
-                result = MapToRb(&(v->asMap()));
-                break;
-            }
-            case qpid::types::VAR_LIST : {
-                result = ListToRb(&(v->asList()));
-                break;
-            }
-            case qpid::types::VAR_UUID : {
-            }
-            }
-        } catch (qpid::types::Exception& ex) {
-            static VALUE error = rb_define_class("Error", rb_eStandardError);
-            rb_raise(error, ex.what());
-        }
-
-        return result;
-    }
-
-    VALUE MapToRb(const qpid::types::Variant::Map* map) {
-        VALUE result = rb_hash_new();
-        qpid::types::Variant::Map::const_iterator iter;
-        for (iter = map->begin(); iter != map->end(); iter++) {
-            const std::string key(iter->first);
-            VALUE rbval = VariantToRb(&(iter->second));
-            rb_hash_aset(result, rb_str_new(key.c_str(), key.size()), rbval);
-        }
-        return result;
-    }
-
-    VALUE ListToRb(const qpid::types::Variant::List* list) {
-        VALUE result = rb_ary_new2(list->size());
-        qpid::types::Variant::List::const_iterator iter;
-        for (iter = list->begin(); iter != list->end(); iter++) {
-            VALUE rbval = VariantToRb(&(*iter));
-            rb_ary_push(result, rbval);
-        }
-        return result;
-    }
-
-    VALUE HashIter(VALUE data_ary, VALUE context) {
-        VALUE key = rb_ary_entry(data_ary, 0);
-        VALUE val = rb_ary_entry(data_ary, 1);
-        qpid::types::Variant::Map* map((qpid::types::Variant::Map*) context);
-        (*map)[std::string(StringValuePtr(key))] = RbToVariant(val);
-        return data_ary;
-    }
-
-    VALUE AryIter(VALUE data, VALUE context) {
-        qpid::types::Variant::List* list((qpid::types::Variant::List*) context);
-        list->push_back(RbToVariant(data));
-        return data;
-    }
-
-    void RbToMap(VALUE hash, qpid::types::Variant::Map* map) {
-        map->clear();
-        rb_iterate(rb_each, hash, (VALUE(*)(ANYARGS))HashIter, (VALUE) map);
-    }
-
-    void RbToList(VALUE ary, qpid::types::Variant::List* list) {
-        list->clear();
-        rb_iterate(rb_each, ary, (VALUE(*)(ANYARGS))AryIter, (VALUE) list);
-    }
-%}
-
-%typemap (in) void *
-{
-    $1 = (void *) $input;
-}
-
-%typemap (out) void *
-{
-    $result = (VALUE) $1;
-}
-
-%typemap (in) uint8_t
-{
-  $1 = NUM2UINT ($input);
-}
-
-%typemap (out) uint8_t
-{
-  $result = UINT2NUM((uint8_t) $1);
-}
-
-%typemap (in) int8_t
-{
-  $1 = NUM2INT ($input);
-}
-
-%typemap (out) int8_t
-{
-  $result = INT2NUM((int8_t) $1);
-}
-
-%typemap (in) uint16_t
-{
-    $1 = NUM2UINT ($input);
-}
-
-%typemap (out) uint16_t
-{
-    $result = UINT2NUM((uint16_t) $1);
-}
-
-%typemap (in) uint32_t
-{
-    if (TYPE($input) == T_BIGNUM)
-        $1 = NUM2UINT($input);
-    else
-        $1 = FIX2UINT($input);
-}
-
-%typemap (out) uint32_t
-{
-    $result = UINT2NUM((uint32_t) $1);
-}
-
-%typemap (in) int32_t
-{
-    if (TYPE($input) == T_BIGNUM)
-        $1 = NUM2INT($input);
-    else
-        $1 = FIX2INT($input);
-}
-
-%typemap (out) int32_t
-{
-    $result = INT2NUM((int32_t) $1);
-}
-
-%typemap (typecheck, precedence=SWIG_TYPECHECK_INTEGER) uint32_t {
-   $1 = FIXNUM_P($input);
-}
-
-%typemap (in) uint64_t
-{
-    if (TYPE($input) == T_BIGNUM)
-        $1 = NUM2ULL($input);
-    else
-        $1 = (uint64_t) FIX2ULONG($input);
-}
-
-%typemap (out) uint64_t
-{
-    $result = ULL2NUM((uint64_t) $1);
-}
-
-%typemap (in) int64_t
-{
-    if (TYPE($input) == T_BIGNUM)
-        $1 = NUM2LL($input);
-    else
-        $1 = (int64_t) FIX2LONG($input);
-}
-
-%typemap (out) int64_t
-{
-    $result = LL2NUM((int64_t) $1);
-}
-
-/*
- * Variant types: C++ --> Ruby
- */
-%typemap(out) qpid::types::Variant::Map {
-    $result = MapToRb(&$1);
-}
-
-%typemap(out) qpid::types::Variant::Map& {
-    $result = MapToRb($1);
-}
-
-%typemap(out) qpid::types::Variant::List {
-    $result = ListToRb(&$1);
-}
-
-%typemap(out) qpid::types::Variant::List& {
-    $result = ListToRb($1);
-}
-
-%typemap(out) qpid::types::Variant& {
-    $result = VariantToRb($1);
-}
-
-
-/*
- * Variant types: Ruby --> C++
- */
-%typemap(in) qpid::types::Variant& {
-    $1 = new qpid::types::Variant(RbToVariant($input));
-}
-
-%typemap(in) qpid::types::Variant::Map& {
-    $1 = new qpid::types::Variant::Map();
-    RbToMap($input, $1);
-}
-
-%typemap(in) qpid::types::Variant::List& {
-    $1 = new qpid::types::Variant::List();
-    RbToList($input, $1);
-}
-
-%typemap(in) const qpid::types::Variant::Map const & {
-    $1 = new qpid::types::Variant::Map();
-    RbToMap($input, $1);
-}
-
-%typemap(in) const qpid::types::Variant::List const & {
-    $1 = new qpid::types::Variant::List();
-    RbToList($input, $1);
-}
-
-%typemap(freearg) qpid::types::Variant& {
-    delete $1;
-}
-
-%typemap(freearg) qpid::types::Variant::Map& {
-    delete $1;
-}
-
-%typemap(freearg) qpid::types::Variant::List& {
-    delete $1;
-}
-
-
-/*
- * Variant types: typecheck maps
- */
-%typemap(typecheck) qpid::types::Variant::Map& {
-    $1 = (TYPE($input) == T_HASH) ? 1 : 0;
-}
-
-%typemap(typecheck) qpid::types::Variant::List& {
-    $1 = (TYPE($input) == T_ARRAY) ? 1 : 0;
-}
-
-%typemap(typecheck) qpid::types::Variant& {
-    $1 = (TYPE($input) == T_FLOAT  ||
-          TYPE($input) == T_STRING ||
-          TYPE($input) == T_FIXNUM ||
-          TYPE($input) == T_BIGNUM ||
-          TYPE($input) == T_TRUE   ||
-          TYPE($input) == T_FALSE) ? 1 : 0;
-}
-
-%typemap(typecheck) qpid::types::Variant::Map const & {
-    $1 = (TYPE($input) == T_HASH) ? 1 : 0;
-}
-
-%typemap(typecheck) qpid::types::Variant::List const & {
-    $1 = (TYPE($input) == T_ARRAY) ? 1 : 0;
-}
-
-%typemap(typecheck) const qpid::types::Variant const & {
-    $1 = (TYPE($input) == T_FLOAT  ||
-          TYPE($input) == T_STRING ||
-          TYPE($input) == T_FIXNUM ||
-          TYPE($input) == T_BIGNUM ||
-          TYPE($input) == T_TRUE   ||
-          TYPE($input) == T_FALSE) ? 1 : 0;
-}
-
-%typemap(typecheck) bool {
-    $1 = (TYPE($input) == T_TRUE ||
-          TYPE($input) == T_FALSE) ? 1 : 0;
-}
-
-
-
-%typemap (typecheck, precedence=SWIG_TYPECHECK_INTEGER) uint64_t {
-   $1 = FIXNUM_P($input);
-}
-
diff --git a/qpid/cpp/include/qmf2.i b/qpid/cpp/include/qmf2.i
new file mode 100644
index 0000000..0f573fe
--- /dev/null
+++ b/qpid/cpp/include/qmf2.i
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+%{
+
+#include <qmf/exceptions.h>
+#include <qmf/AgentEvent.h>
+#include <qmf/Agent.h>
+#include <qmf/AgentSession.h>
+#include <qmf/ConsoleEvent.h>
+#include <qmf/ConsoleSession.h>
+#include <qmf/DataAddr.h>
+#include <qmf/Data.h>
+#include <qmf/Query.h>
+#include <qmf/Schema.h>
+#include <qmf/SchemaId.h>
+#include <qmf/SchemaMethod.h>
+#include <qmf/SchemaProperty.h>
+#include <qmf/SchemaTypes.h>
+#include <qmf/Subscription.h>
+
+%}
+
+%include <qpid/ImportExport.h>
+%include <qpid/messaging/ImportExport.h>
+%include <qpid/messaging/Duration.h>
+
+%include <qmf/ImportExport.h>
+%include <qmf/exceptions.h>
+%include <qmf/AgentEvent.h>
+%include <qmf/Agent.h>
+%include <qmf/AgentSession.h>
+%include <qmf/ConsoleEvent.h>
+%include <qmf/ConsoleSession.h>
+%include <qmf/DataAddr.h>
+%include <qmf/Data.h>
+%include <qmf/Query.h>
+%include <qmf/Schema.h>
+%include <qmf/SchemaId.h>
+%include <qmf/SchemaMethod.h>
+%include <qmf/SchemaProperty.h>
+%include <qmf/SchemaTypes.h>
+%include <qmf/Subscription.h>
+
+%{
+
+using namespace qmf;
+
+%};
+
diff --git a/qpid/cpp/include/qmfengine.i b/qpid/cpp/include/qmfengine.i
new file mode 100644
index 0000000..eb35011
--- /dev/null
+++ b/qpid/cpp/include/qmfengine.i
@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+%{
+
+#include "qmf/engine/Agent.h"
+#include "qmf/engine/Console.h"
+#include "qmf/engine/ResilientConnection.h"
+
+%}
+
+%include <qmf/engine/QmfEngineImportExport.h>
+%include <qmf/engine/Query.h>
+%include <qmf/engine/Message.h>
+%include <qmf/engine/Agent.h>
+%include <qmf/engine/Console.h>
+%include <qmf/engine/ConnectionSettings.h>
+%include <qmf/engine/ResilientConnection.h>
+%include <qmf/engine/Typecode.h>
+%include <qmf/engine/Schema.h>
+%include <qmf/engine/Value.h>
+%include <qmf/engine/ObjectId.h>
+%include <qmf/engine/Object.h>
+%include <qmf/engine/Event.h>
+
+
+%inline {
+
+using namespace std;
+using namespace qmf::engine;
+
+namespace qmf {
+namespace engine {
+
+}
+}
+}
+
+
+%{
+
+%};
+
diff --git a/qpid/cpp/include/qpid.i b/qpid/cpp/include/qpid.i
new file mode 100644
index 0000000..352bafa
--- /dev/null
+++ b/qpid/cpp/include/qpid.i
@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+%{
+
+#include <qpid/messaging/exceptions.h>
+#include <qpid/messaging/Address.h>
+#include <qpid/messaging/Connection.h>
+#include <qpid/messaging/Session.h>
+#include <qpid/messaging/Receiver.h>
+#include <qpid/messaging/Sender.h>
+#include <qpid/messaging/Message.h>
+#include <qpid/messaging/Duration.h>
+#include <qpid/messaging/FailoverUpdates.h>
+
+//
+// Wrapper functions for map-decode and list-decode.  This allows us to avoid
+// the complexity of output parameter mapping.
+//
+qpid::types::Variant::Map& decodeMap(const qpid::messaging::Message& msg) {
+    static qpid::types::Variant::Map map;
+    map.clear();
+    qpid::messaging::decode(msg, map);
+    return map;
+}
+
+qpid::types::Variant::List& decodeList(const qpid::messaging::Message& msg) {
+    static qpid::types::Variant::List list;
+    list.clear();
+    qpid::messaging::decode(msg, list);
+    return list;
+}
+
+%}
+
+%include <qpid/ImportExport.h>
+%include <qpid/messaging/ImportExport.h>
+%include <qpid/messaging/Address.h>
+%include <qpid/messaging/Duration.h>
+%include <qpid/messaging/Message.h>
+%include <qpid/messaging/Receiver.h>
+%include <qpid/messaging/Sender.h>
+%include <qpid/messaging/Session.h>
+%include <qpid/messaging/Connection.h>
+%include <qpid/messaging/FailoverUpdates.h>
+
+qpid::types::Variant::Map& decodeMap(const qpid::messaging::Message&);
+qpid::types::Variant::List& decodeList(const qpid::messaging::Message&);
+
+
+%{
+
+%};
+
diff --git a/qpid/cpp/include/swig_perl_typemaps.i b/qpid/cpp/include/swig_perl_typemaps.i
new file mode 100644
index 0000000..831576a
--- /dev/null
+++ b/qpid/cpp/include/swig_perl_typemaps.i
@@ -0,0 +1,330 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+%wrapper %{
+
+#include <stdarg.h>
+
+    SV* MapToPerl(const qpid::types::Variant::Map*);
+    SV* ListToPerl(const qpid::types::Variant::List*);
+    void PerlToMap(SV*, qpid::types::Variant::Map*);
+    void PerlToList(SV*, qpid::types::Variant::List*);
+
+    qpid::types::Variant PerlToVariant(SV* value) {
+        if (SvROK(value)) {
+            if (SvTYPE(SvRV(value)) == SVt_PVHV) {
+                qpid::types::Variant::Map map;
+                PerlToMap(value, &map);
+                return qpid::types::Variant(map);
+            }
+            else if (SvTYPE(SvRV(value)) == SVt_PVAV) {
+                qpid::types::Variant::List list;
+                PerlToList(value, &list);
+                return qpid::types::Variant(list);
+            }
+        }
+        else {
+            if (SvIOK(value)) {
+                return qpid::types::Variant((int64_t) SvIV(value));
+             }
+            else if (SvNOK(value)) {
+                return qpid::types::Variant((float)SvNV(value));
+            }
+            else if (SvPOK(value)) {
+                return qpid::types::Variant(std::string(SvPV_nolen(value)));
+            }
+        }
+        return qpid::types::Variant();
+    }
+
+    SV* VariantToPerl(const qpid::types::Variant* v) {
+        SV* result = newSV(0);
+        try {
+            switch (v->getType()) {
+            case qpid::types::VAR_VOID: {
+                sv_setiv(result, (IV)0);
+                break;
+            }
+            case qpid::types::VAR_BOOL : {
+                result = boolSV(v->asBool());
+                break;
+            }
+            case qpid::types::VAR_UINT8 :
+            case qpid::types::VAR_UINT16 :
+            case qpid::types::VAR_UINT32 : {
+                sv_setuv(result, (UV)v->asUint32());
+                break;
+            }
+            case qpid::types::VAR_UINT64 : {
+                sv_setuv(result, (UV)v->asUint64());
+                break;
+            }
+            case qpid::types::VAR_INT8 : 
+            case qpid::types::VAR_INT16 :
+            case qpid::types::VAR_INT32 : {
+                sv_setiv(result, (IV)v->asInt32());
+                break;
+            }
+            case qpid::types::VAR_INT64 : {
+                sv_setiv(result, (IV)v->asInt64());
+                break;
+            }
+            case qpid::types::VAR_FLOAT : {
+                sv_setnv(result, (double)v->asFloat());
+                break;
+            }
+            case qpid::types::VAR_DOUBLE : {
+                sv_setnv(result, (double)v->asDouble());
+                break;
+            }
+            case qpid::types::VAR_STRING : {
+                const std::string val(v->asString());
+                result = newSVpvn(val.c_str(), val.size());
+                break;
+            }
+            case qpid::types::VAR_MAP : {
+                result = MapToPerl(&(v->asMap()));
+                break;
+            }
+            case qpid::types::VAR_LIST : {
+                result = ListToPerl(&(v->asList()));
+                break;
+            }
+            case qpid::types::VAR_UUID : {
+            }
+            }
+        } catch (qpid::types::Exception& ex) {
+            Perl_croak(aTHX_ ex.what());
+        }
+
+        return result;
+    }
+
+    SV* MapToPerl(const qpid::types::Variant::Map* map) {
+        SV *result = newSV(0);
+        HV *hv = (HV *)sv_2mortal((SV *)newHV());
+        qpid::types::Variant::Map::const_iterator iter;
+        for (iter = map->begin(); iter != map->end(); iter++) {
+            const std::string key(iter->first);
+            SV* perlval = VariantToPerl(&(iter->second));
+            hv_store(hv, key.c_str(), key.size(), perlval, 0);
+        }
+        SvSetSV(result, newRV_noinc((SV *)hv));
+        return result;
+    }
+
+    SV* ListToPerl(const qpid::types::Variant::List* list) {
+        SV* result = newSV(0);
+        AV* av  = (AV *)sv_2mortal((SV *)newAV());
+        qpid::types::Variant::List::const_iterator iter;
+        for (iter = list->begin(); iter != list->end(); iter++) {
+            SV* perlval = VariantToPerl(&(*iter));
+            av_push(av, perlval);
+        }
+        SvSetSV(result, newRV_noinc((SV *)av));
+        return result;
+    }
+
+    void PerlToMap(SV* hash, qpid::types::Variant::Map* map) {
+        map->clear();
+        HV* hv = (HV *)SvRV(hash);
+        HE* he;
+        while((he = hv_iternext(hv)) != NULL) {
+            SV* svkey = HeSVKEY_force(he);
+            SV* svval = HeVAL(he);
+            (*map)[std::string(SvPV_nolen(svkey))] = PerlToVariant(svval);
+        }
+    }
+
+    void PerlToList(SV* ary, qpid::types::Variant::List* list) {
+        list->clear();
+        AV * av = (AV *)SvRV(ary);
+        I32 len = av_len(av) + 1;
+        if (len > 0) {
+            for (I32 i = 0; i < len; i++) {
+                list->push_back(PerlToVariant(*av_fetch(av, i, 0)));
+            }
+        }
+    }
+%}
+
+%typemap (in) void * {
+    $1 = (void *)SvIV($input);
+}
+
+%typemap (out) void * {
+    sv_setiv($result, (IV)$1);
+    argvi++;
+}
+
+%typemap (in) uint16_t, uint32_t, uint64_t {
+    if (SvIOK($input)) {
+        $1 = ($1_ltype)SvUV($input);
+    }
+    else {
+        SWIG_exception_fail(SWIG_ValueError, "not an integer");
+    }
+}
+
+%typemap (out) uint16_t, uint32_t, uint64_t {
+    sv_setuv($result, (UV)$1);
+    argvi++;
+}
+
+%typemap (in) int32_t, int64_t {
+    if (SvIOK($input)) {
+        $1 = ($1_ltype)SvIV($input);
+    }
+    else {
+        SWIG_exception_fail(SWIG_ValueError, "not an integer");
+    }
+}
+
+%typemap (out) int32_t, int64_t {
+    sv_setiv($result, (IV)$1);
+    argvi++;
+}
+
+%typemap(in) bool {
+    $1 = (bool)SvTRUE($input);
+}
+
+%typemap (out) bool {
+    $result = boolSV($1);
+    argvi++;
+}
+
+
+%typemap (typecheck, precedence=SWIG_TYPECHECK_UINT64) uint64_t {
+    $1 = SvIOK($input) ? 1 : 0;
+}
+
+%typemap (typecheck, precedence=SWIG_TYPECHECK_UINT32) uint32_t {
+    $1 = SvIOK($input) ? 1 : 0;
+}
+
+
+/*
+ * Variant types: C++ --> Perl
+ */
+%typemap(out) qpid::types::Variant::Map {
+    $result = MapToPerl(&$1);
+    argvi++;
+}
+
+%typemap(out) qpid::types::Variant::Map& {
+    $result = MapToPerl($1);
+    argvi++;
+}
+
+%typemap(out) qpid::types::Variant::List {
+    $result = ListToPerl(&$1);
+    argvi++;
+}
+
+%typemap(out) qpid::types::Variant::List& {
+    $result = ListToPerl($1);
+    argvi++;
+}
+
+%typemap(out) qpid::types::Variant& {
+    $result = VariantToPerl($1);
+    argvi++;
+}
+
+
+/*
+ * Variant types: Perl --> C++
+ */
+%typemap(in) qpid::types::Variant& {
+    $1 = new qpid::types::Variant(PerlToVariant($input));
+}
+
+%typemap(in) qpid::types::Variant::Map& {
+    $1 = new qpid::types::Variant::Map();
+    PerlToMap($input, $1);
+
+}
+
+%typemap(in) qpid::types::Variant::List& {
+    $1 = new qpid::types::Variant::List();
+    PerlToList($input, $1);
+
+}
+
+%typemap(in) const qpid::types::Variant::Map const & {
+    $1 = new qpid::types::Variant::Map();
+    PerlToMap($input, $1);
+}
+
+%typemap(in) const qpid::types::Variant::List const & {
+    $1 = new qpid::types::Variant::List();
+    PerlToList($input, $1);
+}
+
+%typemap(freearg) qpid::types::Variant& {
+    delete $1;
+}
+
+%typemap(freearg) qpid::types::Variant::Map& {
+    delete $1;
+}
+
+%typemap(freearg) qpid::types::Variant::List& {
+    delete $1;
+}
+
+
+/*
+ * Variant types: typecheck maps
+ */
+%typemap(typecheck) qpid::types::Variant::Map& {
+    $1 = (SvTYPE(SvRV($input)) == SVt_PVHV) ? 1 : 0;
+}
+
+%typemap(typecheck) qpid::types::Variant::List& {
+    $1 = (SvTYPE(SvRV($input)) == SVt_PVAV) ? 1 : 0;
+}
+
+%typemap(typecheck) qpid::types::Variant& {
+    $1 = (SvIOK($input) ||
+          SvNOK($input) ||
+          SvPOK($input) ) ? 1 : 0;
+}
+
+%typemap(typecheck) const qpid::types::Variant::Map const & {
+    $1 = (SvTYPE(SvRV($input)) == SVt_PVHV) ? 1 : 0;
+}
+
+%typemap(typecheck) const qpid::types::Variant::List const & {
+    $1 = (SvTYPE(SvRV($input)) == SVt_PVAV) ? 1 : 0;
+}
+
+%typemap(typecheck) const qpid::types::Variant const & {
+    $1 = (SvIOK($input) ||
+          SvNOK($input) ||
+          SvPOK($input) ) ? 1 : 0;
+}
+
+/* No boolean type for perl. 
+   Boolean is simply and integer in perl
+*/
+%typecheck(SWIG_TYPECHECK_BOOL) bool {
+    $1 = (SvIOK($input)) ? 1 : 0;
+}
diff --git a/qpid/cpp/include/swig_python_typemaps.i b/qpid/cpp/include/swig_python_typemaps.i
new file mode 100644
index 0000000..25a4e46
--- /dev/null
+++ b/qpid/cpp/include/swig_python_typemaps.i
@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+/* For UUID objects, to convert them to Python uuid.UUID objects,
+ * we'll need a reference to the uuid module.
+ */
+%{
+static PyObject* pUuidModule;
+%}
+
+%init %{
+  /* Instead of directly referencing the uuid module (which is not available
+   * on older versions of Python), reference the wrapper defined in
+   * qpid.datatypes.
+   */
+  pUuidModule = PyImport_ImportModule("qpid.datatypes");
+
+  /* Although it is not required, we'll publish the uuid module in our
+   * module, as if this module was a python module and we called
+   * "import uuid"
+   */
+  Py_INCREF(pUuidModule);
+  PyModule_AddObject(m, "uuid", pUuidModule);
+%}
+
+
+%wrapper %{
+
+#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
+typedef int Py_ssize_t;
+#define PY_SSIZE_T_MAX INT_MAX
+#define PY_SSIZE_T_MIN INT_MIN
+#endif
+
+
+    PyObject* MapToPy(const qpid::types::Variant::Map*);
+    PyObject* ListToPy(const qpid::types::Variant::List*);
+    PyObject* UuidToPy(const qpid::types::Uuid*);
+    void PyToMap(PyObject*, qpid::types::Variant::Map*);
+    void PyToList(PyObject*, qpid::types::Variant::List*);
+
+    qpid::types::Variant PyToVariant(PyObject* value) {
+        if (PyBool_Check(value))   return qpid::types::Variant(bool(PyInt_AS_LONG(value) ? true : false));
+        if (PyFloat_Check(value))  return qpid::types::Variant(PyFloat_AS_DOUBLE(value));
+        if (PyInt_Check(value))    return qpid::types::Variant(int64_t(PyInt_AS_LONG(value)));
+        if (PyLong_Check(value))   return qpid::types::Variant(int64_t(PyLong_AsLongLong(value)));
+        if (PyString_Check(value)) return qpid::types::Variant(std::string(PyString_AS_STRING(value)));
+        if (PyDict_Check(value)) {
+            qpid::types::Variant::Map map;
+            PyToMap(value, &map);
+            return qpid::types::Variant(map);
+        }
+        if (PyList_Check(value)) {
+            qpid::types::Variant::List list;
+            PyToList(value, &list);
+            return qpid::types::Variant(list);
+        }
+        return qpid::types::Variant();
+    }
+
+    PyObject* VariantToPy(const qpid::types::Variant* v) {
+        PyObject* result;
+        try {
+            switch (v->getType()) {
+            case qpid::types::VAR_VOID: {
+                result = Py_None;
+                break;
+            }
+            case qpid::types::VAR_BOOL : {
+                result = v->asBool() ? Py_True : Py_False;
+                break;
+            }
+            case qpid::types::VAR_UINT8 :
+            case qpid::types::VAR_UINT16 :
+            case qpid::types::VAR_UINT32 : {
+                result = PyInt_FromLong((long) v->asUint32());
+                break;
+            }
+            case qpid::types::VAR_UINT64 : {
+                result = PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) v->asUint64());
+                break;
+            }
+            case qpid::types::VAR_INT8 : 
+            case qpid::types::VAR_INT16 :
+            case qpid::types::VAR_INT32 : {
+                result = PyInt_FromLong((long) v->asInt32());
+                break;
+            }
+            case qpid::types::VAR_INT64 : {
+                result = PyLong_FromLongLong((PY_LONG_LONG) v->asInt64());
+                break;
+            }
+            case qpid::types::VAR_FLOAT : {
+                result = PyFloat_FromDouble((double) v->asFloat());
+                break;
+            }
+            case qpid::types::VAR_DOUBLE : {
+                result = PyFloat_FromDouble((double) v->asDouble());
+                break;
+            }
+            case qpid::types::VAR_STRING : {
+                const std::string val(v->asString());
+                result = PyString_FromStringAndSize(val.c_str(), val.size());
+                break;
+            }
+            case qpid::types::VAR_MAP : {
+                result = MapToPy(&(v->asMap()));
+                break;
+            }
+            case qpid::types::VAR_LIST : {
+                result = ListToPy(&(v->asList()));
+                break;
+            }
+            case qpid::types::VAR_UUID : {
+                qpid::types::Uuid uuid = v->asUuid();
+                result = UuidToPy(&uuid);
+                break;
+            }
+            }
+        } catch (qpid::types::Exception& ex) {
+            PyErr_SetString(PyExc_RuntimeError, ex.what());
+            result = 0;
+        }
+
+        return result;
+    }
+
+    PyObject* MapToPy(const qpid::types::Variant::Map* map) {
+        PyObject* result = PyDict_New();
+        qpid::types::Variant::Map::const_iterator iter;
+        for (iter = map->begin(); iter != map->end(); iter++) {
+            const std::string key(iter->first);
+            PyObject* pyval = VariantToPy(&(iter->second));
+            if (pyval == 0)
+                return 0;
+            PyDict_SetItem(result, PyString_FromStringAndSize(key.c_str(), key.size()), pyval);
+        }
+        return result;
+    }
+
+    PyObject* ListToPy(const qpid::types::Variant::List* list) {
+        PyObject* result = PyList_New(list->size());
+        qpid::types::Variant::List::const_iterator iter;
+        Py_ssize_t idx(0);
+        for (iter = list->begin(); iter != list->end(); iter++) {
+            PyObject* pyval = VariantToPy(&(*iter));
+            if (pyval == 0)
+                return 0;
+            PyList_SetItem(result, idx, pyval);
+            idx++;
+        }
+        return result;
+    }
+
+    PyObject* UuidToPy(const qpid::types::Uuid * uuid) {
+        PyObject* pUuidClass = PyObject_GetAttrString(pUuidModule, "UUID");
+        if (!pUuidClass) {
+          // Failed to get UUID class
+          return 0;
+        }
+
+        PyObject* pArgs = PyTuple_New(0);
+        PyObject* pKw = PyDict_New();
+        PyObject* pData = PyString_FromStringAndSize(
+          (const char*)(uuid->data()), 16);
+        PyDict_SetItemString(pKw, "bytes", pData);
+
+        PyObject* result = PyObject_Call(pUuidClass, pArgs, pKw);
+
+        Py_DECREF(pData);
+        Py_DECREF(pKw);
+        Py_DECREF(pArgs);
+        Py_DECREF(pUuidClass);
+
+        return result;
+    }
+
+
+    void PyToMap(PyObject* obj, qpid::types::Variant::Map* map) {
+        map->clear();
+        Py_ssize_t iter(0);
+        PyObject *key;
+        PyObject *val;
+        while (PyDict_Next(obj, &iter, &key, &val))
+            (*map)[std::string(PyString_AS_STRING(key))] = PyToVariant(val);
+    }
+
+    void PyToList(PyObject* obj, qpid::types::Variant::List* list) {
+        list->clear();
+        Py_ssize_t count(PyList_Size(obj));
+        for (Py_ssize_t idx = 0; idx < count; idx++)
+            list->push_back(PyToVariant(PyList_GetItem(obj, idx)));
+    }
+
+%}
+
+
+/* unsigned32 Convert from Python --> C */
+%typemap(in) uint32_t {
+    if (PyInt_Check($input)) {
+        $1 = (uint32_t) PyInt_AsUnsignedLongMask($input);
+    } else if (PyLong_Check($input)) {
+        $1 = (uint32_t) PyLong_AsUnsignedLong($input);
+    } else {
+        SWIG_exception_fail(SWIG_ValueError, "unknown integer type");
+    }
+}
+
+/* unsinged32 Convert from C --> Python */
+%typemap(out) uint32_t {
+    $result = PyInt_FromLong((long)$1);
+}
+
+
+/* unsigned16 Convert from Python --> C */
+%typemap(in) uint16_t {
+    if (PyInt_Check($input)) {
+        $1 = (uint16_t) PyInt_AsUnsignedLongMask($input);
+    } else if (PyLong_Check($input)) {
+        $1 = (uint16_t) PyLong_AsUnsignedLong($input);
+    } else {
+        SWIG_exception_fail(SWIG_ValueError, "unknown integer type");
+    }
+}
+
+/* unsigned16 Convert from C --> Python */
+%typemap(out) uint16_t {
+    $result = PyInt_FromLong((long)$1);
+}
+
+
+/* signed32 Convert from Python --> C */
+%typemap(in) int32_t {
+    if (PyInt_Check($input)) {
+        $1 = (int32_t) PyInt_AsLong($input);
+    } else if (PyLong_Check($input)) {
+        $1 = (int32_t) PyLong_AsLong($input);
+    } else {
+        SWIG_exception_fail(SWIG_ValueError, "unknown integer type");
+    }
+}
+
+/* signed32 Convert from C --> Python */
+%typemap(out) int32_t {
+    $result = PyInt_FromLong((long)$1);
+}
+
+
+/* unsigned64 Convert from Python --> C */
+%typemap(in) uint64_t {
+%#ifdef HAVE_LONG_LONG
+    if (PyLong_Check($input)) {
+        $1 = (uint64_t)PyLong_AsUnsignedLongLong($input);
+    } else if (PyInt_Check($input)) {
+        $1 = (uint64_t)PyInt_AsUnsignedLongLongMask($input);
+    } else
+%#endif
+    {
+        SWIG_exception_fail(SWIG_ValueError, "unsupported integer size - uint64_t input too large");
+    }
+}
+
+/* unsigned64 Convert from C --> Python */
+%typemap(out) uint64_t {
+%#ifdef HAVE_LONG_LONG
+    $result = PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG)$1);
+%#else
+    SWIG_exception_fail(SWIG_ValueError, "unsupported integer size - uint64_t output too large");
+%#endif
+}
+
+/* signed64 Convert from Python --> C */
+%typemap(in) int64_t {
+%#ifdef HAVE_LONG_LONG
+    if (PyLong_Check($input)) {
+        $1 = (int64_t)PyLong_AsLongLong($input);
+    } else if (PyInt_Check($input)) {
+        $1 = (int64_t)PyInt_AsLong($input);
+    } else
+%#endif
+    {
+        SWIG_exception_fail(SWIG_ValueError, "unsupported integer size - int64_t input too large");
+    }
+}
+
+/* signed64 Convert from C --> Python */
+%typemap(out) int64_t {
+%#ifdef HAVE_LONG_LONG
+    $result = PyLong_FromLongLong((PY_LONG_LONG)$1);
+%#else
+    SWIG_exception_fail(SWIG_ValueError, "unsupported integer size - int64_t output too large");
+%#endif
+}
+
+
+/* Convert from Python --> C */
+%typemap(in) void * {
+    $1 = (void *)$input;
+}
+
+/* Convert from C --> Python */
+%typemap(out) void * {
+    $result = (PyObject *) $1;
+    Py_INCREF($result);
+}
+
+/*
+ * Variant types: C++ --> Python
+ */
+%typemap(out) qpid::types::Variant::Map {
+    $result = MapToPy(&$1);
+}
+
+%typemap(out) qpid::types::Variant::Map& {
+    $result = MapToPy($1);
+}
+
+%typemap(out) qpid::types::Variant::List {
+    $result = ListToPy(&$1);
+}
+
+%typemap(out) qpid::types::Variant::List& {
+    $result = ListToPy($1);
+}
+
+%typemap(out) qpid::types::Variant& {
+    $result = VariantToPy($1);
+}
+
+/*
+ * UUID type: C++ --> Python
+ */
+%typemap(out) qpid::types::UUID & {
+    $result = UuidToPy($1);
+}
+
+
+/*
+ * Variant types: Ruby --> C++
+ */
+%typemap(in) qpid::types::Variant& {
+    $1 = new qpid::types::Variant(PyToVariant($input));
+}
+
+%typemap(in) qpid::types::Variant::Map& {
+    $1 = new qpid::types::Variant::Map();
+    PyToMap($input, $1);
+}
+
+%typemap(in) qpid::types::Variant::List& {
+    $1 = new qpid::types::Variant::List();
+    PyToList($input, $1);
+}
+
+%typemap(in) const qpid::types::Variant::Map const & {
+    $1 = new qpid::types::Variant::Map();
+    PyToMap($input, $1);
+}
+
+%typemap(in) const qpid::types::Variant::List const & {
+    $1 = new qpid::types::Variant::List();
+    PyToList($input, $1);
+}
+
+%typemap(freearg) qpid::types::Variant& {
+    delete $1;
+}
+
+%typemap(freearg) qpid::types::Variant::Map& {
+    delete $1;
+}
+
+%typemap(freearg) qpid::types::Variant::List& {
+    delete $1;
+}
+
+
+/*
+ * Variant types: typecheck maps
+ */
+%typemap(typecheck) qpid::types::Variant::Map& {
+    $1 = PyDict_Check($input) ? 1 : 0;
+}
+
+%typemap(typecheck)  qpid::types::Variant::List& {
+    $1 = PyList_Check($input) ? 1 : 0;
+}
+
+%typemap(typecheck) qpid::types::Variant& {
+    $1 = (PyFloat_Check($input)  ||
+          PyString_Check($input) ||
+          PyInt_Check($input)    ||
+          PyLong_Check($input)   ||
+          PyDict_Check($input)   ||
+          PyList_Check($input)   ||
+          PyBool_Check($input)) ? 1 : 0;
+}
+
+%typemap(typecheck) const qpid::types::Variant::Map const & {
+    $1 = PyDict_Check($input) ? 1 : 0;
+}
+
+%typemap(typecheck) const qpid::types::Variant::List const & {
+    $1 = PyList_Check($input) ? 1 : 0;
+}
+
+%typemap(typecheck) const qpid::types::Variant const & {
+    $1 = (PyFloat_Check($input)  ||
+          PyString_Check($input) ||
+          PyInt_Check($input)    ||
+          PyLong_Check($input)   ||
+          PyDict_Check($input)   ||
+          PyList_Check($input)   ||
+          PyBool_Check($input)) ? 1 : 0;
+}
+
+%typemap(typecheck) bool {
+    $1 = PyBool_Check($input) ? 1 : 0;
+}
+
+
+
+%typemap (typecheck, precedence=SWIG_TYPECHECK_UINT64) uint64_t {
+    $1 = PyLong_Check($input) ? 1 : 0;
+}
+
+%typemap (typecheck, precedence=SWIG_TYPECHECK_UINT32) uint32_t {
+    $1 = PyInt_Check($input) ? 1 : 0;
+}
+
diff --git a/qpid/cpp/include/swig_ruby_typemaps.i b/qpid/cpp/include/swig_ruby_typemaps.i
new file mode 100644
index 0000000..1a07cc8
--- /dev/null
+++ b/qpid/cpp/include/swig_ruby_typemaps.i
@@ -0,0 +1,368 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+%wrapper %{
+
+#include <stdarg.h>
+
+    VALUE MapToRb(const qpid::types::Variant::Map*);
+    VALUE ListToRb(const qpid::types::Variant::List*);
+    void RbToMap(VALUE, qpid::types::Variant::Map*);
+    void RbToList(VALUE, qpid::types::Variant::List*);
+
+    qpid::types::Variant RbToVariant(VALUE value) {
+        switch (TYPE(value)) {
+        case T_FLOAT:   return qpid::types::Variant(NUM2DBL(value));
+        case T_STRING:  return qpid::types::Variant(StringValuePtr(value));
+        case T_FIXNUM:  return qpid::types::Variant((int64_t) FIX2LONG(value));
+        case T_BIGNUM:  return qpid::types::Variant((int64_t) NUM2LL(value));
+        case T_TRUE:    return qpid::types::Variant(true);
+        case T_FALSE:   return qpid::types::Variant(false);
+        case T_HASH: {
+            qpid::types::Variant::Map map;
+            RbToMap(value, &map);
+            return qpid::types::Variant(map);
+        }
+        case T_ARRAY: {
+            qpid::types::Variant::List list;
+            RbToList(value, &list);
+            return qpid::types::Variant(list);
+        }
+        default: return qpid::types::Variant();
+        }
+    }
+
+    VALUE VariantToRb(const qpid::types::Variant* v) {
+        VALUE result = Qnil;
+        try {
+            switch (v->getType()) {
+            case qpid::types::VAR_VOID: {
+                result = Qnil;
+                break;
+            }
+            case qpid::types::VAR_BOOL : {
+                result = v->asBool() ? Qtrue : Qfalse;
+                break;
+            }
+            case qpid::types::VAR_UINT8 :
+            case qpid::types::VAR_UINT16 :
+            case qpid::types::VAR_UINT32 : {
+                result = UINT2NUM(v->asUint32());
+                break;
+            }
+            case qpid::types::VAR_UINT64 : {
+                result = ULL2NUM(v->asUint64());
+                break;
+            }
+            case qpid::types::VAR_INT8 : 
+            case qpid::types::VAR_INT16 :
+            case qpid::types::VAR_INT32 : {
+                result = INT2NUM(v->asInt32());
+                break;
+            }
+            case qpid::types::VAR_INT64 : {
+                result = LL2NUM(v->asInt64());
+                break;
+            }
+            case qpid::types::VAR_FLOAT : {
+                result = rb_float_new((double) v->asFloat());
+                break;
+            }
+            case qpid::types::VAR_DOUBLE : {
+                result = rb_float_new(v->asDouble());
+                break;
+            }
+            case qpid::types::VAR_STRING : {
+                const std::string val(v->asString());
+                result = rb_str_new(val.c_str(), val.size());
+                break;
+            }
+            case qpid::types::VAR_MAP : {
+                result = MapToRb(&(v->asMap()));
+                break;
+            }
+            case qpid::types::VAR_LIST : {
+                result = ListToRb(&(v->asList()));
+                break;
+            }
+            case qpid::types::VAR_UUID : {
+            }
+            }
+        } catch (qpid::types::Exception& ex) {
+            static VALUE error = rb_define_class("Error", rb_eStandardError);
+            rb_raise(error, ex.what());
+        }
+
+        return result;
+    }
+
+    VALUE MapToRb(const qpid::types::Variant::Map* map) {
+        VALUE result = rb_hash_new();
+        qpid::types::Variant::Map::const_iterator iter;
+        for (iter = map->begin(); iter != map->end(); iter++) {
+            const std::string key(iter->first);
+            VALUE rbval = VariantToRb(&(iter->second));
+            rb_hash_aset(result, rb_str_new(key.c_str(), key.size()), rbval);
+        }
+        return result;
+    }
+
+    VALUE ListToRb(const qpid::types::Variant::List* list) {
+        VALUE result = rb_ary_new2(list->size());
+        qpid::types::Variant::List::const_iterator iter;
+        for (iter = list->begin(); iter != list->end(); iter++) {
+            VALUE rbval = VariantToRb(&(*iter));
+            rb_ary_push(result, rbval);
+        }
+        return result;
+    }
+
+    VALUE HashIter(VALUE data_ary, VALUE context) {
+        VALUE key = rb_ary_entry(data_ary, 0);
+        VALUE val = rb_ary_entry(data_ary, 1);
+        qpid::types::Variant::Map* map((qpid::types::Variant::Map*) context);
+        (*map)[std::string(StringValuePtr(key))] = RbToVariant(val);
+        return data_ary;
+    }
+
+    VALUE AryIter(VALUE data, VALUE context) {
+        qpid::types::Variant::List* list((qpid::types::Variant::List*) context);
+        list->push_back(RbToVariant(data));
+        return data;
+    }
+
+    void RbToMap(VALUE hash, qpid::types::Variant::Map* map) {
+        map->clear();
+        rb_iterate(rb_each, hash, (VALUE(*)(ANYARGS))HashIter, (VALUE) map);
+    }
+
+    void RbToList(VALUE ary, qpid::types::Variant::List* list) {
+        list->clear();
+        rb_iterate(rb_each, ary, (VALUE(*)(ANYARGS))AryIter, (VALUE) list);
+    }
+%}
+
+%typemap (in) void *
+{
+    $1 = (void *) $input;
+}
+
+%typemap (out) void *
+{
+    $result = (VALUE) $1;
+}
+
+%typemap (in) uint8_t
+{
+  $1 = NUM2UINT ($input);
+}
+
+%typemap (out) uint8_t
+{
+  $result = UINT2NUM((uint8_t) $1);
+}
+
+%typemap (in) int8_t
+{
+  $1 = NUM2INT ($input);
+}
+
+%typemap (out) int8_t
+{
+  $result = INT2NUM((int8_t) $1);
+}
+
+%typemap (in) uint16_t
+{
+    $1 = NUM2UINT ($input);
+}
+
+%typemap (out) uint16_t
+{
+    $result = UINT2NUM((uint16_t) $1);
+}
+
+%typemap (in) uint32_t
+{
+    if (TYPE($input) == T_BIGNUM)
+        $1 = NUM2UINT($input);
+    else
+        $1 = FIX2UINT($input);
+}
+
+%typemap (out) uint32_t
+{
+    $result = UINT2NUM((uint32_t) $1);
+}
+
+%typemap (in) int32_t
+{
+    if (TYPE($input) == T_BIGNUM)
+        $1 = NUM2INT($input);
+    else
+        $1 = FIX2INT($input);
+}
+
+%typemap (out) int32_t
+{
+    $result = INT2NUM((int32_t) $1);
+}
+
+%typemap (typecheck, precedence=SWIG_TYPECHECK_INTEGER) uint32_t {
+   $1 = FIXNUM_P($input);
+}
+
+%typemap (in) uint64_t
+{
+    if (TYPE($input) == T_BIGNUM)
+        $1 = NUM2ULL($input);
+    else
+        $1 = (uint64_t) FIX2ULONG($input);
+}
+
+%typemap (out) uint64_t
+{
+    $result = ULL2NUM((uint64_t) $1);
+}
+
+%typemap (in) int64_t
+{
+    if (TYPE($input) == T_BIGNUM)
+        $1 = NUM2LL($input);
+    else
+        $1 = (int64_t) FIX2LONG($input);
+}
+
+%typemap (out) int64_t
+{
+    $result = LL2NUM((int64_t) $1);
+}
+
+/*
+ * Variant types: C++ --> Ruby
+ */
+%typemap(out) qpid::types::Variant::Map {
+    $result = MapToRb(&$1);
+}
+
+%typemap(out) qpid::types::Variant::Map& {
+    $result = MapToRb($1);
+}
+
+%typemap(out) qpid::types::Variant::List {
+    $result = ListToRb(&$1);
+}
+
+%typemap(out) qpid::types::Variant::List& {
+    $result = ListToRb($1);
+}
+
+%typemap(out) qpid::types::Variant& {
+    $result = VariantToRb($1);
+}
+
+
+/*
+ * Variant types: Ruby --> C++
+ */
+%typemap(in) qpid::types::Variant& {
+    $1 = new qpid::types::Variant(RbToVariant($input));
+}
+
+%typemap(in) qpid::types::Variant::Map& {
+    $1 = new qpid::types::Variant::Map();
+    RbToMap($input, $1);
+}
+
+%typemap(in) qpid::types::Variant::List& {
+    $1 = new qpid::types::Variant::List();
+    RbToList($input, $1);
+}
+
+%typemap(in) const qpid::types::Variant::Map const & {
+    $1 = new qpid::types::Variant::Map();
+    RbToMap($input, $1);
+}
+
+%typemap(in) const qpid::types::Variant::List const & {
+    $1 = new qpid::types::Variant::List();
+    RbToList($input, $1);
+}
+
+%typemap(freearg) qpid::types::Variant& {
+    delete $1;
+}
+
+%typemap(freearg) qpid::types::Variant::Map& {
+    delete $1;
+}
+
+%typemap(freearg) qpid::types::Variant::List& {
+    delete $1;
+}
+
+
+/*
+ * Variant types: typecheck maps
+ */
+%typemap(typecheck) qpid::types::Variant::Map& {
+    $1 = (TYPE($input) == T_HASH) ? 1 : 0;
+}
+
+%typemap(typecheck) qpid::types::Variant::List& {
+    $1 = (TYPE($input) == T_ARRAY) ? 1 : 0;
+}
+
+%typemap(typecheck) qpid::types::Variant& {
+    $1 = (TYPE($input) == T_FLOAT  ||
+          TYPE($input) == T_STRING ||
+          TYPE($input) == T_FIXNUM ||
+          TYPE($input) == T_BIGNUM ||
+          TYPE($input) == T_TRUE   ||
+          TYPE($input) == T_FALSE) ? 1 : 0;
+}
+
+%typemap(typecheck) qpid::types::Variant::Map const & {
+    $1 = (TYPE($input) == T_HASH) ? 1 : 0;
+}
+
+%typemap(typecheck) qpid::types::Variant::List const & {
+    $1 = (TYPE($input) == T_ARRAY) ? 1 : 0;
+}
+
+%typemap(typecheck) const qpid::types::Variant const & {
+    $1 = (TYPE($input) == T_FLOAT  ||
+          TYPE($input) == T_STRING ||
+          TYPE($input) == T_FIXNUM ||
+          TYPE($input) == T_BIGNUM ||
+          TYPE($input) == T_TRUE   ||
+          TYPE($input) == T_FALSE) ? 1 : 0;
+}
+
+%typemap(typecheck) bool {
+    $1 = (TYPE($input) == T_TRUE ||
+          TYPE($input) == T_FALSE) ? 1 : 0;
+}
+
+
+
+%typemap (typecheck, precedence=SWIG_TYPECHECK_INTEGER) uint64_t {
+   $1 = FIXNUM_P($input);
+}
+
-- 
1.7.11.2

