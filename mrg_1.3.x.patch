From 11ed7634097ca3a3e52141509496105ad65290be Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Fri, 21 May 2010 17:31:29 +0000
Subject: [PATCH] Fix broker core dump during start-up caused by un-initialized mAgent pointer.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@947081 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit ffc5afc35bbc8854e1956d120f79072373f29432)
---
 qpid/cpp/src/qpid/cluster/Cluster.cpp |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/Cluster.cpp b/qpid/cpp/src/qpid/cluster/Cluster.cpp
index 7332102..099c3ef 100644
--- a/qpid/cpp/src/qpid/cluster/Cluster.cpp
+++ b/qpid/cpp/src/qpid/cluster/Cluster.cpp
@@ -247,6 +247,7 @@ Cluster::Cluster(const ClusterSettings& set, broker::Broker& b) :
     name(settings.name),
     self(cpg.self()),
     clusterId(true),
+    mAgent(0),
     expiryPolicy(new ExpiryPolicy(mcast, self, broker.getTimer())),
     mcast(cpg, poller, boost::bind(&Cluster::leave, this)),
     dispatcher(cpg, poller, boost::bind(&Cluster::leave, this)),
-- 
1.5.5.6

From a15f49f58cdb1ee2906f03bb487cf40c43498238 Mon Sep 17 00:00:00 2001
From: Kenneth Anthony Giusti <kgiusti@apache.org>
Date: Thu, 20 May 2010 21:42:40 +0000
Subject: [PATCH] Bug 593828 - QMF: python console needs ability to filter unsolicited events.
 QMF: provide event filter api for python console

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@946801 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit b806ee99fb0224069ba628bc0c506e02bb227de2)
---
 qpid/cpp/src/qpid/management/ManagementAgent.cpp |   46 ++++++++++++++++-----
 qpid/cpp/src/qpid/management/ManagementAgent.h   |    2 +
 2 files changed, 37 insertions(+), 11 deletions(-)

diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.cpp b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
index 92f9d79..d4649a7 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.cpp
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
@@ -52,6 +52,25 @@ using namespace std;
 namespace _qmf = qmf::org::apache::qpid::broker;
 
 
+namespace {
+    const string defaultVendorName("vendor");
+    const string defaultProductName("product");
+
+    // Create a valid binding key substring by
+    // replacing all '.' chars with '_'
+    const string keyifyNameStr(const string& name)
+    {
+        string n2 = name;
+
+        size_t pos = n2.find('.');
+        while (pos != n2.npos) {
+            n2.replace(pos, 1, "_");
+            pos = n2.find('.', pos);
+        }
+        return n2;
+    }
+}
+
 
 static Variant::Map mapEncodeSchemaId(const string& pname,
                                       const string& cname,
@@ -81,6 +100,7 @@ ManagementAgent::ManagementAgent (const bool qmfV1, const bool qmfV2) :
     threadPoolSize(1), interval(10), broker(0), timer(0),
     startTime(sys::now()),
     suppressed(false), disallowAllV1Methods(false),
+    vendorNameKey(defaultVendorName), productNameKey(defaultProductName),
     qmf1Support(qmfV1), qmf2Support(qmfV2)
 {
     nextObjectId   = 1;
@@ -89,6 +109,8 @@ ManagementAgent::ManagementAgent (const bool qmfV1, const bool qmfV2) :
     nextRemoteBank = 10;
     nextRequestSequence = 1;
     clientWasAdded = false;
+    attrMap["_vendor"] = defaultVendorName;
+    attrMap["_product"] = defaultProductName;
 }
 
 ManagementAgent::~ManagementAgent ()
@@ -196,6 +218,9 @@ void ManagementAgent::setName(const string& vendor, const string& product, const
    name_address = vendor + ":" + product + ":" + inst;
    attrMap["_instance"] = inst;
    attrMap["_name"] = name_address;
+
+   vendorNameKey = keyifyNameStr(vendor);
+   productNameKey = keyifyNameStr(product);
 }
 
 
@@ -318,6 +343,10 @@ ObjectId ManagementAgent::addObject(ManagementObject* object,
 
 void ManagementAgent::raiseEvent(const ManagementEvent& event, severity_t severity)
 {
+    static const std::string severityStr[] = {
+        "emerg", "alert", "crit", "error", "warn",
+        "note", "info", "debug"
+    };
     sys::Mutex::ScopedLock lock (userLock);
     uint8_t sev = (severity == SEV_DEFAULT) ? event.getSeverity() : (uint8_t) severity;
 
@@ -362,7 +391,11 @@ void ManagementAgent::raiseEvent(const ManagementEvent& event, severity_t severi
         headers["qmf.agent"] = name_address;
 
         stringstream key;
-        key << "agent.ind.event." << sev << "." << name_address << "." << event.getEventName();
+        key << "agent.ind.event." << vendorNameKey
+            << "." << productNameKey
+            << "." << severityStr[sev]
+            << "." << keyifyNameStr(event.getPackageName())
+            << "." << keyifyNameStr(event.getEventName());
 
         string content;
         MapCodec::encode(map_, content);
@@ -803,16 +836,7 @@ void ManagementAgent::periodicProcessing (void)
     if (qmf2Support) {
         std::stringstream addr_key;
 
-        addr_key << "agent.ind.heartbeat";
-
-        // append .<vendor>.<product> to address key if present.
-        Variant::Map::const_iterator v;
-        if ((v = attrMap.find("_vendor")) != attrMap.end()){
-            addr_key << "." << v->second.getString();
-            if ((v = attrMap.find("_product")) != attrMap.end()) {
-                addr_key << "." << v->second.getString();
-            }
-        }
+        addr_key << "agent.ind.heartbeat." << vendorNameKey << "." << productNameKey;
 
         Variant::Map map;
         Variant::Map headers;
diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.h b/qpid/cpp/src/qpid/management/ManagementAgent.h
index a87cc91..8129c1e 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.h
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.h
@@ -284,6 +284,8 @@ private:
     // Agent name and address
     qpid::types::Variant::Map attrMap;
     std::string       name_address;
+    std::string vendorNameKey;  // "." --> "_"
+    std::string productNameKey; // "." --> "_"
 
     // supported management protocol
     bool qmf1Support;
-- 
1.5.5.6

From d3a710d15dcfa2d14750c783de70776bb50a856d Mon Sep 17 00:00:00 2001
From: Kenneth Anthony Giusti <kgiusti@apache.org>
Date: Fri, 21 May 2010 17:39:51 +0000
Subject: [PATCH] Bug 593831 - QMF: c++ console needs ability to filter unsolicited events.

QMF: add bindEvent api to allow filtering of unsolicted events.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@947084 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 5afdc67935d07852c7c166741401ec4a77604d9b)
---
 qpid/cpp/bindings/qmf/python/qmf.py            |   15 +++++++++++-
 qpid/cpp/bindings/qmf/ruby/qmf.rb              |   15 ++++++++++++
 qpid/cpp/include/qmf/engine/Console.h          |    3 ++
 qpid/cpp/include/qpid/console/SessionManager.h |   14 +++++++++++
 qpid/cpp/src/qmf/engine/ConsoleImpl.cpp        |   30 ++++++++++++++++++++++++
 qpid/cpp/src/qmf/engine/ConsoleImpl.h          |    2 +
 qpid/cpp/src/qpid/console/SessionManager.cpp   |   27 +++++++++++++++++++++
 7 files changed, 105 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/bindings/qmf/python/qmf.py b/qpid/cpp/bindings/qmf/python/qmf.py
index 37442b9..06d3070 100644
--- a/qpid/cpp/bindings/qmf/python/qmf.py
+++ b/qpid/cpp/bindings/qmf/python/qmf.py
@@ -1166,9 +1166,22 @@ class Console(Thread):
             if "class" in kwargs:
                 self.impl.bindClass(package, kwargs["class"])
             else:
-                self.impl.bindClass(package)
+                self.impl.bindClass(package, "*")
         else:
             raise Exception("Argument error: invalid arguments, use 'key' or 'package'[,'class']")
+
+
+    def bind_event(self, kwargs = {}):
+        if "key" in kwargs:
+            self.impl.bindEvent(kwargs["key"])
+        elif "package" in kwargs:
+            package = kwargs["package"]
+            if "event" in kwargs:
+                self.impl.bindEvent(package, kwargs["event"])
+            else:
+                self.impl.bindEvent(package, "*")
+        else:
+            raise Exception("Argument error: invalid arguments, use 'key' or 'package'[,'event']")
     
     
     def agents(self, broker=None):
diff --git a/qpid/cpp/bindings/qmf/ruby/qmf.rb b/qpid/cpp/bindings/qmf/ruby/qmf.rb
index e50d23a..34d3255 100644
--- a/qpid/cpp/bindings/qmf/ruby/qmf.rb
+++ b/qpid/cpp/bindings/qmf/ruby/qmf.rb
@@ -1087,6 +1087,21 @@ module Qmf
       end
     end
 
+    def bind_event(kwargs = {})
+      if kwargs.include?(:key)
+        @impl.bindEvent(kwargs[:key])
+      elsif kwargs.include?(:package)
+        package = kwargs[:package]
+        if kwargs.include?(:event)
+          @impl.bindEvent(package, kwargs[:event])
+        else
+          @impl.bindEvent(package, "*")
+        end
+      else
+        raise ArgumentError, "Invalid arguments, use :key or :package[,:event]"
+      end
+    end
+
     def agents(broker = nil)
       blist = []
       if broker
diff --git a/qpid/cpp/include/qmf/engine/Console.h b/qpid/cpp/include/qmf/engine/Console.h
index 03b3993..bd40c63 100644
--- a/qpid/cpp/include/qmf/engine/Console.h
+++ b/qpid/cpp/include/qmf/engine/Console.h
@@ -217,6 +217,9 @@ namespace engine {
         void bindClass(const SchemaClassKey* key);
         void bindClass(const char* packageName, const char* className);
 
+        void bindEvent(const SchemaClassKey *key);
+        void bindEvent(const char* packageName, const char* eventName);
+
         /*
         void startSync(const Query& query, void* context, SyncQuery& sync);
         void touchSync(SyncQuery& sync);
diff --git a/qpid/cpp/include/qpid/console/SessionManager.h b/qpid/cpp/include/qpid/console/SessionManager.h
index f27037a..b46af54 100644
--- a/qpid/cpp/include/qpid/console/SessionManager.h
+++ b/qpid/cpp/include/qpid/console/SessionManager.h
@@ -138,6 +138,20 @@ class SessionManager
     QPID_CONSOLE_EXTERN void bindClass(const std::string& packageName,
                                        const std::string& className);
 
+    /** Request events from a particular package.
+     *
+     * Note that this method is only meaningful if a ConsoleListener was provided at session
+     * creation and if the 'userBindings' flag was set to true.
+     *
+     * @param classKey Class key of event of interest
+     * @param packageName Name of package of event of interest.
+     * @param eventName Name of event of interest. Default=All events defined by package.
+     */
+    QPID_CONSOLE_EXTERN void bindEvent(const ClassKey& classKey);
+    QPID_CONSOLE_EXTERN void bindEvent(const std::string& packageName,
+                                       const std::string& eventName="");
+
+
     /** Get a list of qmf agents known to the session manager.
      *
      *@param agents Vector of Agent objects returned by the session manager.
diff --git a/qpid/cpp/src/qmf/engine/ConsoleImpl.cpp b/qpid/cpp/src/qmf/engine/ConsoleImpl.cpp
index 1b66d9e..4a5da31 100644
--- a/qpid/cpp/src/qmf/engine/ConsoleImpl.cpp
+++ b/qpid/cpp/src/qmf/engine/ConsoleImpl.cpp
@@ -259,6 +259,32 @@ void ConsoleImpl::bindClass(const char* packageName, const char* className)
         (*iter)->addBinding(QMF_EXCHANGE, key.str());
 }
 
+
+void ConsoleImpl::bindEvent(const SchemaClassKey* classKey)
+{
+    bindEvent(classKey->getPackageName(), classKey->getClassName());
+}
+
+void ConsoleImpl::bindEvent(const char* packageName, const char* eventName)
+{
+    if (!settings.userBindings) throw qpid::Exception("Console not configured for userBindings.");
+    if (settings.rcvEvents) throw qpid::Exception("Console already configured to receive all events.");
+
+    stringstream key;
+    key << "console.event.*.*." << packageName;
+    if (eventName && *eventName) {
+        key << "." << eventName << ".#";
+    } else {
+        key << ".#";
+    }
+
+    Mutex::ScopedLock _lock(lock);
+    bindingList.push_back(pair<string, string>(string(), key.str()));
+    for (vector<BrokerProxyImpl*>::iterator iter = brokerList.begin();
+         iter != brokerList.end(); iter++)
+        (*iter)->addBinding(QMF_EXCHANGE, key.str());
+}
+
 /*
 void ConsoleImpl::startSync(const Query& query, void* context, SyncQuery& sync)
 {
@@ -421,6 +447,10 @@ const SchemaEventClass* Console::getEventClass(const SchemaClassKey* key) const
 void Console::bindPackage(const char* packageName) { impl->bindPackage(packageName); }
 void Console::bindClass(const SchemaClassKey* key) { impl->bindClass(key); }
 void Console::bindClass(const char* packageName, const char* className) { impl->bindClass(packageName, className); }
+
+void Console::bindEvent(const SchemaClassKey *key) { impl->bindEvent(key); }
+void Console::bindEvent(const char* packageName, const char* eventName) { impl->bindEvent(packageName, eventName); }
+
 //void Console::startSync(const Query& query, void* context, SyncQuery& sync) { impl->startSync(query, context, sync); }
 //void Console::touchSync(SyncQuery& sync) { impl->touchSync(sync); }
 //void Console::endSync(SyncQuery& sync) { impl->endSync(sync); }
diff --git a/qpid/cpp/src/qmf/engine/ConsoleImpl.h b/qpid/cpp/src/qmf/engine/ConsoleImpl.h
index ace47ec..0c27fda 100644
--- a/qpid/cpp/src/qmf/engine/ConsoleImpl.h
+++ b/qpid/cpp/src/qmf/engine/ConsoleImpl.h
@@ -94,6 +94,8 @@ namespace engine {
         void bindPackage(const char* packageName);
         void bindClass(const SchemaClassKey* key);
         void bindClass(const char* packageName, const char* className);
+        void bindEvent(const SchemaClassKey* key);
+        void bindEvent(const char* packageName, const char* eventName);
 
         /*
         void startSync(const Query& query, void* context, SyncQuery& sync);
diff --git a/qpid/cpp/src/qpid/console/SessionManager.cpp b/qpid/cpp/src/qpid/console/SessionManager.cpp
index 0285c5f..4f39095 100644
--- a/qpid/cpp/src/qpid/console/SessionManager.cpp
+++ b/qpid/cpp/src/qpid/console/SessionManager.cpp
@@ -138,6 +138,33 @@ void SessionManager::bindClass(const std::string& packageName, const std::string
         (*iter)->addBinding(key.str());
 }
 
+
+void SessionManager::bindEvent(const ClassKey& classKey)
+{
+    bindEvent(classKey.getPackageName(), classKey.getClassName());
+}
+
+
+void SessionManager::bindEvent(const std::string& packageName, const std::string& eventName)
+{
+    if (!settings.userBindings) throw Exception("Session not configured for userBindings.");
+    if (settings.rcvEvents) throw Exception("Session already configured to receive all events.");
+
+    stringstream key;
+    key << "console.event.*.*." << packageName;
+    if (eventName.length()) {
+        key << "." << eventName << ".#";
+    } else {
+        key << ".#";
+    }
+
+    bindingKeyList.push_back(key.str());
+    for (vector<Broker*>::iterator iter = brokers.begin();
+         iter != brokers.end(); iter++)
+        (*iter)->addBinding(key.str());
+}
+
+
 void SessionManager::getAgents(Agent::Vector& agents, Broker* broker)
 {
     agents.clear();
-- 
1.5.5.6

From 648ab87be54d30af2ec14b7b8eb7bd77735f5ffa Mon Sep 17 00:00:00 2001
From: Kim van der Riet <kpvdr@apache.org>
Date: Mon, 24 May 2010 15:48:18 +0000
Subject: [PATCH] Changed the names of tests which are installed in /usr/bin/ to be prefixed with "qpid-". This will make these generic names easier to associate with qpid. (BZ577353)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@947678 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/tests/CMakeLists.txt                  |   56 +-
 qpid/cpp/src/tests/Makefile.am                     |   60 +-
 qpid/cpp/src/tests/client_test.cpp                 |  139 ----
 qpid/cpp/src/tests/cluster_authentication_soak.cpp |   22 +-
 qpid/cpp/src/tests/cluster_tests.py                |    2 +-
 qpid/cpp/src/tests/latencytest.cpp                 |  469 -------------
 qpid/cpp/src/tests/perftest.cpp                    |  741 --------------------
 qpid/cpp/src/tests/qpid-client-test.cpp            |  139 ++++
 qpid/cpp/src/tests/qpid-latency-test.cpp           |  469 +++++++++++++
 qpid/cpp/src/tests/qpid-perftest.cpp               |  741 ++++++++++++++++++++
 qpid/cpp/src/tests/qpid-topic-listener.cpp         |  209 ++++++
 qpid/cpp/src/tests/qpid-topic-publisher.cpp        |  230 ++++++
 qpid/cpp/src/tests/qpid-txtest.cpp                 |  340 +++++++++
 qpid/cpp/src/tests/quick_perftest                  |    2 +-
 qpid/cpp/src/tests/quick_txtest                    |    2 +-
 qpid/cpp/src/tests/run_perftest                    |    6 +-
 qpid/cpp/src/tests/ssl_test                        |    2 +-
 qpid/cpp/src/tests/topic_listener.cpp              |  209 ------
 qpid/cpp/src/tests/topic_publisher.cpp             |  230 ------
 qpid/cpp/src/tests/topictest                       |    4 +-
 qpid/cpp/src/tests/txtest.cpp                      |  340 ---------
 21 files changed, 2206 insertions(+), 2206 deletions(-)
 delete mode 100644 qpid/cpp/src/tests/client_test.cpp
 delete mode 100644 qpid/cpp/src/tests/latencytest.cpp
 delete mode 100644 qpid/cpp/src/tests/perftest.cpp
 create mode 100644 qpid/cpp/src/tests/qpid-client-test.cpp
 create mode 100644 qpid/cpp/src/tests/qpid-latency-test.cpp
 create mode 100644 qpid/cpp/src/tests/qpid-perftest.cpp
 create mode 100644 qpid/cpp/src/tests/qpid-topic-listener.cpp
 create mode 100644 qpid/cpp/src/tests/qpid-topic-publisher.cpp
 create mode 100644 qpid/cpp/src/tests/qpid-txtest.cpp
 delete mode 100644 qpid/cpp/src/tests/topic_listener.cpp
 delete mode 100644 qpid/cpp/src/tests/topic_publisher.cpp
 delete mode 100644 qpid/cpp/src/tests/txtest.cpp

diff --git a/qpid/cpp/src/tests/CMakeLists.txt b/qpid/cpp/src/tests/CMakeLists.txt
index c645815..47714ac 100644
--- a/qpid/cpp/src/tests/CMakeLists.txt
+++ b/qpid/cpp/src/tests/CMakeLists.txt
@@ -182,40 +182,40 @@ endif (BUILD_CLUSTER)
 #
 # Other test programs
 #
-add_executable (perftest perftest.cpp ${platform_test_additions})
-target_link_libraries (perftest qpidclient)
-#perftest_SOURCES=perftest.cpp test_tools.h TestOptions.h ConnectionOptions.h
-remember_location(perftest)
+add_executable (qpid-perftest qpid-perftest.cpp ${platform_test_additions})
+target_link_libraries (qpid-perftest qpidclient)
+#qpid_perftest_SOURCES=qpid-perftest.cpp test_tools.h TestOptions.h ConnectionOptions.h
+remember_location(qpid-perftest)
 
-add_executable (txtest txtest.cpp ${platform_test_additions})
-target_link_libraries (txtest qpidclient)
-#txtest_SOURCES=txtest.cpp  TestOptions.h ConnectionOptions.h
-remember_location(txtest)
+add_executable (qpid-txtest qpid-txtest.cpp ${platform_test_additions})
+target_link_libraries (qpid-txtest qpidclient)
+#qpid_txtest_SOURCES=qpid-txtest.cpp  TestOptions.h ConnectionOptions.h
+remember_location(qpid-txtest)
 
-add_executable (latencytest latencytest.cpp ${platform_test_additions})
-target_link_libraries (latencytest qpidclient)
-#latencytest_SOURCES=latencytest.cpp TestOptions.h ConnectionOptions.h
-remember_location(latencytest)
+add_executable (qpid-latency-test qpid-latency-test.cpp ${platform_test_additions})
+target_link_libraries (qpid-latency-test qpidclient)
+#qpid_latencytest_SOURCES=qpid-latency-test.cpp TestOptions.h ConnectionOptions.h
+remember_location(qpid-latency-test)
 
 add_executable (echotest echotest.cpp ${platform_test_additions})
 target_link_libraries (echotest qpidclient)
 #echotest_SOURCES=echotest.cpp TestOptions.h ConnectionOptions.h
 remember_location(echotest)
 
-add_executable (client_test client_test.cpp ${platform_test_additions})
-target_link_libraries (client_test qpidclient)
-#client_test_SOURCES=client_test.cpp TestOptions.h ConnectionOptions.h
-remember_location(client_test)
+add_executable (qpid-client-test qpid-client-test.cpp ${platform_test_additions})
+target_link_libraries (qpid-client-test qpidclient)
+#qpid_client_test_SOURCES=qpid-client-test.cpp TestOptions.h ConnectionOptions.h
+remember_location(qpid-client-test)
 
-add_executable (topic_listener topic_listener.cpp ${platform_test_additions})
-target_link_libraries (topic_listener qpidclient)
-#topic_listener_SOURCES=topic_listener.cpp TestOptions.h ConnectionOptions.h
-remember_location(topic_listener)
+add_executable (qpid-topic-listener qpid-topic-listener.cpp ${platform_test_additions})
+target_link_libraries (qpid-topic-listener qpidclient)
+#qpid_topic_listener_SOURCES=qpid-topic-listener.cpp TestOptions.h ConnectionOptions.h
+remember_location(qpid-topic-listener)
 
-add_executable (topic_publisher topic_publisher.cpp ${platform_test_additions})
-target_link_libraries (topic_publisher qpidclient)
-#topic_publisher_SOURCES=topic_publisher.cpp TestOptions.h ConnectionOptions.h
-remember_location(topic_publisher)
+add_executable (qpid-topic-publisher qpid-topic-publisher.cpp ${platform_test_additions})
+target_link_libraries (qpid-topic-publisher qpidclient)
+#qpid_topic_publisher_SOURCES=qpid-topic-publisher.cpp TestOptions.h ConnectionOptions.h
+remember_location(qpid-topic-publisher)
 
 add_executable (publish publish.cpp ${platform_test_additions})
 target_link_libraries (publish qpidclient)
@@ -272,8 +272,8 @@ add_executable (qpid_send qpid_send.cpp Statistics.cpp ${platform_test_additions
 target_link_libraries (qpid_send qpidmessaging)
 remember_location(qpid_send)
 
-# perftest and latencytest are generally useful so install them
-install (TARGETS perftest latencytest RUNTIME
+# qpid-perftest and qpid-latency-test are generally useful so install them
+install (TARGETS qpid-perftest qpid-latency-test RUNTIME
          DESTINATION ${QPID_INSTALL_BINDIR})
 
 if (CMAKE_SYSTEM_NAME STREQUAL Windows)
@@ -286,8 +286,8 @@ set(test_wrap ${shell} ${CMAKE_CURRENT_SOURCE_DIR}/run_test${test_script_suffix}
 
 add_test (unit_test ${test_wrap} ${unit_test_LOCATION})
 add_test (start_broker ${shell} ${CMAKE_CURRENT_SOURCE_DIR}/start_broker${test_script_suffix})
-add_test (client_test ${test_wrap} ${client_test_LOCATION})
-add_test (quick_perftest ${test_wrap} ${perftest_LOCATION} --summary --count 100)
+add_test (qpid-client-test ${test_wrap} ${client_test_LOCATION})
+add_test (quick_perftest ${test_wrap} ${qpid-perftest_LOCATION} --summary --count 100)
 add_test (quick_topictest ${test_wrap} ${CMAKE_CURRENT_SOURCE_DIR}/quick_topictest${test_script_suffix})
 add_test (quick_txtest ${test_wrap} ${txtest_LOCATION} --queues 4 --tx-count 10 --quiet)
 if (PYTHON_EXECUTABLE)
diff --git a/qpid/cpp/src/tests/Makefile.am b/qpid/cpp/src/tests/Makefile.am
index 235e6fe..92e4e85 100644
--- a/qpid/cpp/src/tests/Makefile.am
+++ b/qpid/cpp/src/tests/Makefile.am
@@ -184,35 +184,35 @@ qpid_send_SOURCES = \
   Statistics.cpp
 qpid_send_LDADD = $(lib_messaging)
 
-qpidtest_PROGRAMS+=perftest
-perftest_SOURCES=perftest.cpp test_tools.h TestOptions.h ConnectionOptions.h
-perftest_INCLUDES=$(PUBLIC_INCLUDES)
-perftest_LDADD=$(lib_client) 
-
-qpidtest_PROGRAMS+=txtest
-txtest_INCLUDES=$(PUBLIC_INCLUDES)
-txtest_SOURCES=txtest.cpp  TestOptions.h ConnectionOptions.h
-txtest_LDADD=$(lib_client) 
-
-qpidtest_PROGRAMS+=latencytest
-latencytest_INCLUDES=$(PUBLIC_INCLUDES)
-latencytest_SOURCES=latencytest.cpp TestOptions.h ConnectionOptions.h
-latencytest_LDADD=$(lib_client) 
-
-qpidtest_PROGRAMS+=client_test
-client_test_INCLUDES=$(PUBLIC_INCLUDES)
-client_test_SOURCES=client_test.cpp TestOptions.h ConnectionOptions.h
-client_test_LDADD=$(lib_client) 
-
-qpidtest_PROGRAMS+=topic_listener
-topic_listener_INCLUDES=$(PUBLIC_INCLUDES)
-topic_listener_SOURCES=topic_listener.cpp TestOptions.h ConnectionOptions.h
-topic_listener_LDADD=$(lib_client) 
-
-qpidtest_PROGRAMS+=topic_publisher
-topic_publisher_INCLUDES=$(PUBLIC_INCLUDES)
-topic_publisher_SOURCES=topic_publisher.cpp TestOptions.h ConnectionOptions.h
-topic_publisher_LDADD=$(lib_client) 
+qpidtest_PROGRAMS+=qpid-perftest
+qpid_perftest_SOURCES=qpid-perftest.cpp test_tools.h TestOptions.h ConnectionOptions.h
+qpid_perftest_INCLUDES=$(PUBLIC_INCLUDES)
+qpid_perftest_LDADD=$(lib_client) 
+
+qpidtest_PROGRAMS+=qpid-txtest
+qpid_txtest_INCLUDES=$(PUBLIC_INCLUDES)
+qpid_txtest_SOURCES=qpid-txtest.cpp  TestOptions.h ConnectionOptions.h
+qpid_txtest_LDADD=$(lib_client) 
+
+qpidtest_PROGRAMS+=qpid-latency-test
+qpid_latency_test_INCLUDES=$(PUBLIC_INCLUDES)
+qpid_latency_test_SOURCES=qpid-latency-test.cpp TestOptions.h ConnectionOptions.h
+qpid_latency_test_LDADD=$(lib_client) 
+
+qpidtest_PROGRAMS+=qpid-client-test
+qpid_client_test_INCLUDES=$(PUBLIC_INCLUDES)
+qpid_client_test_SOURCES=qpid-client-test.cpp TestOptions.h ConnectionOptions.h
+qpid_client_test_LDADD=$(lib_client) 
+
+qpidtest_PROGRAMS+=qpid-topic-listener
+qpid_topic_listener_INCLUDES=$(PUBLIC_INCLUDES)
+qpid_topic_listener_SOURCES=qpid-topic-listener.cpp TestOptions.h ConnectionOptions.h
+qpid_topic_listener_LDADD=$(lib_client) 
+
+qpidtest_PROGRAMS+=qpid-topic-publisher
+qpid_topic_publisher_INCLUDES=$(PUBLIC_INCLUDES)
+qpid_topic_publisher_SOURCES=qpid-topic-publisher.cpp TestOptions.h ConnectionOptions.h
+qpid_topic_publisher_LDADD=$(lib_client) 
 
 qpidtest_PROGRAMS+=qpid_ping
 qpid_ping_INCLUDES=$(PUBLIC_INCLUDES)
@@ -313,7 +313,7 @@ TESTS_ENVIRONMENT = \
     QPID_DATA_DIR= \
     $(srcdir)/run_test 
 
-system_tests = client_test quick_perftest quick_topictest run_header_test quick_txtest
+system_tests = qpid-client-test quick_perftest quick_topictest run_header_test quick_txtest
 TESTS += start_broker $(system_tests) python_tests stop_broker run_federation_tests run_acl_tests run_cli_tests replication_test
 
 EXTRA_DIST +=								\
diff --git a/qpid/cpp/src/tests/client_test.cpp b/qpid/cpp/src/tests/client_test.cpp
deleted file mode 100644
index 2f5e8e5..0000000
--- a/qpid/cpp/src/tests/client_test.cpp
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- *
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- *
- */
-
-/**
- * This file provides a simple test (and example) of basic
- * functionality including declaring an exchange and a queue, binding
- * these together, publishing a message and receiving that message
- * asynchronously.
- */
-
-#include <iostream>
-
-#include "TestOptions.h"
-#include "qpid/client/Connection.h"
-#include "qpid/client/Message.h"
-#include "qpid/client/Session.h"
-#include "qpid/client/SubscriptionManager.h"
-
-
-using namespace qpid;
-using namespace qpid::client;
-using namespace qpid::framing;
-using std::string;
-
-namespace qpid {
-namespace tests {
-
-struct Args : public TestOptions {
-    uint msgSize;
-    bool verbose;
-
-    Args() : TestOptions("Simple test of Qpid c++ client; sends and receives a single message."), msgSize(26)
-    {
-        addOptions()
-            ("size", optValue(msgSize, "N"), "message size")
-            ("verbose", optValue(verbose), "print out some status messages");
-    }
-};
-
-const std::string chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
-
-std::string generateData(uint size)
-{
-    if (size < chars.length()) {
-        return chars.substr(0, size);
-    }
-    std::string data;
-    for (uint i = 0; i < (size / chars.length()); i++) {
-        data += chars;
-    }
-    data += chars.substr(0, size % chars.length());
-    return data;
-}
-
-void print(const std::string& text, const Message& msg)
-{
-    std::cout << text;
-    if (msg.getData().size() > 16) {
-        std::cout << msg.getData().substr(0, 16) << "...";
-    } else {
-        std::cout << msg.getData();
-    }
-    std::cout << std::endl;
-}
-
-}} // namespace qpid::tests
-
-using namespace qpid::tests;
-
-int main(int argc, char** argv)
-{
-    try {
-        Args opts;
-        opts.parse(argc, argv);
-
-        //Connect to the broker:
-        Connection connection;
-        opts.open(connection);
-	if (opts.verbose) std::cout << "Opened connection." << std::endl;
-
-        //Create and open a session on the connection through which
-        //most functionality is exposed:
-        Session session = connection.newSession();
-	if (opts.verbose) std::cout << "Opened session." << std::endl;
-
-
-        //'declare' the exchange and the queue, which will create them
-        //as they don't exist
-	session.exchangeDeclare(arg::exchange="MyExchange", arg::type="direct");
-	if (opts.verbose) std::cout << "Declared exchange." << std::endl;
-	session.queueDeclare(arg::queue="MyQueue", arg::autoDelete=true, arg::exclusive=true);
-	if (opts.verbose) std::cout << "Declared queue." << std::endl;
-
-        //now bind the queue to the exchange
-	session.exchangeBind(arg::exchange="MyExchange", arg::queue="MyQueue", arg::bindingKey="MyKey");
-	if (opts.verbose) std::cout << "Bound queue to exchange." << std::endl;
-
-        //create and send a message to the exchange using the routing
-        //key we bound our queue with:
-	Message msgOut(generateData(opts.msgSize));
-        msgOut.getDeliveryProperties().setRoutingKey("MyKey");
-        session.messageTransfer(arg::destination="MyExchange", arg::content=msgOut, arg::acceptMode=1);
-	if (opts.verbose) print("Published message: ", msgOut);
-
-        // Using the SubscriptionManager, get the message from the queue.
-        SubscriptionManager subs(session);
-        Message msgIn = subs.get("MyQueue");
-        if (msgIn.getData() == msgOut.getData())
-            if (opts.verbose) std::cout << "Received the exepected message." << std::endl;
-
-        //close the session & connection
-	session.close();
-	if (opts.verbose) std::cout << "Closed session." << std::endl;
-	connection.close();
-	if (opts.verbose) std::cout << "Closed connection." << std::endl;
-        return 0;
-    } catch(const std::exception& e) {
-	std::cout << e.what() << std::endl;
-    }
-    return 1;
-}
diff --git a/qpid/cpp/src/tests/cluster_authentication_soak.cpp b/qpid/cpp/src/tests/cluster_authentication_soak.cpp
index 985c3aa..ccf4d27 100644
--- a/qpid/cpp/src/tests/cluster_authentication_soak.cpp
+++ b/qpid/cpp/src/tests/cluster_authentication_soak.cpp
@@ -104,10 +104,10 @@ runPerftest ( ) {
     stringstream portSs;
     portSs << newbiePort;
 
-    char const *  path = "./perftest";
+    char const *  path = "./qpid-perftest";
 
     vector<char const *> argv;
-    argv.push_back ( "./perftest" );
+    argv.push_back ( "./qpid-perftest" );
     argv.push_back ( "-p" );
     argv.push_back ( portSs.str().c_str() );
     argv.push_back ( "--username" );
@@ -129,7 +129,7 @@ runPerftest ( ) {
 
         execv ( path, const_cast<char * const *>(&argv[0]) );
         // The exec failed: we are still in parent process.
-        perror ( "error running perftest: " ); 
+        perror ( "error running qpid-perftest: " );
         return false;
     }
     else {
@@ -146,19 +146,19 @@ runPerftest ( ) {
           if ( returned_pid == pid ) {
               int exit_status = WEXITSTATUS(status);
               if ( exit_status ) {
-                cerr << "Perftest failed. exit_status was: " << exit_status;
+                cerr << "qpid-perftest failed. exit_status was: " << exit_status;
                 return false;
               }
               else {
-                return true; // perftest succeeded.
+                return true; // qpid-perftest succeeded.
               }
           }
-          else  {  // perftest has not yet completed. 
+          else  {  // qpid-perftest has not yet completed.
               gettimeofday ( & currentTime, 0 );
               timersub ( & currentTime, & startTime, & duration );
               if ( duration.tv_sec > 60 ) {
                 kill ( pid, 9 );
-                cerr << "Perftest pid " << pid << " hanging: killed.\n";
+                cerr << "qpid-perftest pid " << pid << " hanging: killed.\n";
                 return false;
               }
           }
@@ -214,7 +214,7 @@ main ( int argc, char ** argv )
 
     sleep ( 3 );
 
-    /* Run all perftest iterations, and only then check for brokers 
+    /* Run all qpid-perftest iterations, and only then check for brokers
      * still being up.  If you just want a quick check for the failure 
      * mode in which a single iteration would kill all brokers except 
      * the client-connected one, just run it with the iterations arg
@@ -222,14 +222,14 @@ main ( int argc, char ** argv )
     */
     for ( int iteration = 0; iteration < n_iterations; ++ iteration ) {
         if ( ! runPerftest ( ) ) {
-            cerr << "Perftest " << iteration << " failed.\n";
+            cerr << "qpid-perftest " << iteration << " failed.\n";
             return 1;
         }
         if ( ! ( iteration % 10 ) ) {
-            cerr << "perftest " << iteration << " complete. -------------- \n";
+            cerr << "qpid-perftest " << iteration << " complete. -------------- \n";
         }
     }
-    cerr << "\nperftest " << n_iterations << " iterations complete. -------------- \n\n";
+    cerr << "\nqpid-perftest " << n_iterations << " iterations complete. -------------- \n\n";
 
     if ( ! allBrokersAreAlive ( brokers ) ) {
         cerr << "not all brokers are alive.\n";
diff --git a/qpid/cpp/src/tests/cluster_tests.py b/qpid/cpp/src/tests/cluster_tests.py
index 893fb99..f36cde9 100755
--- a/qpid/cpp/src/tests/cluster_tests.py
+++ b/qpid/cpp/src/tests/cluster_tests.py
@@ -211,7 +211,7 @@ class LongTests(BrokerTest):
             """Start ordinary clients for a broker. Start one client per broker.
             Round-robin on a colllection of different clients."""
             cmds=[
-                ["perftest", "--count", 50000,
+                ["qpid-perftest", "--count", 50000,
                  "--base-name", str(qpid.datatypes.uuid4()), "--port", broker.port()],
                 ["qpid-queue-stats", "-a", "localhost:%s" %(broker.port())],
                 ["testagent", "localhost", str(broker.port())] ]
diff --git a/qpid/cpp/src/tests/latencytest.cpp b/qpid/cpp/src/tests/latencytest.cpp
deleted file mode 100644
index 20eb456..0000000
--- a/qpid/cpp/src/tests/latencytest.cpp
+++ /dev/null
@@ -1,469 +0,0 @@
-/*
- *
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- *
- */
-
-
-#include <algorithm>
-#include <limits>
-#include <iostream>
-#include <memory>
-#include <sstream>
-#include <vector>
-
-#include "TestOptions.h"
-#include "qpid/sys/Thread.h"
-#include "qpid/client/Connection.h"
-#include "qpid/client/Message.h"
-#include "qpid/client/AsyncSession.h"
-#include "qpid/client/SubscriptionManager.h"
-#include "qpid/sys/Time.h"
-
-using namespace qpid;
-using namespace qpid::client;
-using namespace qpid::sys;
-using std::string;
-
-namespace qpid {
-namespace tests {
-
-typedef std::vector<std::string> StringSet;
-
-struct Args : public qpid::TestOptions {
-    uint size;
-    uint count;
-    uint rate;
-    bool sync;
-    uint reportFrequency;
-    uint timeLimit;
-    uint concurrentConnections;
-    uint prefetch;
-    uint ack;
-    bool cumulative;
-    bool csv;
-    bool durable;
-    string base;
-    bool singleConnect;
-
-    Args() : size(256), count(1000), rate(0), reportFrequency(1000),
-	     timeLimit(0), concurrentConnections(1),
-             prefetch(100), ack(0),
-             durable(false), base("latency-test"), singleConnect(false)
-
-    {
-        addOptions()
-
-            ("size", optValue(size, "N"), "message size")
-            ("concurrentTests", optValue(concurrentConnections, "N"), "number of concurrent test setups, will create another publisher,\
- subcriber, queue, and connections")
-            ("single-connection", optValue(singleConnect, "yes|no"), "Use one connection for multiple sessions.")
-            ("count", optValue(count, "N"), "number of messages to send")
-            ("rate", optValue(rate, "N"), "target message rate (causes count to be ignored)")
-            ("sync", optValue(sync), "send messages synchronously")
-            ("report-frequency", optValue(reportFrequency, "N"),
-             "number of milliseconds to wait between reports (ignored unless rate specified)")
-            ("time-limit", optValue(timeLimit, "N"),
-             "test duration, in seconds")
-            ("prefetch", optValue(prefetch, "N"), "prefetch count (0 implies no flow control, and no acking)")
-            ("ack", optValue(ack, "N"), "Ack frequency in messages (defaults to half the prefetch value)")
-            ("durable", optValue(durable, "yes|no"), "use durable messages")
-            ("csv", optValue(csv), "print stats in csv format (rate,min,max,avg)")
-            ("cumulative", optValue(cumulative), "cumulative stats in csv format")
-            ("queue-base-name", optValue(base, "<name>"), "base name for queues");
-    }
-};
-
-const std::string chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
-
-Args opts;
-double c_min, c_avg, c_max;
-Connection globalConnection;
-
-uint64_t current_time()
-{
-    Duration t(EPOCH, now());
-    return t;
-}
-
-struct Stats
-{
-    Mutex lock;
-    uint count;
-    double minLatency;
-    double maxLatency;
-    double totalLatency;
-
-    Stats();
-    void update(double l);
-    void print();
-    void reset();
-};
-
-class Client : public Runnable
-{
-protected:
-    Connection* connection;
-    Connection localConnection;
-    AsyncSession session;
-    Thread thread;
-    string queue;
-
-public:
-    Client(const string& q);
-    virtual ~Client();
-
-    void start();
-    void join();
-    void run();
-    virtual void test() = 0;
-};
-
-class Receiver : public Client, public MessageListener
-{
-    SubscriptionManager mgr;
-    uint count;
-    Stats& stats;
-
-public:
-    Receiver(const string& queue, Stats& stats);
-    void test();
-    void received(Message& msg);
-    Stats getStats();
-    uint getCount() { return count; }
-    void stop() {  mgr.stop(); mgr.cancel(queue); }
-};
-
-
-class Sender : public Client
-{
-    string generateData(uint size);
-    void sendByRate();
-    void sendByCount();
-    Receiver& receiver;
-    const string data;
-
-public:
-    Sender(const string& queue, Receiver& receiver);
-    void test();
-};
-
-
-class Test
-{
-    const string queue;
-    Stats stats;
-    Receiver receiver;
-    Sender sender;
-    AbsTime begin;
-
-public:
-    Test(const string& q) : queue(q), receiver(queue, stats), sender(queue, receiver), begin(now()) {}
-    void start();
-    void join();
-    void report();
-};
-
-
-Client::Client(const string& q) : queue(q)
-{
-    if (opts.singleConnect){
-        connection = &globalConnection;
-        if (!globalConnection.isOpen()) opts.open(globalConnection);
-    }else{
-        connection = &localConnection;
-        opts.open(localConnection);
-    }
-    session = connection->newSession();
-}
-
-void Client::start()
-{
-    thread = Thread(this);
-}
-
-void Client::join()
-{
-    thread.join();
-}
-
-void Client::run()
-{
-    try{
-        test();
-    } catch(const std::exception& e) {
-        std::cout << "Error in receiver: " << e.what() << std::endl;
-    }
-}
-
-Client::~Client()
-{
-    try{
-        session.close();
-        connection->close();
-    } catch(const std::exception& e) {
-        std::cout << "Error in receiver: " << e.what() << std::endl;
-    }
-}
-
-Receiver::Receiver(const string& q, Stats& s) : Client(q), mgr(session), count(0), stats(s)
-{
-    session.queueDeclare(arg::queue=queue, arg::durable=opts.durable, arg::autoDelete=true);
-    uint msgCount = session.queueQuery(arg::queue=queue).get().getMessageCount();
-    if (msgCount) {
-        std::cout << "Warning: found " << msgCount << " msgs on " << queue << ". Purging..." << std::endl;
-        session.queuePurge(arg::queue=queue);
-        session.sync();
-    }
-    SubscriptionSettings settings;
-    if (opts.prefetch) {
-        settings.autoAck = (opts.ack ? opts.ack : (opts.prefetch / 2));
-        settings.flowControl = FlowControl::messageWindow(opts.prefetch);
-    } else {
-        settings.acceptMode = ACCEPT_MODE_NONE;
-        settings.flowControl = FlowControl::unlimited();
-    }
-    mgr.subscribe(*this, queue, settings);
-}
-
-void Receiver::test()
-{
-    mgr.run();
-    mgr.cancel(queue);
-}
-
-void Receiver::received(Message& msg)
-{
-    ++count;
-    uint64_t receivedAt = current_time();
-    uint64_t sentAt = msg.getDeliveryProperties().getTimestamp();
-
-    stats.update(((double) (receivedAt - sentAt)) / TIME_MSEC);
-
-    if (!opts.rate && count >= opts.count) {
-        mgr.stop();
-    }
-}
-
-void Stats::update(double latency)
-{
-    Mutex::ScopedLock l(lock);
-    count++;
-    minLatency = std::min(minLatency, latency);
-    maxLatency = std::max(maxLatency, latency);
-    totalLatency += latency;
-}
-
-Stats::Stats() : count(0), minLatency(std::numeric_limits<double>::max()), maxLatency(0), totalLatency(0) {}
-
-void Stats::print()
-{
-    static bool already_have_stats = false;
-    uint value;
-
-    if (opts.rate)
-        value = opts.rate;
-    else
-        value = opts.count;
-    Mutex::ScopedLock l(lock);
-    double aux_avg = (totalLatency / count);
-    if (!opts.cumulative) {
-        if (!opts.csv) {
-            if (count) {
-                std::cout << "Latency(ms): min=" << minLatency << ", max=" <<
-	                 maxLatency << ", avg=" << aux_avg;
-            } else {
-                std::cout << "Stalled: no samples for interval";
-            }
-        } else {
-            if (count) {
-          	    std::cout << value << "," << minLatency << "," << maxLatency <<
-    				     "," << aux_avg;
-            } else {
-          	    std::cout << value << "," << minLatency << "," << maxLatency <<
-    				     ", Stalled";
-            }
-        }
-    } else {
-       if (count) {
-            if (already_have_stats) {
-                c_avg = (c_min + aux_avg) / 2;
-                if (c_min > minLatency) c_min = minLatency;
-                if (c_max < maxLatency) c_max = maxLatency;
-            } else {
-                c_avg = aux_avg;
-                c_min = minLatency;
-                c_max = maxLatency;
-                already_have_stats = true;
-            }
-  	        std::cout << value << "," << c_min << "," << c_max <<
-    				     "," << c_avg;
-        } else {
-            std::cout << "Stalled: no samples for interval";
-        }
-    }
-}
-
-void Stats::reset()
-{
-    Mutex::ScopedLock l(lock);
-    count = 0;
-    totalLatency = maxLatency = 0;
-    minLatency = std::numeric_limits<double>::max();
-}
-
-Sender::Sender(const string& q, Receiver& receiver) : Client(q), receiver(receiver), data(generateData(opts.size)) {}
-
-void Sender::test()
-{
-    if (opts.rate) sendByRate();
-    else sendByCount();
-}
-
-void Sender::sendByCount()
-{
-    Message msg(data, queue);
-    if (opts.durable) {
-        msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
-    }
-
-    for (uint i = 0; i < opts.count; i++) {
-        uint64_t sentAt(current_time());
-        msg.getDeliveryProperties().setTimestamp(sentAt);
-        async(session).messageTransfer(arg::content=msg, arg::acceptMode=1);
-        if (opts.sync) session.sync();
-    }
-    session.sync();
-}
-
-void Sender::sendByRate()
-{
-    Message msg(data, queue);
-    if (opts.durable) {
-        msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
-    }
-    uint64_t interval = TIME_SEC/opts.rate;
-    int64_t timeLimit = opts.timeLimit * TIME_SEC;
-    uint64_t sent = 0, missedRate = 0;
-    AbsTime start = now();
-    while (true) {
-        AbsTime sentAt=now();
-        msg.getDeliveryProperties().setTimestamp(Duration(EPOCH, sentAt));
-        async(session).messageTransfer(arg::content=msg, arg::acceptMode=1);
-        if (opts.sync) session.sync();
-        ++sent;
-        AbsTime waitTill(start, sent*interval);
-        Duration delay(sentAt, waitTill);
-        if (delay < 0)
-            ++missedRate;
-        else
-            sys::usleep(delay / TIME_USEC);
-        if (timeLimit != 0 && Duration(start, now()) > timeLimit) {
-            session.sync();
-            receiver.stop();
-            break;
-        }
-    }
-}
-
-string Sender::generateData(uint size)
-{
-    if (size < chars.length()) {
-        return chars.substr(0, size);
-    }
-    std::string data;
-    for (uint i = 0; i < (size / chars.length()); i++) {
-        data += chars;
-    }
-    data += chars.substr(0, size % chars.length());
-    return data;
-}
-
-
-void Test::start()
-{
-    receiver.start();
-    begin = AbsTime(now());
-    sender.start();
-}
-
-void Test::join()
-{
-    sender.join();
-    receiver.join();
-    AbsTime end = now();
-    Duration time(begin, end);
-    double msecs(time / TIME_MSEC);
-    if (!opts.csv) {
-        std::cout << "Sent " << receiver.getCount() << " msgs through " << queue
-                  << " in " << msecs << "ms (" << (receiver.getCount() * 1000 / msecs) << " msgs/s) ";
-    }
-    stats.print();
-    std::cout << std::endl;
-}
-
-void Test::report()
-{
-    stats.print();
-    std::cout << std::endl;
-    stats.reset();
-}
-
-}} // namespace qpid::tests
-
-using namespace qpid::tests;
-
-int main(int argc, char** argv)
-{
-    try {
-        opts.parse(argc, argv);
-        if (opts.cumulative)
-            opts.csv = true;
-
-        Connection localConnection;
-        AsyncSession session;
-
-        boost::ptr_vector<Test> tests(opts.concurrentConnections);
-        for (uint i = 0; i < opts.concurrentConnections; i++) {
-            std::ostringstream out;
-            out << opts.base << "-" << (i+1);
-            tests.push_back(new Test(out.str()));
-        }
-        for (boost::ptr_vector<Test>::iterator i = tests.begin(); i != tests.end(); i++) {
-            i->start();
-        }
-        if (opts.rate && !opts.timeLimit) {
-            while (true) {
-                qpid::sys::usleep(opts.reportFrequency * 1000);
-                //print latency report:
-                for (boost::ptr_vector<Test>::iterator i = tests.begin(); i != tests.end(); i++) {
-                    i->report();
-                }
-            }
-        } else {
-            for (boost::ptr_vector<Test>::iterator i = tests.begin(); i != tests.end(); i++) {
-                i->join();
-            }
-        }
-
-        return 0;
-    } catch(const std::exception& e) {
-	std::cout << e.what() << std::endl;
-    }
-    return 1;
-}
diff --git a/qpid/cpp/src/tests/perftest.cpp b/qpid/cpp/src/tests/perftest.cpp
deleted file mode 100644
index 88d9fd1..0000000
--- a/qpid/cpp/src/tests/perftest.cpp
+++ /dev/null
@@ -1,741 +0,0 @@
-/*
- *
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- *
- */
-
-#include "TestOptions.h"
-
-#include "qpid/client/AsyncSession.h"
-#include "qpid/client/SubscriptionManager.h"
-#include "qpid/client/Connection.h"
-#include "qpid/client/Completion.h"
-#include "qpid/client/Message.h"
-#include "qpid/framing/FieldTable.h"
-#include "qpid/sys/Time.h"
-#include "qpid/sys/Thread.h"
-
-#include <boost/lexical_cast.hpp>
-#include <boost/bind.hpp>
-#include <boost/function.hpp>
-#include <boost/ptr_container/ptr_vector.hpp>
-
-#include <iostream>
-#include <sstream>
-#include <numeric>
-#include <algorithm>
-#include <math.h>
-
-
-using namespace std;
-using namespace qpid;
-using namespace client;
-using namespace sys;
-using boost::lexical_cast;
-using boost::bind;
-
-namespace qpid {
-namespace tests {
-
-enum Mode { SHARED, FANOUT, TOPIC };
-const char* modeNames[] = { "shared", "fanout", "topic" };
-
-// istream/ostream ops so Options can read/display Mode.
-istream& operator>>(istream& in, Mode& mode) {
-    string s;
-    in >> s;
-    int i = find(modeNames, modeNames+3, s) - modeNames;
-    if (i >= 3)  throw Exception("Invalid mode: "+s);
-    mode = Mode(i);
-    return in;
-}
-
-ostream& operator<<(ostream& out, Mode mode) {
-    return out << modeNames[mode];
-}
-
-
-struct Opts : public TestOptions {
-
-    // Actions
-    bool setup, control, publish, subscribe;
-
-    // Queue policy
-    uint32_t queueMaxCount;
-    uint64_t queueMaxSize;
-    std::string baseName;
-    bool queueDurable;
-
-    // Publisher
-    size_t pubs;
-    size_t count ;
-    size_t size;
-    bool confirm;
-    bool durable;
-    bool uniqueData;
-    bool syncPub;
-
-    // Subscriber
-    size_t subs;
-    size_t ack;
-
-    // General
-    size_t qt;
-    bool singleConnect;
-    size_t iterations;
-    Mode mode;
-    bool summary;
-    uint32_t intervalSub;
-    uint32_t intervalPub;
-    size_t tx;
-    size_t txPub;
-    size_t txSub;
-    bool commitAsync;
-
-    static const std::string helpText;
-
-    Opts() :
-        TestOptions(helpText),
-        setup(false), control(false), publish(false), subscribe(false), baseName("perftest"),
-        pubs(1), count(500000), size(1024), confirm(true), durable(false), uniqueData(false), syncPub(false),
-        subs(1), ack(0),
-        qt(1),singleConnect(false), iterations(1), mode(SHARED), summary(false),
-        intervalSub(0), intervalPub(0), tx(0), txPub(0), txSub(0), commitAsync(false)
-    {
-        addOptions()
-            ("setup", optValue(setup), "Create shared queues.")
-            ("control", optValue(control), "Run test, print report.")
-            ("publish", optValue(publish), "Publish messages.")
-            ("subscribe", optValue(subscribe), "Subscribe for messages.")
-
-            ("mode", optValue(mode, "shared|fanout|topic"), "Test mode."
-             "\nshared: --qt queues, --npubs publishers and --nsubs subscribers per queue.\n"
-             "\nfanout: --npubs publishers, --nsubs subscribers, fanout exchange."
-             "\ntopic: --qt topics, --npubs publishers and --nsubs subscribers per topic.\n")
-
-            ("npubs", optValue(pubs, "N"), "Create N publishers.")
-            ("count", optValue(count, "N"), "Each publisher sends N messages.")
-            ("size", optValue(size, "BYTES"), "Size of messages in bytes.")
-            ("pub-confirm", optValue(confirm, "yes|no"), "Publisher use confirm-mode.")
-            ("durable", optValue(durable, "yes|no"), "Publish messages as durable.")
-            ("unique-data", optValue(uniqueData, "yes|no"), "Make data for each message unique.")
-            ("sync-publish", optValue(syncPub, "yes|no"), "Wait for confirmation of each message before sending the next one.")
-
-            ("nsubs", optValue(subs, "N"), "Create N subscribers.")
-            ("sub-ack", optValue(ack, "N"), "N>0: Subscriber acks batches of N.\n"
-             "N==0: Subscriber uses unconfirmed mode")
-
-            ("qt", optValue(qt, "N"), "Create N queues or topics.")
-            ("single-connection", optValue(singleConnect, "yes|no"), "Use one connection for multiple sessions.")
-
-            ("iterations", optValue(iterations, "N"), "Desired number of iterations of the test.")
-            ("summary,s", optValue(summary), "Summary output: pubs/sec subs/sec transfers/sec Mbytes/sec")
-
-            ("queue-max-count", optValue(queueMaxCount, "N"), "queue policy: count to trigger 'flow to disk'")
-            ("queue-max-size", optValue(queueMaxSize, "N"), "queue policy: accumulated size to trigger 'flow to disk'")
-            ("base-name", optValue(baseName, "NAME"), "base name used for queues or topics")
-            ("queue-durable", optValue(queueDurable, "N"), "Make queue durable (implied if durable set)")
-
-            ("interval_sub", optValue(intervalSub, "ms"), ">=0 delay between msg consume")
-            ("interval_pub", optValue(intervalPub, "ms"), ">=0 delay between msg publish")
-
-            ("tx", optValue(tx, "N"), "if non-zero, the transaction batch size for publishing and consuming")
-            ("pub-tx", optValue(txPub, "N"), "if non-zero, the transaction batch size for publishing")
-            ("async-commit", optValue(commitAsync, "yes|no"), "Don't wait for completion of commit")
-            ("sub-tx", optValue(txSub, "N"), "if non-zero, the transaction batch size for consuming");
-    }
-
-    // Computed values
-    size_t totalPubs;
-    size_t totalSubs;
-    size_t transfers;
-    size_t subQuota;
-
-    void parse(int argc, char** argv) {
-        TestOptions::parse(argc, argv);
-        switch (mode) {
-          case SHARED:
-            if (count % subs) {
-                count += subs - (count % subs);
-                cout << "WARNING: Adjusted --count to " << count
-                     << " the nearest multiple of --nsubs" << endl;
-            }
-            totalPubs = pubs*qt;
-            totalSubs = subs*qt;
-            subQuota = (pubs*count)/subs;
-            break;
-          case FANOUT:
-            if (qt != 1) cerr << "WARNING: Fanout mode, ignoring --qt="
-                              << qt << endl;
-            qt=1;
-            totalPubs = pubs;
-            totalSubs = subs;
-            subQuota = totalPubs*count;
-            break;
-          case TOPIC:
-            totalPubs = pubs*qt;
-            totalSubs = subs*qt;
-            subQuota = pubs*count;
-            break;
-        }
-        transfers=(totalPubs*count) + (totalSubs*subQuota);
-        if (tx) {
-            if (txPub) {
-                cerr << "WARNING: Using overriden tx value for publishers: " << txPub << std::endl;
-            } else {
-                txPub = tx;
-            }
-            if (txSub) {
-                cerr << "WARNING: Using overriden tx value for subscribers: " << txSub << std::endl;
-            } else {
-                txSub = tx;
-            }
-        }
-    }
-};
-
-const std::string Opts::helpText=
-"There are two ways to use perftest: single process or multi-process.\n\n"
-"If none of the --setup, --publish, --subscribe or --control options\n"
-"are given perftest will run a single-process test.\n"
-"For a  multi-process test first run:\n"
-"  perftest --setup <other options>\n"
-"and wait for it to complete. The remaining process should run concurrently::\n"
-"Run --npubs times: perftest --publish <other options>\n"
-"Run --nsubs times: perftest --subscribe <other options>\n"
-"Run once:          perftest --control <other options>\n"
-"Note the <other options> must be identical for all processes.\n";
-
-Opts opts;
-Connection globalConnection;
-
-std::string fqn(const std::string& name)
-{
-    ostringstream fqn;
-    fqn << opts.baseName << "_" << name;
-    return fqn.str();
-}
-
-struct Client : public Runnable {
-    Connection* connection;
-    Connection localConnection;
-    AsyncSession session;
-    Thread thread;
-
-    Client() {
-        if (opts.singleConnect){
-            connection = &globalConnection;
-            if (!globalConnection.isOpen()) opts.open(globalConnection);
-        }else{
-            connection = &localConnection;
-            opts.open(localConnection);
-        }
-        session = connection->newSession();
-    }
-
-    ~Client() {
-        try {
-            if (connection->isOpen()) {
-                session.close();
-                connection->close();
-            }
-        } catch (const std::exception& e) {
-            std::cerr << "Error in shutdown: " << e.what() << std::endl;
-        }
-    }
-};
-
-struct Setup : public Client {
-
-    void queueInit(string name, bool durable=false, const framing::FieldTable& settings=framing::FieldTable()) {
-        session.queueDeclare(arg::queue=name, arg::durable=durable, arg::arguments=settings);
-        session.queuePurge(arg::queue=name);
-        session.sync();
-    }
-
-    void run() {
-        queueInit(fqn("pub_start"));
-        queueInit(fqn("pub_done"));
-        queueInit(fqn("sub_ready"));
-        queueInit(fqn("sub_done"));
-        if (opts.iterations > 1) queueInit(fqn("sub_iteration"));
-        if (opts.mode==SHARED) {
-            framing::FieldTable settings;//queue policy settings
-            settings.setInt("qpid.max_count", opts.queueMaxCount);
-            settings.setInt("qpid.max_size", opts.queueMaxSize);
-            for (size_t i = 0; i < opts.qt; ++i) {
-                ostringstream qname;
-                qname << opts.baseName << i;
-                queueInit(qname.str(), opts.durable || opts.queueDurable, settings);
-            }
-        }
-    }
-};
-
-void expect(string actual, string expect) {
-    if (expect != actual)
-        throw Exception("Expecting "+expect+" but received "+actual);
-
-}
-
-double secs(Duration d) { return double(d)/TIME_SEC; }
-double secs(AbsTime start, AbsTime finish) {
-    return secs(Duration(start,finish));
-}
-
-
-// Collect rates & print stats.
-class Stats {
-    vector<double> values;
-    double sum;
-
-  public:
-    Stats() : sum(0) {}
-
-    // Functor to collect rates.
-    void operator()(const string& data) {
-        try {
-            double d=lexical_cast<double>(data);
-            values.push_back(d);
-            sum += d;
-        } catch (const std::exception&) {
-            throw Exception("Bad report: "+data);
-        }
-    }
-
-    double mean() const {
-        return sum/values.size();
-    }
-
-    double stdev() const {
-        if (values.size() <= 1) return 0;
-        double avg = mean();
-        double ssq = 0;
-        for (vector<double>::const_iterator i = values.begin();
-             i != values.end(); ++i) {
-            double x=*i;
-            x -= avg;
-            ssq += x*x;
-        }
-        return sqrt(ssq/(values.size()-1));
-    }
-
-    ostream& print(ostream& out) {
-        ostream_iterator<double> o(out, "\n");
-        copy(values.begin(), values.end(), o);
-        out << "Average: " << mean();
-        if (values.size() > 1)
-            out << " (std.dev. " << stdev() << ")";
-        return out << endl;
-    }
-};
-
-
-// Manage control queues, collect and print reports.
-struct Controller : public Client {
-
-   SubscriptionManager subs;
-
-    Controller() : subs(session) {}
-
-    /** Process messages from queue by applying a functor. */
-    void process(size_t n, string queue,
-                 boost::function<void (const string&)> msgFn)
-    {
-        if (!opts.summary)
-            cout << "Processing " << n << " messages from "
-                 << queue << " " << flush;
-        LocalQueue lq;
-        subs.setFlowControl(n, SubscriptionManager::UNLIMITED, false);
-        subs.subscribe(lq, queue);
-        for (size_t i = 0; i < n; ++i) {
-            if (!opts.summary) cout << "." << flush;
-            msgFn(lq.pop().getData());
-        }
-        if (!opts.summary) cout << " done." << endl;
-    }
-
-    void process(size_t n, LocalQueue lq, string queue,
-                 boost::function<void (const string&)> msgFn)
-    {
-        session.messageFlow(queue, 0, n);
-        if (!opts.summary)
-            cout << "Processing " << n << " messages from "
-                 << queue << " " << flush;
-        for (size_t i = 0; i < n; ++i) {
-            if (!opts.summary) cout << "." << flush;
-            msgFn(lq.pop().getData());
-        }
-        if (!opts.summary) cout << " done." << endl;
-    }
-
-    void send(size_t n, string queue, string data) {
-        if (!opts.summary)
-            cout << "Sending " << data << " " << n << " times to " << queue
-                 << endl;
-        Message msg(data, queue);
-        for (size_t i = 0; i < n; ++i)
-            session.messageTransfer(arg::content=msg, arg::acceptMode=1);
-    }
-
-    void run() {                // Controller
-        try {
-            // Wait for subscribers to be ready.
-            process(opts.totalSubs, fqn("sub_ready"), bind(expect, _1, "ready"));
-
-            LocalQueue pubDone;
-            LocalQueue subDone;
-            subs.setFlowControl(0, SubscriptionManager::UNLIMITED, false);
-            subs.subscribe(pubDone, fqn("pub_done"));
-            subs.subscribe(subDone, fqn("sub_done"));
-
-            double txrateTotal(0);
-            double mbytesTotal(0);
-            double pubRateTotal(0);
-            double subRateTotal(0);
-
-            for (size_t j = 0; j < opts.iterations; ++j) {
-                AbsTime start=now();
-                send(opts.totalPubs, fqn("pub_start"), "start"); // Start publishers
-                if (j) {
-		    send(opts.totalPubs, fqn("sub_iteration"), "next"); // Start subscribers on next iteration
-                }
-
-                Stats pubRates;
-                Stats subRates;
-
-                process(opts.totalPubs, pubDone, fqn("pub_done"), boost::ref(pubRates));
-                process(opts.totalSubs, subDone, fqn("sub_done"), boost::ref(subRates));
-
-                AbsTime end=now();
-
-                double time=secs(start, end);
-                double txrate=opts.transfers/time;
-                double mbytes=(txrate*opts.size)/(1024*1024);
-
-                if (!opts.summary) {
-                    cout << endl << "Total " << opts.transfers << " transfers of "
-                         << opts.size << " bytes in "
-                         << time << " seconds." << endl;
-                    cout << endl << "Publish transfers/sec:    " << endl;
-                    pubRates.print(cout);
-                    cout << endl << "Subscribe transfers/sec:  " << endl;
-                    subRates.print(cout);
-                    cout << endl
-                         << "Total transfers/sec:      " << txrate << endl
-                         << "Total Mbytes/sec: " << mbytes << endl;
-                }
-                else {
-                    cout << pubRates.mean() << "\t"
-                         << subRates.mean() << "\t"
-                         << txrate << "\t"
-                         << mbytes << endl;
-                }
-
-                txrateTotal += txrate;
-                mbytesTotal += mbytes;
-                pubRateTotal += pubRates.mean();
-                subRateTotal += subRates.mean();
-            }
-            if (opts.iterations > 1) {
-                cout << "Averages: "<< endl
-                     << (pubRateTotal / opts.iterations) << "\t"
-                     << (subRateTotal / opts.iterations) << "\t"
-                     << (txrateTotal / opts.iterations) << "\t"
-                     << (mbytesTotal / opts.iterations) << endl;
-            }
-        }
-        catch (const std::exception& e) {
-            cout << "Controller exception: " << e.what() << endl;
-        }
-    }
-};
-
-
-struct PublishThread : public Client {
-    string destination;
-    string routingKey;
-
-    PublishThread() {};
-
-    PublishThread(string key, string dest=string()) {
-        destination=dest;
-        routingKey=key;
-    }
-
-    void run() {                // Publisher
-        try {
-            string data;
-            size_t offset(0);
-            if (opts.uniqueData) {
-                offset = 5;
-                data += "data:";//marker (requested for latency testing tool scripts)
-                data += string(sizeof(size_t), 'X');//space for seq no
-                data += session.getId().str();
-                if (opts.size > data.size()) {
-                    data += string(opts.size - data.size(), 'X');
-                } else if(opts.size < data.size()) {
-                    cout << "WARNING: Increased --size to " << data.size()
-                         << " to honour --unique-data" << endl;
-                }
-            } else {
-                size_t msgSize=max(opts.size, sizeof(size_t));
-                data = string(msgSize, 'X');
-            }
-
-            Message msg(data, routingKey);
-            if (opts.durable)
-                msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
-
-
-            if (opts.txPub){
-                session.txSelect();
-            }
-            SubscriptionManager subs(session);
-            LocalQueue lq;
-            subs.setFlowControl(1, SubscriptionManager::UNLIMITED, true);
-            subs.subscribe(lq, fqn("pub_start"));
-
-            for (size_t j = 0; j < opts.iterations; ++j) {
-                expect(lq.pop().getData(), "start");
-                AbsTime start=now();
-                for (size_t i=0; i<opts.count; i++) {
-                    // Stamp the iteration into the message data, avoid
-                    // any heap allocation.
-                    const_cast<std::string&>(msg.getData()).replace(offset, sizeof(size_t),
-                                          reinterpret_cast<const char*>(&i), sizeof(size_t));
-                    if (opts.syncPub) {
-                        sync(session).messageTransfer(
-                            arg::destination=destination,
-                            arg::content=msg,
-                            arg::acceptMode=1);
-                    } else {
-                        session.messageTransfer(
-                            arg::destination=destination,
-                            arg::content=msg,
-                            arg::acceptMode=1);
-                    }
-                    if (opts.txPub && ((i+1) % opts.txPub == 0)){
-                        if (opts.commitAsync){
-                            session.txCommit();
-                        } else {
-                            sync(session).txCommit();
-                        }
-                    }
-                    if (opts.intervalPub)
-                        qpid::sys::usleep(opts.intervalPub*1000);
-                }
-                if (opts.confirm) session.sync();
-                AbsTime end=now();
-                double time=secs(start,end);
-
-                // Send result to controller.
-                Message report(lexical_cast<string>(opts.count/time), fqn("pub_done"));
-                session.messageTransfer(arg::content=report, arg::acceptMode=1);
-                if (opts.txPub){
-                    sync(session).txCommit();
-                }
-            }
-            session.close();
-        }
-        catch (const std::exception& e) {
-            cout << "PublishThread exception: " << e.what() << endl;
-        }
-    }
-};
-
-struct SubscribeThread : public Client {
-
-    string queue;
-
-    SubscribeThread() {}
-
-    SubscribeThread(string q) { queue = q; }
-
-    SubscribeThread(string key, string ex) {
-        queue=session.getId().str(); // Unique name.
-        session.queueDeclare(arg::queue=queue,
-                             arg::exclusive=true,
-                             arg::autoDelete=true,
-                             arg::durable=opts.durable);
-        session.exchangeBind(arg::queue=queue,
-                             arg::exchange=ex,
-                             arg::bindingKey=key);
-    }
-
-    void verify(bool cond, const char* test, uint32_t expect, uint32_t actual) {
-        if (!cond) {
-            Message error(
-                QPID_MSG("Sequence error: expected  n" << test << expect << " but got " << actual),
-                "sub_done");
-            session.messageTransfer(arg::content=error, arg::acceptMode=1);
-            throw Exception(error.getData());
-        }
-    }
-
-    void run() {                // Subscribe
-        try {
-            if (opts.txSub) sync(session).txSelect();
-            SubscriptionManager subs(session);
-            SubscriptionSettings settings;
-            settings.autoAck = opts.txSub ? opts.txSub : opts.ack;
-            settings.acceptMode = (opts.txSub || opts.ack ? ACCEPT_MODE_EXPLICIT : ACCEPT_MODE_NONE);
-            settings.flowControl = FlowControl::messageCredit(opts.subQuota);
-            LocalQueue lq;
-            Subscription subscription = subs.subscribe(lq, queue, settings);
-            // Notify controller we are ready.
-            session.messageTransfer(arg::content=Message("ready", fqn("sub_ready")), arg::acceptMode=1);
-            if (opts.txSub) {
-                if (opts.commitAsync) session.txCommit();
-                else sync(session).txCommit();
-            }
-
-            LocalQueue iterationControl;
-            if (opts.iterations > 1) {
-                subs.subscribe(iterationControl, fqn("sub_iteration"), SubscriptionSettings(FlowControl::messageCredit(0)));
-            }
-
-            for (size_t j = 0; j < opts.iterations; ++j) {
-                if (j > 0) {
-                    //need to wait here until all subs are done
-                    session.messageFlow(fqn("sub_iteration"), 0, 1);
-                    iterationControl.pop();
-
-                    //need to allocate some more credit for subscription
-                    session.messageFlow(queue, 0, opts.subQuota);
-                }
-                Message msg;
-                AbsTime start=now();
-                size_t expect=0;
-                for (size_t i = 0; i < opts.subQuota; ++i) {
-                    msg=lq.pop();
-                    if (opts.txSub && ((i+1) % opts.txSub == 0)) {
-                        if (opts.commitAsync) session.txCommit();
-                        else sync(session).txCommit();
-                    }
-                    if (opts.intervalSub)
-                        qpid::sys::usleep(opts.intervalSub*1000);
-                    // TODO aconway 2007-11-23: check message order for.
-                    // multiple publishers. Need an array of counters,
-                    // one per publisher and a publisher ID in the
-                    // message. Careful not to introduce a lot of overhead
-                    // here, e.g. no std::map, std::string etc.
-                    //
-                    // For now verify order only for a single publisher.
-                    size_t offset = opts.uniqueData ? 5 /*marker is 'data:'*/ : 0;
-                    size_t n = *reinterpret_cast<const size_t*>(msg.getData().data() + offset);
-                    if (opts.pubs == 1) {
-                        if (opts.subs == 1 || opts.mode == FANOUT) verify(n==expect, "==", expect, n);
-                        else verify(n>=expect, ">=", expect, n);
-                        expect = n+1;
-                    }
-                }
-                if (opts.txSub || opts.ack)
-                    subscription.accept(subscription.getUnaccepted());
-                if (opts.txSub) {
-                    if (opts.commitAsync) session.txCommit();
-                    else sync(session).txCommit();
-                }
-                AbsTime end=now();
-
-                // Report to publisher.
-                Message result(lexical_cast<string>(opts.subQuota/secs(start,end)),
-                               fqn("sub_done"));
-                session.messageTransfer(arg::content=result, arg::acceptMode=1);
-                if (opts.txSub) sync(session).txCommit();
-            }
-            session.close();
-        }
-        catch (const std::exception& e) {
-            cout << "SubscribeThread exception: " << e.what() << endl;
-        }
-    }
-};
-
-}} // namespace qpid::tests
-
-using namespace qpid::tests;
-
-int main(int argc, char** argv) {
-    int exitCode = 0;
-    boost::ptr_vector<Client> subs(opts.subs);
-    boost::ptr_vector<Client> pubs(opts.pubs);
-
-    try {
-        opts.parse(argc, argv);
-
-        string exchange;
-        switch (opts.mode) {
-            case FANOUT: exchange="amq.fanout"; break;
-            case TOPIC: exchange="amq.topic"; break;
-            case SHARED: break;
-        }
-
-        bool singleProcess=
-            (!opts.setup && !opts.control && !opts.publish && !opts.subscribe);
-        if (singleProcess)
-            opts.setup = opts.control = opts.publish = opts.subscribe = true;
-
-        if (opts.setup) Setup().run();          // Set up queues
-
-        // Start pubs/subs for each queue/topic.
-        for (size_t i = 0; i < opts.qt; ++i) {
-            ostringstream key;
-            key << opts.baseName << i; // Queue or topic name.
-            if (opts.publish) {
-                size_t n = singleProcess ? opts.pubs : 1;
-                for (size_t j = 0; j < n; ++j)  {
-                    pubs.push_back(new PublishThread(key.str(), exchange));
-                    pubs.back().thread=Thread(pubs.back());
-                }
-            }
-            if (opts.subscribe) {
-                size_t n = singleProcess ? opts.subs : 1;
-                for (size_t j = 0; j < n; ++j)  {
-                    if (opts.mode==SHARED)
-                        subs.push_back(new SubscribeThread(key.str()));
-                    else
-                        subs.push_back(new SubscribeThread(key.str(),exchange));
-                    subs.back().thread=Thread(subs.back());
-                }
-            }
-        }
-
-        if (opts.control) Controller().run();
-    }
-    catch (const std::exception& e) {
-        cout << endl << e.what() << endl;
-        exitCode = 1;
-    }
-
-    // Wait for started threads.
-    if (opts.publish) {
-        for (boost::ptr_vector<Client>::iterator i=pubs.begin();
-             i != pubs.end();
-             ++i)
-            i->thread.join();
-    }
-
-    if (opts.subscribe) {
-        for (boost::ptr_vector<Client>::iterator i=subs.begin();
-             i != subs.end();
-             ++i)
-            i->thread.join();
-    }
-    return exitCode;
-}
diff --git a/qpid/cpp/src/tests/qpid-client-test.cpp b/qpid/cpp/src/tests/qpid-client-test.cpp
new file mode 100644
index 0000000..2f5e8e5
--- /dev/null
+++ b/qpid/cpp/src/tests/qpid-client-test.cpp
@@ -0,0 +1,139 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+/**
+ * This file provides a simple test (and example) of basic
+ * functionality including declaring an exchange and a queue, binding
+ * these together, publishing a message and receiving that message
+ * asynchronously.
+ */
+
+#include <iostream>
+
+#include "TestOptions.h"
+#include "qpid/client/Connection.h"
+#include "qpid/client/Message.h"
+#include "qpid/client/Session.h"
+#include "qpid/client/SubscriptionManager.h"
+
+
+using namespace qpid;
+using namespace qpid::client;
+using namespace qpid::framing;
+using std::string;
+
+namespace qpid {
+namespace tests {
+
+struct Args : public TestOptions {
+    uint msgSize;
+    bool verbose;
+
+    Args() : TestOptions("Simple test of Qpid c++ client; sends and receives a single message."), msgSize(26)
+    {
+        addOptions()
+            ("size", optValue(msgSize, "N"), "message size")
+            ("verbose", optValue(verbose), "print out some status messages");
+    }
+};
+
+const std::string chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
+
+std::string generateData(uint size)
+{
+    if (size < chars.length()) {
+        return chars.substr(0, size);
+    }
+    std::string data;
+    for (uint i = 0; i < (size / chars.length()); i++) {
+        data += chars;
+    }
+    data += chars.substr(0, size % chars.length());
+    return data;
+}
+
+void print(const std::string& text, const Message& msg)
+{
+    std::cout << text;
+    if (msg.getData().size() > 16) {
+        std::cout << msg.getData().substr(0, 16) << "...";
+    } else {
+        std::cout << msg.getData();
+    }
+    std::cout << std::endl;
+}
+
+}} // namespace qpid::tests
+
+using namespace qpid::tests;
+
+int main(int argc, char** argv)
+{
+    try {
+        Args opts;
+        opts.parse(argc, argv);
+
+        //Connect to the broker:
+        Connection connection;
+        opts.open(connection);
+	if (opts.verbose) std::cout << "Opened connection." << std::endl;
+
+        //Create and open a session on the connection through which
+        //most functionality is exposed:
+        Session session = connection.newSession();
+	if (opts.verbose) std::cout << "Opened session." << std::endl;
+
+
+        //'declare' the exchange and the queue, which will create them
+        //as they don't exist
+	session.exchangeDeclare(arg::exchange="MyExchange", arg::type="direct");
+	if (opts.verbose) std::cout << "Declared exchange." << std::endl;
+	session.queueDeclare(arg::queue="MyQueue", arg::autoDelete=true, arg::exclusive=true);
+	if (opts.verbose) std::cout << "Declared queue." << std::endl;
+
+        //now bind the queue to the exchange
+	session.exchangeBind(arg::exchange="MyExchange", arg::queue="MyQueue", arg::bindingKey="MyKey");
+	if (opts.verbose) std::cout << "Bound queue to exchange." << std::endl;
+
+        //create and send a message to the exchange using the routing
+        //key we bound our queue with:
+	Message msgOut(generateData(opts.msgSize));
+        msgOut.getDeliveryProperties().setRoutingKey("MyKey");
+        session.messageTransfer(arg::destination="MyExchange", arg::content=msgOut, arg::acceptMode=1);
+	if (opts.verbose) print("Published message: ", msgOut);
+
+        // Using the SubscriptionManager, get the message from the queue.
+        SubscriptionManager subs(session);
+        Message msgIn = subs.get("MyQueue");
+        if (msgIn.getData() == msgOut.getData())
+            if (opts.verbose) std::cout << "Received the exepected message." << std::endl;
+
+        //close the session & connection
+	session.close();
+	if (opts.verbose) std::cout << "Closed session." << std::endl;
+	connection.close();
+	if (opts.verbose) std::cout << "Closed connection." << std::endl;
+        return 0;
+    } catch(const std::exception& e) {
+	std::cout << e.what() << std::endl;
+    }
+    return 1;
+}
diff --git a/qpid/cpp/src/tests/qpid-latency-test.cpp b/qpid/cpp/src/tests/qpid-latency-test.cpp
new file mode 100644
index 0000000..20eb456
--- /dev/null
+++ b/qpid/cpp/src/tests/qpid-latency-test.cpp
@@ -0,0 +1,469 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+
+#include <algorithm>
+#include <limits>
+#include <iostream>
+#include <memory>
+#include <sstream>
+#include <vector>
+
+#include "TestOptions.h"
+#include "qpid/sys/Thread.h"
+#include "qpid/client/Connection.h"
+#include "qpid/client/Message.h"
+#include "qpid/client/AsyncSession.h"
+#include "qpid/client/SubscriptionManager.h"
+#include "qpid/sys/Time.h"
+
+using namespace qpid;
+using namespace qpid::client;
+using namespace qpid::sys;
+using std::string;
+
+namespace qpid {
+namespace tests {
+
+typedef std::vector<std::string> StringSet;
+
+struct Args : public qpid::TestOptions {
+    uint size;
+    uint count;
+    uint rate;
+    bool sync;
+    uint reportFrequency;
+    uint timeLimit;
+    uint concurrentConnections;
+    uint prefetch;
+    uint ack;
+    bool cumulative;
+    bool csv;
+    bool durable;
+    string base;
+    bool singleConnect;
+
+    Args() : size(256), count(1000), rate(0), reportFrequency(1000),
+	     timeLimit(0), concurrentConnections(1),
+             prefetch(100), ack(0),
+             durable(false), base("latency-test"), singleConnect(false)
+
+    {
+        addOptions()
+
+            ("size", optValue(size, "N"), "message size")
+            ("concurrentTests", optValue(concurrentConnections, "N"), "number of concurrent test setups, will create another publisher,\
+ subcriber, queue, and connections")
+            ("single-connection", optValue(singleConnect, "yes|no"), "Use one connection for multiple sessions.")
+            ("count", optValue(count, "N"), "number of messages to send")
+            ("rate", optValue(rate, "N"), "target message rate (causes count to be ignored)")
+            ("sync", optValue(sync), "send messages synchronously")
+            ("report-frequency", optValue(reportFrequency, "N"),
+             "number of milliseconds to wait between reports (ignored unless rate specified)")
+            ("time-limit", optValue(timeLimit, "N"),
+             "test duration, in seconds")
+            ("prefetch", optValue(prefetch, "N"), "prefetch count (0 implies no flow control, and no acking)")
+            ("ack", optValue(ack, "N"), "Ack frequency in messages (defaults to half the prefetch value)")
+            ("durable", optValue(durable, "yes|no"), "use durable messages")
+            ("csv", optValue(csv), "print stats in csv format (rate,min,max,avg)")
+            ("cumulative", optValue(cumulative), "cumulative stats in csv format")
+            ("queue-base-name", optValue(base, "<name>"), "base name for queues");
+    }
+};
+
+const std::string chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
+
+Args opts;
+double c_min, c_avg, c_max;
+Connection globalConnection;
+
+uint64_t current_time()
+{
+    Duration t(EPOCH, now());
+    return t;
+}
+
+struct Stats
+{
+    Mutex lock;
+    uint count;
+    double minLatency;
+    double maxLatency;
+    double totalLatency;
+
+    Stats();
+    void update(double l);
+    void print();
+    void reset();
+};
+
+class Client : public Runnable
+{
+protected:
+    Connection* connection;
+    Connection localConnection;
+    AsyncSession session;
+    Thread thread;
+    string queue;
+
+public:
+    Client(const string& q);
+    virtual ~Client();
+
+    void start();
+    void join();
+    void run();
+    virtual void test() = 0;
+};
+
+class Receiver : public Client, public MessageListener
+{
+    SubscriptionManager mgr;
+    uint count;
+    Stats& stats;
+
+public:
+    Receiver(const string& queue, Stats& stats);
+    void test();
+    void received(Message& msg);
+    Stats getStats();
+    uint getCount() { return count; }
+    void stop() {  mgr.stop(); mgr.cancel(queue); }
+};
+
+
+class Sender : public Client
+{
+    string generateData(uint size);
+    void sendByRate();
+    void sendByCount();
+    Receiver& receiver;
+    const string data;
+
+public:
+    Sender(const string& queue, Receiver& receiver);
+    void test();
+};
+
+
+class Test
+{
+    const string queue;
+    Stats stats;
+    Receiver receiver;
+    Sender sender;
+    AbsTime begin;
+
+public:
+    Test(const string& q) : queue(q), receiver(queue, stats), sender(queue, receiver), begin(now()) {}
+    void start();
+    void join();
+    void report();
+};
+
+
+Client::Client(const string& q) : queue(q)
+{
+    if (opts.singleConnect){
+        connection = &globalConnection;
+        if (!globalConnection.isOpen()) opts.open(globalConnection);
+    }else{
+        connection = &localConnection;
+        opts.open(localConnection);
+    }
+    session = connection->newSession();
+}
+
+void Client::start()
+{
+    thread = Thread(this);
+}
+
+void Client::join()
+{
+    thread.join();
+}
+
+void Client::run()
+{
+    try{
+        test();
+    } catch(const std::exception& e) {
+        std::cout << "Error in receiver: " << e.what() << std::endl;
+    }
+}
+
+Client::~Client()
+{
+    try{
+        session.close();
+        connection->close();
+    } catch(const std::exception& e) {
+        std::cout << "Error in receiver: " << e.what() << std::endl;
+    }
+}
+
+Receiver::Receiver(const string& q, Stats& s) : Client(q), mgr(session), count(0), stats(s)
+{
+    session.queueDeclare(arg::queue=queue, arg::durable=opts.durable, arg::autoDelete=true);
+    uint msgCount = session.queueQuery(arg::queue=queue).get().getMessageCount();
+    if (msgCount) {
+        std::cout << "Warning: found " << msgCount << " msgs on " << queue << ". Purging..." << std::endl;
+        session.queuePurge(arg::queue=queue);
+        session.sync();
+    }
+    SubscriptionSettings settings;
+    if (opts.prefetch) {
+        settings.autoAck = (opts.ack ? opts.ack : (opts.prefetch / 2));
+        settings.flowControl = FlowControl::messageWindow(opts.prefetch);
+    } else {
+        settings.acceptMode = ACCEPT_MODE_NONE;
+        settings.flowControl = FlowControl::unlimited();
+    }
+    mgr.subscribe(*this, queue, settings);
+}
+
+void Receiver::test()
+{
+    mgr.run();
+    mgr.cancel(queue);
+}
+
+void Receiver::received(Message& msg)
+{
+    ++count;
+    uint64_t receivedAt = current_time();
+    uint64_t sentAt = msg.getDeliveryProperties().getTimestamp();
+
+    stats.update(((double) (receivedAt - sentAt)) / TIME_MSEC);
+
+    if (!opts.rate && count >= opts.count) {
+        mgr.stop();
+    }
+}
+
+void Stats::update(double latency)
+{
+    Mutex::ScopedLock l(lock);
+    count++;
+    minLatency = std::min(minLatency, latency);
+    maxLatency = std::max(maxLatency, latency);
+    totalLatency += latency;
+}
+
+Stats::Stats() : count(0), minLatency(std::numeric_limits<double>::max()), maxLatency(0), totalLatency(0) {}
+
+void Stats::print()
+{
+    static bool already_have_stats = false;
+    uint value;
+
+    if (opts.rate)
+        value = opts.rate;
+    else
+        value = opts.count;
+    Mutex::ScopedLock l(lock);
+    double aux_avg = (totalLatency / count);
+    if (!opts.cumulative) {
+        if (!opts.csv) {
+            if (count) {
+                std::cout << "Latency(ms): min=" << minLatency << ", max=" <<
+	                 maxLatency << ", avg=" << aux_avg;
+            } else {
+                std::cout << "Stalled: no samples for interval";
+            }
+        } else {
+            if (count) {
+          	    std::cout << value << "," << minLatency << "," << maxLatency <<
+    				     "," << aux_avg;
+            } else {
+          	    std::cout << value << "," << minLatency << "," << maxLatency <<
+    				     ", Stalled";
+            }
+        }
+    } else {
+       if (count) {
+            if (already_have_stats) {
+                c_avg = (c_min + aux_avg) / 2;
+                if (c_min > minLatency) c_min = minLatency;
+                if (c_max < maxLatency) c_max = maxLatency;
+            } else {
+                c_avg = aux_avg;
+                c_min = minLatency;
+                c_max = maxLatency;
+                already_have_stats = true;
+            }
+  	        std::cout << value << "," << c_min << "," << c_max <<
+    				     "," << c_avg;
+        } else {
+            std::cout << "Stalled: no samples for interval";
+        }
+    }
+}
+
+void Stats::reset()
+{
+    Mutex::ScopedLock l(lock);
+    count = 0;
+    totalLatency = maxLatency = 0;
+    minLatency = std::numeric_limits<double>::max();
+}
+
+Sender::Sender(const string& q, Receiver& receiver) : Client(q), receiver(receiver), data(generateData(opts.size)) {}
+
+void Sender::test()
+{
+    if (opts.rate) sendByRate();
+    else sendByCount();
+}
+
+void Sender::sendByCount()
+{
+    Message msg(data, queue);
+    if (opts.durable) {
+        msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
+    }
+
+    for (uint i = 0; i < opts.count; i++) {
+        uint64_t sentAt(current_time());
+        msg.getDeliveryProperties().setTimestamp(sentAt);
+        async(session).messageTransfer(arg::content=msg, arg::acceptMode=1);
+        if (opts.sync) session.sync();
+    }
+    session.sync();
+}
+
+void Sender::sendByRate()
+{
+    Message msg(data, queue);
+    if (opts.durable) {
+        msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
+    }
+    uint64_t interval = TIME_SEC/opts.rate;
+    int64_t timeLimit = opts.timeLimit * TIME_SEC;
+    uint64_t sent = 0, missedRate = 0;
+    AbsTime start = now();
+    while (true) {
+        AbsTime sentAt=now();
+        msg.getDeliveryProperties().setTimestamp(Duration(EPOCH, sentAt));
+        async(session).messageTransfer(arg::content=msg, arg::acceptMode=1);
+        if (opts.sync) session.sync();
+        ++sent;
+        AbsTime waitTill(start, sent*interval);
+        Duration delay(sentAt, waitTill);
+        if (delay < 0)
+            ++missedRate;
+        else
+            sys::usleep(delay / TIME_USEC);
+        if (timeLimit != 0 && Duration(start, now()) > timeLimit) {
+            session.sync();
+            receiver.stop();
+            break;
+        }
+    }
+}
+
+string Sender::generateData(uint size)
+{
+    if (size < chars.length()) {
+        return chars.substr(0, size);
+    }
+    std::string data;
+    for (uint i = 0; i < (size / chars.length()); i++) {
+        data += chars;
+    }
+    data += chars.substr(0, size % chars.length());
+    return data;
+}
+
+
+void Test::start()
+{
+    receiver.start();
+    begin = AbsTime(now());
+    sender.start();
+}
+
+void Test::join()
+{
+    sender.join();
+    receiver.join();
+    AbsTime end = now();
+    Duration time(begin, end);
+    double msecs(time / TIME_MSEC);
+    if (!opts.csv) {
+        std::cout << "Sent " << receiver.getCount() << " msgs through " << queue
+                  << " in " << msecs << "ms (" << (receiver.getCount() * 1000 / msecs) << " msgs/s) ";
+    }
+    stats.print();
+    std::cout << std::endl;
+}
+
+void Test::report()
+{
+    stats.print();
+    std::cout << std::endl;
+    stats.reset();
+}
+
+}} // namespace qpid::tests
+
+using namespace qpid::tests;
+
+int main(int argc, char** argv)
+{
+    try {
+        opts.parse(argc, argv);
+        if (opts.cumulative)
+            opts.csv = true;
+
+        Connection localConnection;
+        AsyncSession session;
+
+        boost::ptr_vector<Test> tests(opts.concurrentConnections);
+        for (uint i = 0; i < opts.concurrentConnections; i++) {
+            std::ostringstream out;
+            out << opts.base << "-" << (i+1);
+            tests.push_back(new Test(out.str()));
+        }
+        for (boost::ptr_vector<Test>::iterator i = tests.begin(); i != tests.end(); i++) {
+            i->start();
+        }
+        if (opts.rate && !opts.timeLimit) {
+            while (true) {
+                qpid::sys::usleep(opts.reportFrequency * 1000);
+                //print latency report:
+                for (boost::ptr_vector<Test>::iterator i = tests.begin(); i != tests.end(); i++) {
+                    i->report();
+                }
+            }
+        } else {
+            for (boost::ptr_vector<Test>::iterator i = tests.begin(); i != tests.end(); i++) {
+                i->join();
+            }
+        }
+
+        return 0;
+    } catch(const std::exception& e) {
+	std::cout << e.what() << std::endl;
+    }
+    return 1;
+}
diff --git a/qpid/cpp/src/tests/qpid-perftest.cpp b/qpid/cpp/src/tests/qpid-perftest.cpp
new file mode 100644
index 0000000..7058851
--- /dev/null
+++ b/qpid/cpp/src/tests/qpid-perftest.cpp
@@ -0,0 +1,741 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+#include "TestOptions.h"
+
+#include "qpid/client/AsyncSession.h"
+#include "qpid/client/SubscriptionManager.h"
+#include "qpid/client/Connection.h"
+#include "qpid/client/Completion.h"
+#include "qpid/client/Message.h"
+#include "qpid/framing/FieldTable.h"
+#include "qpid/sys/Time.h"
+#include "qpid/sys/Thread.h"
+
+#include <boost/lexical_cast.hpp>
+#include <boost/bind.hpp>
+#include <boost/function.hpp>
+#include <boost/ptr_container/ptr_vector.hpp>
+
+#include <iostream>
+#include <sstream>
+#include <numeric>
+#include <algorithm>
+#include <math.h>
+
+
+using namespace std;
+using namespace qpid;
+using namespace client;
+using namespace sys;
+using boost::lexical_cast;
+using boost::bind;
+
+namespace qpid {
+namespace tests {
+
+enum Mode { SHARED, FANOUT, TOPIC };
+const char* modeNames[] = { "shared", "fanout", "topic" };
+
+// istream/ostream ops so Options can read/display Mode.
+istream& operator>>(istream& in, Mode& mode) {
+    string s;
+    in >> s;
+    int i = find(modeNames, modeNames+3, s) - modeNames;
+    if (i >= 3)  throw Exception("Invalid mode: "+s);
+    mode = Mode(i);
+    return in;
+}
+
+ostream& operator<<(ostream& out, Mode mode) {
+    return out << modeNames[mode];
+}
+
+
+struct Opts : public TestOptions {
+
+    // Actions
+    bool setup, control, publish, subscribe;
+
+    // Queue policy
+    uint32_t queueMaxCount;
+    uint64_t queueMaxSize;
+    std::string baseName;
+    bool queueDurable;
+
+    // Publisher
+    size_t pubs;
+    size_t count ;
+    size_t size;
+    bool confirm;
+    bool durable;
+    bool uniqueData;
+    bool syncPub;
+
+    // Subscriber
+    size_t subs;
+    size_t ack;
+
+    // General
+    size_t qt;
+    bool singleConnect;
+    size_t iterations;
+    Mode mode;
+    bool summary;
+    uint32_t intervalSub;
+    uint32_t intervalPub;
+    size_t tx;
+    size_t txPub;
+    size_t txSub;
+    bool commitAsync;
+
+    static const std::string helpText;
+
+    Opts() :
+        TestOptions(helpText),
+        setup(false), control(false), publish(false), subscribe(false), baseName("qpid-perftest"),
+        pubs(1), count(500000), size(1024), confirm(true), durable(false), uniqueData(false), syncPub(false),
+        subs(1), ack(0),
+        qt(1),singleConnect(false), iterations(1), mode(SHARED), summary(false),
+        intervalSub(0), intervalPub(0), tx(0), txPub(0), txSub(0), commitAsync(false)
+    {
+        addOptions()
+            ("setup", optValue(setup), "Create shared queues.")
+            ("control", optValue(control), "Run test, print report.")
+            ("publish", optValue(publish), "Publish messages.")
+            ("subscribe", optValue(subscribe), "Subscribe for messages.")
+
+            ("mode", optValue(mode, "shared|fanout|topic"), "Test mode."
+             "\nshared: --qt queues, --npubs publishers and --nsubs subscribers per queue.\n"
+             "\nfanout: --npubs publishers, --nsubs subscribers, fanout exchange."
+             "\ntopic: --qt topics, --npubs publishers and --nsubs subscribers per topic.\n")
+
+            ("npubs", optValue(pubs, "N"), "Create N publishers.")
+            ("count", optValue(count, "N"), "Each publisher sends N messages.")
+            ("size", optValue(size, "BYTES"), "Size of messages in bytes.")
+            ("pub-confirm", optValue(confirm, "yes|no"), "Publisher use confirm-mode.")
+            ("durable", optValue(durable, "yes|no"), "Publish messages as durable.")
+            ("unique-data", optValue(uniqueData, "yes|no"), "Make data for each message unique.")
+            ("sync-publish", optValue(syncPub, "yes|no"), "Wait for confirmation of each message before sending the next one.")
+
+            ("nsubs", optValue(subs, "N"), "Create N subscribers.")
+            ("sub-ack", optValue(ack, "N"), "N>0: Subscriber acks batches of N.\n"
+             "N==0: Subscriber uses unconfirmed mode")
+
+            ("qt", optValue(qt, "N"), "Create N queues or topics.")
+            ("single-connection", optValue(singleConnect, "yes|no"), "Use one connection for multiple sessions.")
+
+            ("iterations", optValue(iterations, "N"), "Desired number of iterations of the test.")
+            ("summary,s", optValue(summary), "Summary output: pubs/sec subs/sec transfers/sec Mbytes/sec")
+
+            ("queue-max-count", optValue(queueMaxCount, "N"), "queue policy: count to trigger 'flow to disk'")
+            ("queue-max-size", optValue(queueMaxSize, "N"), "queue policy: accumulated size to trigger 'flow to disk'")
+            ("base-name", optValue(baseName, "NAME"), "base name used for queues or topics")
+            ("queue-durable", optValue(queueDurable, "N"), "Make queue durable (implied if durable set)")
+
+            ("interval_sub", optValue(intervalSub, "ms"), ">=0 delay between msg consume")
+            ("interval_pub", optValue(intervalPub, "ms"), ">=0 delay between msg publish")
+
+            ("tx", optValue(tx, "N"), "if non-zero, the transaction batch size for publishing and consuming")
+            ("pub-tx", optValue(txPub, "N"), "if non-zero, the transaction batch size for publishing")
+            ("async-commit", optValue(commitAsync, "yes|no"), "Don't wait for completion of commit")
+            ("sub-tx", optValue(txSub, "N"), "if non-zero, the transaction batch size for consuming");
+    }
+
+    // Computed values
+    size_t totalPubs;
+    size_t totalSubs;
+    size_t transfers;
+    size_t subQuota;
+
+    void parse(int argc, char** argv) {
+        TestOptions::parse(argc, argv);
+        switch (mode) {
+          case SHARED:
+            if (count % subs) {
+                count += subs - (count % subs);
+                cout << "WARNING: Adjusted --count to " << count
+                     << " the nearest multiple of --nsubs" << endl;
+            }
+            totalPubs = pubs*qt;
+            totalSubs = subs*qt;
+            subQuota = (pubs*count)/subs;
+            break;
+          case FANOUT:
+            if (qt != 1) cerr << "WARNING: Fanout mode, ignoring --qt="
+                              << qt << endl;
+            qt=1;
+            totalPubs = pubs;
+            totalSubs = subs;
+            subQuota = totalPubs*count;
+            break;
+          case TOPIC:
+            totalPubs = pubs*qt;
+            totalSubs = subs*qt;
+            subQuota = pubs*count;
+            break;
+        }
+        transfers=(totalPubs*count) + (totalSubs*subQuota);
+        if (tx) {
+            if (txPub) {
+                cerr << "WARNING: Using overriden tx value for publishers: " << txPub << std::endl;
+            } else {
+                txPub = tx;
+            }
+            if (txSub) {
+                cerr << "WARNING: Using overriden tx value for subscribers: " << txSub << std::endl;
+            } else {
+                txSub = tx;
+            }
+        }
+    }
+};
+
+const std::string Opts::helpText=
+"There are two ways to use qpid-perftest: single process or multi-process.\n\n"
+"If none of the --setup, --publish, --subscribe or --control options\n"
+"are given qpid-perftest will run a single-process test.\n"
+"For a  multi-process test first run:\n"
+"  qpid-perftest --setup <other options>\n"
+"and wait for it to complete. The remaining process should run concurrently::\n"
+"Run --npubs times: pqid-perftest --publish <other options>\n"
+"Run --nsubs times: qpid-perftest --subscribe <other options>\n"
+"Run once:          qpid-perftest --control <other options>\n"
+"Note the <other options> must be identical for all processes.\n";
+
+Opts opts;
+Connection globalConnection;
+
+std::string fqn(const std::string& name)
+{
+    ostringstream fqn;
+    fqn << opts.baseName << "_" << name;
+    return fqn.str();
+}
+
+struct Client : public Runnable {
+    Connection* connection;
+    Connection localConnection;
+    AsyncSession session;
+    Thread thread;
+
+    Client() {
+        if (opts.singleConnect){
+            connection = &globalConnection;
+            if (!globalConnection.isOpen()) opts.open(globalConnection);
+        }else{
+            connection = &localConnection;
+            opts.open(localConnection);
+        }
+        session = connection->newSession();
+    }
+
+    ~Client() {
+        try {
+            if (connection->isOpen()) {
+                session.close();
+                connection->close();
+            }
+        } catch (const std::exception& e) {
+            std::cerr << "Error in shutdown: " << e.what() << std::endl;
+        }
+    }
+};
+
+struct Setup : public Client {
+
+    void queueInit(string name, bool durable=false, const framing::FieldTable& settings=framing::FieldTable()) {
+        session.queueDeclare(arg::queue=name, arg::durable=durable, arg::arguments=settings);
+        session.queuePurge(arg::queue=name);
+        session.sync();
+    }
+
+    void run() {
+        queueInit(fqn("pub_start"));
+        queueInit(fqn("pub_done"));
+        queueInit(fqn("sub_ready"));
+        queueInit(fqn("sub_done"));
+        if (opts.iterations > 1) queueInit(fqn("sub_iteration"));
+        if (opts.mode==SHARED) {
+            framing::FieldTable settings;//queue policy settings
+            settings.setInt("qpid.max_count", opts.queueMaxCount);
+            settings.setInt("qpid.max_size", opts.queueMaxSize);
+            for (size_t i = 0; i < opts.qt; ++i) {
+                ostringstream qname;
+                qname << opts.baseName << i;
+                queueInit(qname.str(), opts.durable || opts.queueDurable, settings);
+            }
+        }
+    }
+};
+
+void expect(string actual, string expect) {
+    if (expect != actual)
+        throw Exception("Expecting "+expect+" but received "+actual);
+
+}
+
+double secs(Duration d) { return double(d)/TIME_SEC; }
+double secs(AbsTime start, AbsTime finish) {
+    return secs(Duration(start,finish));
+}
+
+
+// Collect rates & print stats.
+class Stats {
+    vector<double> values;
+    double sum;
+
+  public:
+    Stats() : sum(0) {}
+
+    // Functor to collect rates.
+    void operator()(const string& data) {
+        try {
+            double d=lexical_cast<double>(data);
+            values.push_back(d);
+            sum += d;
+        } catch (const std::exception&) {
+            throw Exception("Bad report: "+data);
+        }
+    }
+
+    double mean() const {
+        return sum/values.size();
+    }
+
+    double stdev() const {
+        if (values.size() <= 1) return 0;
+        double avg = mean();
+        double ssq = 0;
+        for (vector<double>::const_iterator i = values.begin();
+             i != values.end(); ++i) {
+            double x=*i;
+            x -= avg;
+            ssq += x*x;
+        }
+        return sqrt(ssq/(values.size()-1));
+    }
+
+    ostream& print(ostream& out) {
+        ostream_iterator<double> o(out, "\n");
+        copy(values.begin(), values.end(), o);
+        out << "Average: " << mean();
+        if (values.size() > 1)
+            out << " (std.dev. " << stdev() << ")";
+        return out << endl;
+    }
+};
+
+
+// Manage control queues, collect and print reports.
+struct Controller : public Client {
+
+   SubscriptionManager subs;
+
+    Controller() : subs(session) {}
+
+    /** Process messages from queue by applying a functor. */
+    void process(size_t n, string queue,
+                 boost::function<void (const string&)> msgFn)
+    {
+        if (!opts.summary)
+            cout << "Processing " << n << " messages from "
+                 << queue << " " << flush;
+        LocalQueue lq;
+        subs.setFlowControl(n, SubscriptionManager::UNLIMITED, false);
+        subs.subscribe(lq, queue);
+        for (size_t i = 0; i < n; ++i) {
+            if (!opts.summary) cout << "." << flush;
+            msgFn(lq.pop().getData());
+        }
+        if (!opts.summary) cout << " done." << endl;
+    }
+
+    void process(size_t n, LocalQueue lq, string queue,
+                 boost::function<void (const string&)> msgFn)
+    {
+        session.messageFlow(queue, 0, n);
+        if (!opts.summary)
+            cout << "Processing " << n << " messages from "
+                 << queue << " " << flush;
+        for (size_t i = 0; i < n; ++i) {
+            if (!opts.summary) cout << "." << flush;
+            msgFn(lq.pop().getData());
+        }
+        if (!opts.summary) cout << " done." << endl;
+    }
+
+    void send(size_t n, string queue, string data) {
+        if (!opts.summary)
+            cout << "Sending " << data << " " << n << " times to " << queue
+                 << endl;
+        Message msg(data, queue);
+        for (size_t i = 0; i < n; ++i)
+            session.messageTransfer(arg::content=msg, arg::acceptMode=1);
+    }
+
+    void run() {                // Controller
+        try {
+            // Wait for subscribers to be ready.
+            process(opts.totalSubs, fqn("sub_ready"), bind(expect, _1, "ready"));
+
+            LocalQueue pubDone;
+            LocalQueue subDone;
+            subs.setFlowControl(0, SubscriptionManager::UNLIMITED, false);
+            subs.subscribe(pubDone, fqn("pub_done"));
+            subs.subscribe(subDone, fqn("sub_done"));
+
+            double txrateTotal(0);
+            double mbytesTotal(0);
+            double pubRateTotal(0);
+            double subRateTotal(0);
+
+            for (size_t j = 0; j < opts.iterations; ++j) {
+                AbsTime start=now();
+                send(opts.totalPubs, fqn("pub_start"), "start"); // Start publishers
+                if (j) {
+		    send(opts.totalPubs, fqn("sub_iteration"), "next"); // Start subscribers on next iteration
+                }
+
+                Stats pubRates;
+                Stats subRates;
+
+                process(opts.totalPubs, pubDone, fqn("pub_done"), boost::ref(pubRates));
+                process(opts.totalSubs, subDone, fqn("sub_done"), boost::ref(subRates));
+
+                AbsTime end=now();
+
+                double time=secs(start, end);
+                double txrate=opts.transfers/time;
+                double mbytes=(txrate*opts.size)/(1024*1024);
+
+                if (!opts.summary) {
+                    cout << endl << "Total " << opts.transfers << " transfers of "
+                         << opts.size << " bytes in "
+                         << time << " seconds." << endl;
+                    cout << endl << "Publish transfers/sec:    " << endl;
+                    pubRates.print(cout);
+                    cout << endl << "Subscribe transfers/sec:  " << endl;
+                    subRates.print(cout);
+                    cout << endl
+                         << "Total transfers/sec:      " << txrate << endl
+                         << "Total Mbytes/sec: " << mbytes << endl;
+                }
+                else {
+                    cout << pubRates.mean() << "\t"
+                         << subRates.mean() << "\t"
+                         << txrate << "\t"
+                         << mbytes << endl;
+                }
+
+                txrateTotal += txrate;
+                mbytesTotal += mbytes;
+                pubRateTotal += pubRates.mean();
+                subRateTotal += subRates.mean();
+            }
+            if (opts.iterations > 1) {
+                cout << "Averages: "<< endl
+                     << (pubRateTotal / opts.iterations) << "\t"
+                     << (subRateTotal / opts.iterations) << "\t"
+                     << (txrateTotal / opts.iterations) << "\t"
+                     << (mbytesTotal / opts.iterations) << endl;
+            }
+        }
+        catch (const std::exception& e) {
+            cout << "Controller exception: " << e.what() << endl;
+        }
+    }
+};
+
+
+struct PublishThread : public Client {
+    string destination;
+    string routingKey;
+
+    PublishThread() {};
+
+    PublishThread(string key, string dest=string()) {
+        destination=dest;
+        routingKey=key;
+    }
+
+    void run() {                // Publisher
+        try {
+            string data;
+            size_t offset(0);
+            if (opts.uniqueData) {
+                offset = 5;
+                data += "data:";//marker (requested for latency testing tool scripts)
+                data += string(sizeof(size_t), 'X');//space for seq no
+                data += session.getId().str();
+                if (opts.size > data.size()) {
+                    data += string(opts.size - data.size(), 'X');
+                } else if(opts.size < data.size()) {
+                    cout << "WARNING: Increased --size to " << data.size()
+                         << " to honour --unique-data" << endl;
+                }
+            } else {
+                size_t msgSize=max(opts.size, sizeof(size_t));
+                data = string(msgSize, 'X');
+            }
+
+            Message msg(data, routingKey);
+            if (opts.durable)
+                msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
+
+
+            if (opts.txPub){
+                session.txSelect();
+            }
+            SubscriptionManager subs(session);
+            LocalQueue lq;
+            subs.setFlowControl(1, SubscriptionManager::UNLIMITED, true);
+            subs.subscribe(lq, fqn("pub_start"));
+
+            for (size_t j = 0; j < opts.iterations; ++j) {
+                expect(lq.pop().getData(), "start");
+                AbsTime start=now();
+                for (size_t i=0; i<opts.count; i++) {
+                    // Stamp the iteration into the message data, avoid
+                    // any heap allocation.
+                    const_cast<std::string&>(msg.getData()).replace(offset, sizeof(size_t),
+                                          reinterpret_cast<const char*>(&i), sizeof(size_t));
+                    if (opts.syncPub) {
+                        sync(session).messageTransfer(
+                            arg::destination=destination,
+                            arg::content=msg,
+                            arg::acceptMode=1);
+                    } else {
+                        session.messageTransfer(
+                            arg::destination=destination,
+                            arg::content=msg,
+                            arg::acceptMode=1);
+                    }
+                    if (opts.txPub && ((i+1) % opts.txPub == 0)){
+                        if (opts.commitAsync){
+                            session.txCommit();
+                        } else {
+                            sync(session).txCommit();
+                        }
+                    }
+                    if (opts.intervalPub)
+                        qpid::sys::usleep(opts.intervalPub*1000);
+                }
+                if (opts.confirm) session.sync();
+                AbsTime end=now();
+                double time=secs(start,end);
+
+                // Send result to controller.
+                Message report(lexical_cast<string>(opts.count/time), fqn("pub_done"));
+                session.messageTransfer(arg::content=report, arg::acceptMode=1);
+                if (opts.txPub){
+                    sync(session).txCommit();
+                }
+            }
+            session.close();
+        }
+        catch (const std::exception& e) {
+            cout << "PublishThread exception: " << e.what() << endl;
+        }
+    }
+};
+
+struct SubscribeThread : public Client {
+
+    string queue;
+
+    SubscribeThread() {}
+
+    SubscribeThread(string q) { queue = q; }
+
+    SubscribeThread(string key, string ex) {
+        queue=session.getId().str(); // Unique name.
+        session.queueDeclare(arg::queue=queue,
+                             arg::exclusive=true,
+                             arg::autoDelete=true,
+                             arg::durable=opts.durable);
+        session.exchangeBind(arg::queue=queue,
+                             arg::exchange=ex,
+                             arg::bindingKey=key);
+    }
+
+    void verify(bool cond, const char* test, uint32_t expect, uint32_t actual) {
+        if (!cond) {
+            Message error(
+                QPID_MSG("Sequence error: expected  n" << test << expect << " but got " << actual),
+                "sub_done");
+            session.messageTransfer(arg::content=error, arg::acceptMode=1);
+            throw Exception(error.getData());
+        }
+    }
+
+    void run() {                // Subscribe
+        try {
+            if (opts.txSub) sync(session).txSelect();
+            SubscriptionManager subs(session);
+            SubscriptionSettings settings;
+            settings.autoAck = opts.txSub ? opts.txSub : opts.ack;
+            settings.acceptMode = (opts.txSub || opts.ack ? ACCEPT_MODE_EXPLICIT : ACCEPT_MODE_NONE);
+            settings.flowControl = FlowControl::messageCredit(opts.subQuota);
+            LocalQueue lq;
+            Subscription subscription = subs.subscribe(lq, queue, settings);
+            // Notify controller we are ready.
+            session.messageTransfer(arg::content=Message("ready", fqn("sub_ready")), arg::acceptMode=1);
+            if (opts.txSub) {
+                if (opts.commitAsync) session.txCommit();
+                else sync(session).txCommit();
+            }
+
+            LocalQueue iterationControl;
+            if (opts.iterations > 1) {
+                subs.subscribe(iterationControl, fqn("sub_iteration"), SubscriptionSettings(FlowControl::messageCredit(0)));
+            }
+
+            for (size_t j = 0; j < opts.iterations; ++j) {
+                if (j > 0) {
+                    //need to wait here until all subs are done
+                    session.messageFlow(fqn("sub_iteration"), 0, 1);
+                    iterationControl.pop();
+
+                    //need to allocate some more credit for subscription
+                    session.messageFlow(queue, 0, opts.subQuota);
+                }
+                Message msg;
+                AbsTime start=now();
+                size_t expect=0;
+                for (size_t i = 0; i < opts.subQuota; ++i) {
+                    msg=lq.pop();
+                    if (opts.txSub && ((i+1) % opts.txSub == 0)) {
+                        if (opts.commitAsync) session.txCommit();
+                        else sync(session).txCommit();
+                    }
+                    if (opts.intervalSub)
+                        qpid::sys::usleep(opts.intervalSub*1000);
+                    // TODO aconway 2007-11-23: check message order for.
+                    // multiple publishers. Need an array of counters,
+                    // one per publisher and a publisher ID in the
+                    // message. Careful not to introduce a lot of overhead
+                    // here, e.g. no std::map, std::string etc.
+                    //
+                    // For now verify order only for a single publisher.
+                    size_t offset = opts.uniqueData ? 5 /*marker is 'data:'*/ : 0;
+                    size_t n = *reinterpret_cast<const size_t*>(msg.getData().data() + offset);
+                    if (opts.pubs == 1) {
+                        if (opts.subs == 1 || opts.mode == FANOUT) verify(n==expect, "==", expect, n);
+                        else verify(n>=expect, ">=", expect, n);
+                        expect = n+1;
+                    }
+                }
+                if (opts.txSub || opts.ack)
+                    subscription.accept(subscription.getUnaccepted());
+                if (opts.txSub) {
+                    if (opts.commitAsync) session.txCommit();
+                    else sync(session).txCommit();
+                }
+                AbsTime end=now();
+
+                // Report to publisher.
+                Message result(lexical_cast<string>(opts.subQuota/secs(start,end)),
+                               fqn("sub_done"));
+                session.messageTransfer(arg::content=result, arg::acceptMode=1);
+                if (opts.txSub) sync(session).txCommit();
+            }
+            session.close();
+        }
+        catch (const std::exception& e) {
+            cout << "SubscribeThread exception: " << e.what() << endl;
+        }
+    }
+};
+
+}} // namespace qpid::tests
+
+using namespace qpid::tests;
+
+int main(int argc, char** argv) {
+    int exitCode = 0;
+    boost::ptr_vector<Client> subs(opts.subs);
+    boost::ptr_vector<Client> pubs(opts.pubs);
+
+    try {
+        opts.parse(argc, argv);
+
+        string exchange;
+        switch (opts.mode) {
+            case FANOUT: exchange="amq.fanout"; break;
+            case TOPIC: exchange="amq.topic"; break;
+            case SHARED: break;
+        }
+
+        bool singleProcess=
+            (!opts.setup && !opts.control && !opts.publish && !opts.subscribe);
+        if (singleProcess)
+            opts.setup = opts.control = opts.publish = opts.subscribe = true;
+
+        if (opts.setup) Setup().run();          // Set up queues
+
+        // Start pubs/subs for each queue/topic.
+        for (size_t i = 0; i < opts.qt; ++i) {
+            ostringstream key;
+            key << opts.baseName << i; // Queue or topic name.
+            if (opts.publish) {
+                size_t n = singleProcess ? opts.pubs : 1;
+                for (size_t j = 0; j < n; ++j)  {
+                    pubs.push_back(new PublishThread(key.str(), exchange));
+                    pubs.back().thread=Thread(pubs.back());
+                }
+            }
+            if (opts.subscribe) {
+                size_t n = singleProcess ? opts.subs : 1;
+                for (size_t j = 0; j < n; ++j)  {
+                    if (opts.mode==SHARED)
+                        subs.push_back(new SubscribeThread(key.str()));
+                    else
+                        subs.push_back(new SubscribeThread(key.str(),exchange));
+                    subs.back().thread=Thread(subs.back());
+                }
+            }
+        }
+
+        if (opts.control) Controller().run();
+    }
+    catch (const std::exception& e) {
+        cout << endl << e.what() << endl;
+        exitCode = 1;
+    }
+
+    // Wait for started threads.
+    if (opts.publish) {
+        for (boost::ptr_vector<Client>::iterator i=pubs.begin();
+             i != pubs.end();
+             ++i)
+            i->thread.join();
+    }
+
+    if (opts.subscribe) {
+        for (boost::ptr_vector<Client>::iterator i=subs.begin();
+             i != subs.end();
+             ++i)
+            i->thread.join();
+    }
+    return exitCode;
+}
diff --git a/qpid/cpp/src/tests/qpid-topic-listener.cpp b/qpid/cpp/src/tests/qpid-topic-listener.cpp
new file mode 100644
index 0000000..c42e76d
--- /dev/null
+++ b/qpid/cpp/src/tests/qpid-topic-listener.cpp
@@ -0,0 +1,209 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+/**
+ * This file provides one half of a test and example of a pub-sub
+ * style of interaction. See qpid-topic-publisher.cpp for the other half,
+ * in which the logic for publishing is defined.
+ *
+ * This file contains the listener logic. A listener will subscribe to
+ * a logical 'topic'. It will count the number of messages it receives
+ * and the time elapsed between the first one and the last one. It
+ * recognises two types of 'special' message that tell it to (a) send
+ * a report containing this information, (b) shutdown (i.e. stop
+ * listening).
+ */
+
+#include "TestOptions.h"
+#include "qpid/client/Connection.h"
+#include "qpid/client/MessageListener.h"
+#include "qpid/client/Session.h"
+#include "qpid/client/AsyncSession.h"
+#include "qpid/client/SubscriptionManager.h"
+#include "qpid/sys/SystemInfo.h"
+#include "qpid/sys/Time.h"
+#include "qpid/framing/FieldValue.h"
+#include <iostream>
+#include <sstream>
+
+using namespace qpid;
+using namespace qpid::client;
+using namespace qpid::sys;
+using namespace qpid::framing;
+using namespace std;
+
+namespace qpid {
+namespace tests {
+
+/**
+ * A message listener implementation in which the runtime logic is
+ * defined.
+ */
+class Listener : public MessageListener{
+    Session session;
+    SubscriptionManager& mgr;
+    const string responseQueue;
+    const bool transactional;
+    bool init;
+    int count;
+    AbsTime start;
+
+    void shutdown();
+    void report();
+public:
+    Listener(const Session& session, SubscriptionManager& mgr, const string& reponseQueue, bool tx);
+    virtual void received(Message& msg);
+    Subscription subscription;
+};
+
+/**
+ * A utility class for managing the options passed in.
+ */
+struct Args : public qpid::TestOptions {
+    int ack;
+    bool transactional;
+    bool durable;
+    int prefetch;
+    string statusqueue;
+
+    Args() : ack(0), transactional(false), durable(false), prefetch(0) {
+        addOptions()
+            ("ack", optValue(ack, "MODE"), "Ack frequency in messages (defaults to half the prefetch value)")
+            ("transactional", optValue(transactional), "Use transactions")
+            ("durable", optValue(durable), "subscribers should use durable queues")
+            ("prefetch", optValue(prefetch, "N"), "prefetch count (0 implies no flow control, and no acking)")
+            ("status-queue", optValue(statusqueue, "QUEUE-NAME"), "Message queue to put status messages on");
+    }
+};
+
+Listener::Listener(const Session& s, SubscriptionManager& m, const string& _responseq, bool tx) :
+    session(s), mgr(m), responseQueue(_responseq), transactional(tx), init(false), count(0){}
+
+void Listener::received(Message& message){
+    if(!init){
+        start = now();
+        count = 0;
+        init = true;
+        cout << "Batch started." << endl;
+    }
+    string type = message.getHeaders().getAsString("TYPE");
+
+    if(string("TERMINATION_REQUEST") == type){
+        shutdown();
+    }else if(string("REPORT_REQUEST") == type){
+        subscription.accept(subscription.getUnaccepted()); // Accept everything upto this point
+        cout <<"Batch ended, sending report." << endl;
+        //send a report:
+        report();
+        init = false;
+    }else if (++count % 1000 == 0){
+        cout <<"Received " << count << " messages." << endl;
+    }
+}
+
+void Listener::shutdown(){
+    mgr.stop();
+}
+
+void Listener::report(){
+    AbsTime finish = now();
+    Duration time(start, finish);
+    stringstream reportstr;
+    reportstr << "Received " << count << " messages in "
+              << time/TIME_MSEC << " ms.";
+    Message msg(reportstr.str(), responseQueue);
+    msg.getHeaders().setString("TYPE", "REPORT");
+    session.messageTransfer(arg::destination="amq.direct", arg::content=msg, arg::acceptMode=1);
+    if(transactional){
+        sync(session).txCommit();
+    }
+}
+
+}} // namespace qpid::tests
+
+using namespace qpid::tests;
+
+/**
+ * The main routine creates a Listener instance and sets it up to
+ * consume from a private queue bound to the exchange with the
+ * appropriate topic name.
+ */
+int main(int argc, char** argv){
+    try{
+        Args args;
+        args.parse(argc, argv);
+        if(args.help)
+            cout << args << endl;
+        else {
+            Connection connection;
+            args.open(connection);
+            AsyncSession session = connection.newSession();
+
+            //declare exchange, queue and bind them:
+            session.queueDeclare(arg::queue="response");
+            std::string control = "control_" + session.getId().str();
+            if (args.durable) {
+                session.queueDeclare(arg::queue=control, arg::durable=true);
+            } else {
+                session.queueDeclare(arg::queue=control, arg::exclusive=true, arg::autoDelete=true);
+            }
+            session.exchangeBind(arg::exchange="amq.topic", arg::queue=control, arg::bindingKey="topic_control");
+
+            //set up listener
+            SubscriptionManager mgr(session);
+            Listener listener(session, mgr, "response", args.transactional);
+            SubscriptionSettings settings;
+            if (args.prefetch) {
+                settings.autoAck = (args.ack ? args.ack : (args.prefetch / 2));
+                settings.flowControl = FlowControl::messageCredit(args.prefetch);
+            } else {
+                settings.acceptMode = ACCEPT_MODE_NONE;
+                settings.flowControl = FlowControl::unlimited();
+            }
+            listener.subscription =  mgr.subscribe(listener, control, settings);
+            session.sync();
+
+            if( args.statusqueue.length() > 0 ) {
+                stringstream msg_str;
+                msg_str << "qpid-topic-listener: " << qpid::sys::SystemInfo::getProcessId();
+                session.messageTransfer(arg::content=Message(msg_str.str(), args.statusqueue));
+                cout << "Ready status put on queue '" << args.statusqueue << "'" << endl;
+            }
+
+            if (args.transactional) {
+                session.txSelect();
+            }
+
+            cout << "qpid-topic-listener: listening..." << endl;
+            mgr.run();
+            if (args.durable) {
+                session.queueDelete(arg::queue=control);
+            }
+            session.close();
+            cout << "closing connection" << endl;
+            connection.close();
+        }
+        return 0;
+    } catch (const std::exception& error) {
+        cout << "qpid-topic-listener: " << error.what() << endl;
+    }
+    return 1;
+}
diff --git a/qpid/cpp/src/tests/qpid-topic-publisher.cpp b/qpid/cpp/src/tests/qpid-topic-publisher.cpp
new file mode 100644
index 0000000..f9107b9
--- /dev/null
+++ b/qpid/cpp/src/tests/qpid-topic-publisher.cpp
@@ -0,0 +1,230 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+/**
+ * This file provides one half of a test and example of a pub-sub
+ * style of interaction. See qpid-topic-listener.cpp for the other half, in
+ * which the logic for subscribers is defined.
+ *
+ * This file contains the publisher logic. The publisher will send a
+ * number of messages to the exchange with the appropriate routing key
+ * for the logical 'topic'. Once it has done this it will then send a
+ * request that each subscriber report back with the number of message
+ * it has received and the time that elapsed between receiving the
+ * first one and receiving the report request. Once the expected
+ * number of reports are received, it sends out a request that each
+ * subscriber shutdown.
+ */
+
+#include "TestOptions.h"
+#include "qpid/client/Connection.h"
+#include "qpid/client/MessageListener.h"
+#include "qpid/client/AsyncSession.h"
+#include "qpid/client/SubscriptionManager.h"
+#include "qpid/sys/Monitor.h"
+#include "qpid/sys/Time.h"
+#include <cstdlib>
+#include <iostream>
+
+using namespace qpid;
+using namespace qpid::client;
+using namespace qpid::sys;
+using namespace std;
+
+namespace qpid {
+namespace tests {
+
+/**
+ * The publishing logic is defined in this class. It implements
+ * message listener and can therfore be used to receive messages sent
+ * back by the subscribers.
+ */
+class Publisher {
+    AsyncSession session;
+    SubscriptionManager mgr;
+    LocalQueue queue;
+    const string controlTopic;
+    const bool transactional;
+    const bool durable;
+
+    string generateData(int size);
+
+public:
+    Publisher(const AsyncSession& session, const string& controlTopic, bool tx, bool durable);
+    int64_t publish(int msgs, int listeners, int size);
+    void terminate();
+};
+
+/**
+ * A utility class for managing the options passed in to the test
+ */
+struct Args : public TestOptions {
+    int messages;
+    int subscribers;
+    bool transactional;
+    bool durable;
+    int batches;
+    int delay;
+    int size;
+    string statusqueue;
+
+    Args() : messages(1000), subscribers(1),
+             transactional(false), durable(false),
+             batches(1), delay(0), size(256)
+    {
+        addOptions()
+            ("messages", optValue(messages, "N"), "how many messages to send")
+            ("subscribers", optValue(subscribers, "N"), "how many subscribers to expect reports from")
+            ("transactional", optValue(transactional), "client should use transactions")
+            ("durable", optValue(durable), "messages should be durable")
+            ("batches", optValue(batches, "N"), "how many batches to run")
+            ("delay", optValue(delay, "SECONDS"), "Causes a delay between each batch")
+            ("size", optValue(size, "BYTES"), "size of the published messages")
+            ("status-queue", optValue(statusqueue, "QUEUE-NAME"), "Message queue to read status messages from");
+    }
+};
+
+Publisher::Publisher(const AsyncSession& _session, const string& _controlTopic, bool tx, bool d) :
+    session(_session), mgr(session), controlTopic(_controlTopic), transactional(tx), durable(d)
+{
+    mgr.subscribe(queue, "response");
+}
+
+int64_t Publisher::publish(int msgs, int listeners, int size){
+    Message msg(generateData(size), controlTopic);
+    if (durable) {
+        msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
+    }
+    AbsTime start = now();
+
+    for(int i = 0; i < msgs; i++){
+        session.messageTransfer(arg::content=msg, arg::destination="amq.topic", arg::acceptMode=1);
+    }
+    //send report request
+    Message reportRequest("", controlTopic);
+    reportRequest.getHeaders().setString("TYPE", "REPORT_REQUEST");
+    session.messageTransfer(arg::content=reportRequest, arg::destination="amq.topic", arg::acceptMode=1);
+    if(transactional){
+        sync(session).txCommit();
+    }
+    //wait for a response from each listener (TODO, could log these)
+    for (int i = 0; i < listeners; i++) {
+        Message report = queue.pop();
+    }
+
+    if(transactional){
+        sync(session).txCommit();
+    }
+
+    AbsTime finish = now();
+    return Duration(start, finish);
+}
+
+string Publisher::generateData(int size){
+    string data;
+    for(int i = 0; i < size; i++){
+        data += ('A' + (i / 26));
+    }
+    return data;
+}
+
+void Publisher::terminate(){
+    //send termination request
+    Message terminationRequest("", controlTopic);
+    terminationRequest.getHeaders().setString("TYPE", "TERMINATION_REQUEST");
+    session.messageTransfer(arg::content=terminationRequest, arg::destination="amq.topic", arg::acceptMode=1);
+    if(transactional){
+        session.txCommit();
+    }
+}
+
+}} // namespace qpid::tests
+
+using namespace qpid::tests;
+
+int main(int argc, char** argv) {
+    try{
+        Args args;
+        args.parse(argc, argv);
+        if(args.help)
+            cout << args << endl;
+        else {
+            Connection connection;
+            args.open(connection);
+            AsyncSession session = connection.newSession();
+
+            // If status-queue is defined, wait for all expected listeners to join in before we start
+            if( args.statusqueue.length() > 0 ) {
+                cout << "Waiting for " << args.subscribers << " listeners..." << endl;
+                SubscriptionManager statusSubs(session);
+                LocalQueue statusQ;
+                statusSubs.subscribe(statusQ, args.statusqueue);
+                for (int i = 0; i < args.subscribers; i++) {
+                    Message m = statusQ.get();
+                    if( m.getData().find("topic_listener: ", 0) == 0 ) {
+                        cout << "Listener " << (i+1) << " of " << args.subscribers
+                            << " is ready (pid " << m.getData().substr(16, m.getData().length() - 16)
+                            << ")" << endl;
+                    } else {
+                        throw Exception(QPID_MSG("Unexpected message received on status queue: " << m.getData()));
+                    }
+                }
+            }
+
+            if (args.transactional) {
+                session.txSelect();
+            }
+            session.queueDeclare(arg::queue="response");
+            session.exchangeBind(arg::exchange="amq.direct", arg::queue="response", arg::bindingKey="response");
+
+            Publisher publisher(session, "topic_control", args.transactional, args.durable);
+
+            int batchSize(args.batches);
+            int64_t max(0);
+            int64_t min(0);
+            int64_t sum(0);
+            for(int i = 0; i < batchSize; i++){
+                if(i > 0 && args.delay) qpid::sys::sleep(args.delay);
+                int64_t msecs =
+                    publisher.publish(args.messages,
+                                      args.subscribers,
+                                      args.size) / TIME_MSEC;
+                if(!max || msecs > max) max = msecs;
+                if(!min || msecs < min) min = msecs;
+                sum += msecs;
+                cout << "Completed " << (i+1) << " of " << batchSize
+                    << " in " << msecs << "ms" << endl;
+            }
+            publisher.terminate();
+            int64_t avg = sum / batchSize;
+            if(batchSize > 1){
+                cout << batchSize << " batches completed. avg=" << avg <<
+                    ", max=" << max << ", min=" << min << endl;
+            }
+            session.close();
+            connection.close();
+        }
+        return 0;
+    }catch(exception& error) {
+        cout << error.what() << endl;
+    }
+    return 1;
+}
diff --git a/qpid/cpp/src/tests/qpid-txtest.cpp b/qpid/cpp/src/tests/qpid-txtest.cpp
new file mode 100644
index 0000000..d0ba2f1
--- /dev/null
+++ b/qpid/cpp/src/tests/qpid-txtest.cpp
@@ -0,0 +1,340 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+#include <algorithm>
+#include <iomanip>
+#include <iostream>
+#include <memory>
+#include <sstream>
+#include <vector>
+
+#include "TestOptions.h"
+#include "qpid/client/Connection.h"
+#include "qpid/client/Message.h"
+#include "qpid/client/AsyncSession.h"
+#include "qpid/client/SubscriptionManager.h"
+#include "qpid/framing/Array.h"
+#include "qpid/framing/Buffer.h"
+#include "qpid/framing/Uuid.h"
+#include "qpid/sys/Thread.h"
+
+using namespace qpid;
+using namespace qpid::client;
+using namespace qpid::sys;
+using std::string;
+
+namespace qpid {
+namespace tests {
+
+typedef std::vector<std::string> StringSet;
+
+struct Args : public qpid::TestOptions {
+    bool init, transfer, check;//actions
+    uint size;
+    bool durable;
+    uint queues;
+    string base;
+    uint msgsPerTx;
+    uint txCount;
+    uint totalMsgCount;
+    bool dtx;
+    bool quiet;
+
+    Args() : init(true), transfer(true), check(true),
+             size(256), durable(true), queues(2),
+             base("tx-test"), msgsPerTx(1), txCount(1), totalMsgCount(10),
+             dtx(false), quiet(false)
+    {
+        addOptions()
+
+            ("init", optValue(init, "yes|no"), "Declare queues and populate one with the initial set of messages.")
+            ("transfer", optValue(transfer, "yes|no"), "'Move' messages from one queue to another using transactions to ensure no message loss.")
+            ("check", optValue(check, "yes|no"), "Check that the initial messages are all still available.")
+            ("size", optValue(size, "N"), "message size")
+            ("durable", optValue(durable, "yes|no"), "use durable messages")
+            ("queues", optValue(queues, "N"), "number of queues")
+            ("queue-base-name", optValue(base, "<name>"), "base name for queues")
+            ("messages-per-tx", optValue(msgsPerTx, "N"), "number of messages transferred per transaction")
+            ("tx-count", optValue(txCount, "N"), "number of transactions per 'agent'")
+            ("total-messages", optValue(totalMsgCount, "N"), "total number of messages in 'circulation'")
+            ("dtx", optValue(dtx, "yes|no"), "use distributed transactions")
+            ("quiet", optValue(quiet), "reduce output from test");
+    }
+};
+
+const std::string chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
+
+std::string generateData(uint size)
+{
+    if (size < chars.length()) {
+        return chars.substr(0, size);
+    }
+    std::string data;
+    for (uint i = 0; i < (size / chars.length()); i++) {
+        data += chars;
+    }
+    data += chars.substr(0, size % chars.length());
+    return data;
+}
+
+void generateSet(const std::string& base, uint count, StringSet& collection)
+{
+    for (uint i = 0; i < count; i++) {
+        std::ostringstream out;
+        out << base << "-" << (i+1);
+        collection.push_back(out.str());
+    }
+}
+
+Args opts;
+
+struct Client
+{
+    Connection connection;
+    AsyncSession session;
+
+    Client()
+    {
+        opts.open(connection);
+        session = connection.newSession();
+    }
+
+    ~Client()
+    {
+        try{
+            session.close();
+            connection.close();
+        } catch(const std::exception& e) {
+            std::cout << e.what() << std::endl;
+        }
+    }
+};
+
+struct Transfer : public Client, public Runnable
+{
+    std::string src;
+    std::string dest;
+    Thread thread;
+    framing::Xid xid;
+
+    Transfer(const std::string& to, const std::string& from) : src(to), dest(from), xid(0x4c414e47, "", from) {}
+
+    void run()
+    {
+        try {
+
+            if (opts.dtx) session.dtxSelect();
+            else session.txSelect();
+            SubscriptionManager subs(session);
+
+            LocalQueue lq;
+            SubscriptionSettings settings(FlowControl::messageWindow(opts.msgsPerTx));
+            settings.autoAck = 0; // Disabled
+            Subscription sub = subs.subscribe(lq, src, settings);
+
+            for (uint t = 0; t < opts.txCount; t++) {
+                Message in;
+                Message out("", dest);
+                if (opts.dtx) {
+                    setNewXid(xid);
+                    session.dtxStart(arg::xid=xid);
+                }
+                for (uint m = 0; m < opts.msgsPerTx; m++) {
+                    in = lq.pop();
+                    std::string& data = in.getData();
+                    if (data.size() != opts.size) {
+                        std::ostringstream oss;
+                        oss << "Message size incorrect: size=" << in.getData().size() << "; expected " << opts.size;
+                        throw std::runtime_error(oss.str());
+                    }
+                    out.setData(data);
+                    out.getMessageProperties().setCorrelationId(in.getMessageProperties().getCorrelationId());
+                    out.getDeliveryProperties().setDeliveryMode(in.getDeliveryProperties().getDeliveryMode());
+                    session.messageTransfer(arg::content=out, arg::acceptMode=1);
+                }
+                sub.accept(sub.getUnaccepted());
+                if (opts.dtx) {
+                    session.dtxEnd(arg::xid=xid);
+                    session.dtxPrepare(arg::xid=xid);
+                    session.dtxCommit(arg::xid=xid);
+                } else {
+                    session.txCommit();
+                }
+            }
+        } catch(const std::exception& e) {
+            std::cout << "Transfer interrupted: " << e.what() << std::endl;
+        }
+    }
+
+    void setNewXid(framing::Xid& xid) {
+        framing::Uuid uuid(true);
+        xid.setGlobalId(uuid.str());
+    }
+};
+
+struct Controller : public Client
+{
+    StringSet ids;
+    StringSet queues;
+
+    Controller()
+    {
+        generateSet(opts.base, opts.queues, queues);
+        generateSet("msg", opts.totalMsgCount, ids);
+    }
+
+    void init()
+    {
+        //declare queues
+        for (StringSet::iterator i = queues.begin(); i != queues.end(); i++) {
+            session.queueDeclare(arg::queue=*i, arg::durable=opts.durable);
+            session.sync();
+        }
+
+        Message msg(generateData(opts.size), *queues.begin());
+        if (opts.durable) {
+            msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
+        }
+
+        //publish messages
+        for (StringSet::iterator i = ids.begin(); i != ids.end(); i++) {
+            msg.getMessageProperties().setCorrelationId(*i);
+            session.messageTransfer(arg::content=msg, arg::acceptMode=1);
+        }
+    }
+
+    void transfer()
+    {
+        boost::ptr_vector<Transfer> agents(opts.queues);
+        //launch transfer agents
+        for (StringSet::iterator i = queues.begin(); i != queues.end(); i++) {
+            StringSet::iterator next = i + 1;
+            if (next == queues.end()) next = queues.begin();
+
+            if (!opts.quiet) std::cout << "Transfering from " << *i << " to " << *next << std::endl;
+            agents.push_back(new Transfer(*i, *next));
+            agents.back().thread = Thread(agents.back());
+        }
+
+        for (boost::ptr_vector<Transfer>::iterator i = agents.begin(); i != agents.end(); i++) {
+            i->thread.join();
+        }
+    }
+
+    int check()
+    {
+        SubscriptionManager subs(session);
+
+        // Recover DTX transactions (if any)
+        if (opts.dtx) {
+            std::vector<std::string> inDoubtXids;
+            framing::DtxRecoverResult dtxRes = session.dtxRecover().get();
+            const framing::Array& xidArr = dtxRes.getInDoubt();
+            xidArr.collect(inDoubtXids);
+
+            if (inDoubtXids.size()) {
+                if (!opts.quiet) std::cout << "Recovering DTX in-doubt transaction(s):" << std::endl;
+                framing::StructHelper decoder;
+                framing::Xid xid;
+                // abort even, commit odd transactions
+                for (unsigned i = 0; i < inDoubtXids.size(); i++) {
+                    decoder.decode(xid, inDoubtXids[i]);
+                    if (!opts.quiet) std::cout << (i%2 ? " * aborting " : " * committing ");
+                    xid.print(std::cout);
+                    std::cout << std::endl;
+                    if (i%2) {
+                        session.dtxRollback(arg::xid=xid);
+                    } else {
+                        session.dtxCommit(arg::xid=xid);
+                    }
+                }
+            }
+        }
+
+        StringSet drained;
+        //drain each queue and verify the correct set of messages are available
+        for (StringSet::iterator i = queues.begin(); i != queues.end(); i++) {
+            //subscribe, allocate credit and flushn
+            LocalQueue lq;
+            SubscriptionSettings settings(FlowControl::unlimited(), ACCEPT_MODE_NONE);
+            subs.subscribe(lq, *i, settings);
+            session.messageFlush(arg::destination=*i);
+            session.sync();
+
+            uint count(0);
+            while (!lq.empty()) {
+                Message m = lq.pop();
+                //add correlation ids of received messages to drained
+                drained.push_back(m.getMessageProperties().getCorrelationId());
+                ++count;
+            }
+            if (!opts.quiet) std::cout << "Drained " << count << " messages from " << *i << std::endl;
+        }
+
+        sort(ids.begin(), ids.end());
+        sort(drained.begin(), drained.end());
+
+        //check that drained == ids
+        StringSet missing;
+        set_difference(ids.begin(), ids.end(), drained.begin(), drained.end(), back_inserter(missing));
+
+        StringSet extra;
+        set_difference(drained.begin(), drained.end(), ids.begin(), ids.end(), back_inserter(extra));
+
+        if (missing.empty() && extra.empty()) {
+            std::cout << "All expected messages were retrieved." << std::endl;
+            return 0;
+        } else {
+            if (!missing.empty()) {
+                std::cout << "The following ids were missing:" << std::endl;
+                for (StringSet::iterator i = missing.begin(); i != missing.end(); i++) {
+                    std::cout << "    '" << *i << "'" << std::endl;
+                }
+            }
+            if (!extra.empty()) {
+                std::cout << "The following extra ids were encountered:" << std::endl;
+                for (StringSet::iterator i = extra.begin(); i != extra.end(); i++) {
+                    std::cout << "    '" << *i << "'" << std::endl;
+                }
+            }
+            return 1;
+        }
+    }
+};
+
+}} // namespace qpid::tests
+
+using namespace qpid::tests;
+
+int main(int argc, char** argv)
+{
+    try {
+        opts.parse(argc, argv);
+        Controller controller;
+        if (opts.init) controller.init();
+        if (opts.transfer) controller.transfer();
+        if (opts.check) return controller.check();
+        return 0;
+    } catch(const std::exception& e) {
+	std::cout << e.what() << std::endl;
+    }
+    return 2;
+}
diff --git a/qpid/cpp/src/tests/quick_perftest b/qpid/cpp/src/tests/quick_perftest
index 4f7cf3c..362f9ee 100755
--- a/qpid/cpp/src/tests/quick_perftest
+++ b/qpid/cpp/src/tests/quick_perftest
@@ -19,4 +19,4 @@
 # under the License.
 #
 
-exec `dirname $0`/run_test ./perftest --summary --count 100
+exec `dirname $0`/run_test ./qpid-perftest --summary --count 100
diff --git a/qpid/cpp/src/tests/quick_txtest b/qpid/cpp/src/tests/quick_txtest
index 938e380..c872fce 100755
--- a/qpid/cpp/src/tests/quick_txtest
+++ b/qpid/cpp/src/tests/quick_txtest
@@ -19,4 +19,4 @@
 # under the License.
 #
 
-exec `dirname $0`/run_test ./txtest --queues 4 --tx-count 10 --quiet
+exec `dirname $0`/run_test ./qpid-txtest --queues 4 --tx-count 10 --quiet
diff --git a/qpid/cpp/src/tests/run_perftest b/qpid/cpp/src/tests/run_perftest
index 1a9b934..5ad7c1f 100755
--- a/qpid/cpp/src/tests/run_perftest
+++ b/qpid/cpp/src/tests/run_perftest
@@ -19,10 +19,10 @@
 # under the License.
 #
 
-# Args: count [perftest options...]
-# Run a perftest with count multiplied.
+# Args: count [qpid-perftest options...]
+# Run a qpid-perftest with count multiplied.
 # 
 MULTIPLIER=3
 COUNT=`expr $1 \* $MULTIPLIER`
 shift
-exec `dirname $0`/run_test ./perftest --summary --count $COUNT "$@"
+exec `dirname $0`/run_test ./qpid-perftest --summary --count $COUNT "$@"
diff --git a/qpid/cpp/src/tests/ssl_test b/qpid/cpp/src/tests/ssl_test
index 4863eb9..a03341e 100755
--- a/qpid/cpp/src/tests/ssl_test
+++ b/qpid/cpp/src/tests/ssl_test
@@ -73,7 +73,7 @@ export QPID_SSL_CERT_DB=${CERT_DIR}
 export QPID_SSL_CERT_PASSWORD_FILE=${CERT_PW_FILE}
 
 ## Test connection via connection settings
-./perftest --count ${COUNT} --port ${PORT} -P ssl -b $TEST_HOSTNAME --summary
+./qpid-perftest --count ${COUNT} --port ${PORT} -P ssl -b $TEST_HOSTNAME --summary
 
 ## Test connection with a URL
 URL=amqp:ssl:$TEST_HOSTNAME:$PORT 
diff --git a/qpid/cpp/src/tests/topic_listener.cpp b/qpid/cpp/src/tests/topic_listener.cpp
deleted file mode 100644
index aa8c19d..0000000
--- a/qpid/cpp/src/tests/topic_listener.cpp
+++ /dev/null
@@ -1,209 +0,0 @@
-/*
- *
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- *
- */
-
-/**
- * This file provides one half of a test and example of a pub-sub
- * style of interaction. See topic_publisher.cpp for the other half,
- * in which the logic for publishing is defined.
- *
- * This file contains the listener logic. A listener will subscribe to
- * a logical 'topic'. It will count the number of messages it receives
- * and the time elapsed between the first one and the last one. It
- * recognises two types of 'special' message that tell it to (a) send
- * a report containing this information, (b) shutdown (i.e. stop
- * listening).
- */
-
-#include "TestOptions.h"
-#include "qpid/client/Connection.h"
-#include "qpid/client/MessageListener.h"
-#include "qpid/client/Session.h"
-#include "qpid/client/AsyncSession.h"
-#include "qpid/client/SubscriptionManager.h"
-#include "qpid/sys/SystemInfo.h"
-#include "qpid/sys/Time.h"
-#include "qpid/framing/FieldValue.h"
-#include <iostream>
-#include <sstream>
-
-using namespace qpid;
-using namespace qpid::client;
-using namespace qpid::sys;
-using namespace qpid::framing;
-using namespace std;
-
-namespace qpid {
-namespace tests {
-
-/**
- * A message listener implementation in which the runtime logic is
- * defined.
- */
-class Listener : public MessageListener{
-    Session session;
-    SubscriptionManager& mgr;
-    const string responseQueue;
-    const bool transactional;
-    bool init;
-    int count;
-    AbsTime start;
-
-    void shutdown();
-    void report();
-public:
-    Listener(const Session& session, SubscriptionManager& mgr, const string& reponseQueue, bool tx);
-    virtual void received(Message& msg);
-    Subscription subscription;
-};
-
-/**
- * A utility class for managing the options passed in.
- */
-struct Args : public qpid::TestOptions {
-    int ack;
-    bool transactional;
-    bool durable;
-    int prefetch;
-    string statusqueue;
-
-    Args() : ack(0), transactional(false), durable(false), prefetch(0) {
-        addOptions()
-            ("ack", optValue(ack, "MODE"), "Ack frequency in messages (defaults to half the prefetch value)")
-            ("transactional", optValue(transactional), "Use transactions")
-            ("durable", optValue(durable), "subscribers should use durable queues")
-            ("prefetch", optValue(prefetch, "N"), "prefetch count (0 implies no flow control, and no acking)")
-            ("status-queue", optValue(statusqueue, "QUEUE-NAME"), "Message queue to put status messages on");
-    }
-};
-
-Listener::Listener(const Session& s, SubscriptionManager& m, const string& _responseq, bool tx) :
-    session(s), mgr(m), responseQueue(_responseq), transactional(tx), init(false), count(0){}
-
-void Listener::received(Message& message){
-    if(!init){
-        start = now();
-        count = 0;
-        init = true;
-        cout << "Batch started." << endl;
-    }
-    string type = message.getHeaders().getAsString("TYPE");
-
-    if(string("TERMINATION_REQUEST") == type){
-        shutdown();
-    }else if(string("REPORT_REQUEST") == type){
-        subscription.accept(subscription.getUnaccepted()); // Accept everything upto this point
-        cout <<"Batch ended, sending report." << endl;
-        //send a report:
-        report();
-        init = false;
-    }else if (++count % 1000 == 0){
-        cout <<"Received " << count << " messages." << endl;
-    }
-}
-
-void Listener::shutdown(){
-    mgr.stop();
-}
-
-void Listener::report(){
-    AbsTime finish = now();
-    Duration time(start, finish);
-    stringstream reportstr;
-    reportstr << "Received " << count << " messages in "
-              << time/TIME_MSEC << " ms.";
-    Message msg(reportstr.str(), responseQueue);
-    msg.getHeaders().setString("TYPE", "REPORT");
-    session.messageTransfer(arg::destination="amq.direct", arg::content=msg, arg::acceptMode=1);
-    if(transactional){
-        sync(session).txCommit();
-    }
-}
-
-}} // namespace qpid::tests
-
-using namespace qpid::tests;
-
-/**
- * The main routine creates a Listener instance and sets it up to
- * consume from a private queue bound to the exchange with the
- * appropriate topic name.
- */
-int main(int argc, char** argv){
-    try{
-        Args args;
-        args.parse(argc, argv);
-        if(args.help)
-            cout << args << endl;
-        else {
-            Connection connection;
-            args.open(connection);
-            AsyncSession session = connection.newSession();
-
-            //declare exchange, queue and bind them:
-            session.queueDeclare(arg::queue="response");
-            std::string control = "control_" + session.getId().str();
-            if (args.durable) {
-                session.queueDeclare(arg::queue=control, arg::durable=true);
-            } else {
-                session.queueDeclare(arg::queue=control, arg::exclusive=true, arg::autoDelete=true);
-            }
-            session.exchangeBind(arg::exchange="amq.topic", arg::queue=control, arg::bindingKey="topic_control");
-
-            //set up listener
-            SubscriptionManager mgr(session);
-            Listener listener(session, mgr, "response", args.transactional);
-            SubscriptionSettings settings;
-            if (args.prefetch) {
-                settings.autoAck = (args.ack ? args.ack : (args.prefetch / 2));
-                settings.flowControl = FlowControl::messageCredit(args.prefetch);
-            } else {
-                settings.acceptMode = ACCEPT_MODE_NONE;
-                settings.flowControl = FlowControl::unlimited();
-            }
-            listener.subscription =  mgr.subscribe(listener, control, settings);
-            session.sync();
-
-            if( args.statusqueue.length() > 0 ) {
-                stringstream msg_str;
-                msg_str << "topic_listener: " << qpid::sys::SystemInfo::getProcessId();
-                session.messageTransfer(arg::content=Message(msg_str.str(), args.statusqueue));
-                cout << "Ready status put on queue '" << args.statusqueue << "'" << endl;
-            }
-
-            if (args.transactional) {
-                session.txSelect();
-            }
-
-            cout << "topic_listener: listening..." << endl;
-            mgr.run();
-            if (args.durable) {
-                session.queueDelete(arg::queue=control);
-            }
-            session.close();
-            cout << "closing connection" << endl;
-            connection.close();
-        }
-        return 0;
-    } catch (const std::exception& error) {
-        cout << "topic_listener: " << error.what() << endl;
-    }
-    return 1;
-}
diff --git a/qpid/cpp/src/tests/topic_publisher.cpp b/qpid/cpp/src/tests/topic_publisher.cpp
deleted file mode 100644
index 3381132..0000000
--- a/qpid/cpp/src/tests/topic_publisher.cpp
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
- *
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- *
- */
-
-/**
- * This file provides one half of a test and example of a pub-sub
- * style of interaction. See topic_listener.cpp for the other half, in
- * which the logic for subscribers is defined.
- *
- * This file contains the publisher logic. The publisher will send a
- * number of messages to the exchange with the appropriate routing key
- * for the logical 'topic'. Once it has done this it will then send a
- * request that each subscriber report back with the number of message
- * it has received and the time that elapsed between receiving the
- * first one and receiving the report request. Once the expected
- * number of reports are received, it sends out a request that each
- * subscriber shutdown.
- */
-
-#include "TestOptions.h"
-#include "qpid/client/Connection.h"
-#include "qpid/client/MessageListener.h"
-#include "qpid/client/AsyncSession.h"
-#include "qpid/client/SubscriptionManager.h"
-#include "qpid/sys/Monitor.h"
-#include "qpid/sys/Time.h"
-#include <cstdlib>
-#include <iostream>
-
-using namespace qpid;
-using namespace qpid::client;
-using namespace qpid::sys;
-using namespace std;
-
-namespace qpid {
-namespace tests {
-
-/**
- * The publishing logic is defined in this class. It implements
- * message listener and can therfore be used to receive messages sent
- * back by the subscribers.
- */
-class Publisher {
-    AsyncSession session;
-    SubscriptionManager mgr;
-    LocalQueue queue;
-    const string controlTopic;
-    const bool transactional;
-    const bool durable;
-
-    string generateData(int size);
-
-public:
-    Publisher(const AsyncSession& session, const string& controlTopic, bool tx, bool durable);
-    int64_t publish(int msgs, int listeners, int size);
-    void terminate();
-};
-
-/**
- * A utility class for managing the options passed in to the test
- */
-struct Args : public TestOptions {
-    int messages;
-    int subscribers;
-    bool transactional;
-    bool durable;
-    int batches;
-    int delay;
-    int size;
-    string statusqueue;
-
-    Args() : messages(1000), subscribers(1),
-             transactional(false), durable(false),
-             batches(1), delay(0), size(256)
-    {
-        addOptions()
-            ("messages", optValue(messages, "N"), "how many messages to send")
-            ("subscribers", optValue(subscribers, "N"), "how many subscribers to expect reports from")
-            ("transactional", optValue(transactional), "client should use transactions")
-            ("durable", optValue(durable), "messages should be durable")
-            ("batches", optValue(batches, "N"), "how many batches to run")
-            ("delay", optValue(delay, "SECONDS"), "Causes a delay between each batch")
-            ("size", optValue(size, "BYTES"), "size of the published messages")
-            ("status-queue", optValue(statusqueue, "QUEUE-NAME"), "Message queue to read status messages from");
-    }
-};
-
-Publisher::Publisher(const AsyncSession& _session, const string& _controlTopic, bool tx, bool d) :
-    session(_session), mgr(session), controlTopic(_controlTopic), transactional(tx), durable(d)
-{
-    mgr.subscribe(queue, "response");
-}
-
-int64_t Publisher::publish(int msgs, int listeners, int size){
-    Message msg(generateData(size), controlTopic);
-    if (durable) {
-        msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
-    }
-    AbsTime start = now();
-
-    for(int i = 0; i < msgs; i++){
-        session.messageTransfer(arg::content=msg, arg::destination="amq.topic", arg::acceptMode=1);
-    }
-    //send report request
-    Message reportRequest("", controlTopic);
-    reportRequest.getHeaders().setString("TYPE", "REPORT_REQUEST");
-    session.messageTransfer(arg::content=reportRequest, arg::destination="amq.topic", arg::acceptMode=1);
-    if(transactional){
-        sync(session).txCommit();
-    }
-    //wait for a response from each listener (TODO, could log these)
-    for (int i = 0; i < listeners; i++) {
-        Message report = queue.pop();
-    }
-
-    if(transactional){
-        sync(session).txCommit();
-    }
-
-    AbsTime finish = now();
-    return Duration(start, finish);
-}
-
-string Publisher::generateData(int size){
-    string data;
-    for(int i = 0; i < size; i++){
-        data += ('A' + (i / 26));
-    }
-    return data;
-}
-
-void Publisher::terminate(){
-    //send termination request
-    Message terminationRequest("", controlTopic);
-    terminationRequest.getHeaders().setString("TYPE", "TERMINATION_REQUEST");
-    session.messageTransfer(arg::content=terminationRequest, arg::destination="amq.topic", arg::acceptMode=1);
-    if(transactional){
-        session.txCommit();
-    }
-}
-
-}} // namespace qpid::tests
-
-using namespace qpid::tests;
-
-int main(int argc, char** argv) {
-    try{
-        Args args;
-        args.parse(argc, argv);
-        if(args.help)
-            cout << args << endl;
-        else {
-            Connection connection;
-            args.open(connection);
-            AsyncSession session = connection.newSession();
-
-            // If status-queue is defined, wait for all expected listeners to join in before we start
-            if( args.statusqueue.length() > 0 ) {
-                cout << "Waiting for " << args.subscribers << " listeners..." << endl;
-                SubscriptionManager statusSubs(session);
-                LocalQueue statusQ;
-                statusSubs.subscribe(statusQ, args.statusqueue);
-                for (int i = 0; i < args.subscribers; i++) {
-                    Message m = statusQ.get();
-                    if( m.getData().find("topic_listener: ", 0) == 0 ) {
-                        cout << "Listener " << (i+1) << " of " << args.subscribers
-                            << " is ready (pid " << m.getData().substr(16, m.getData().length() - 16)
-                            << ")" << endl;
-                    } else {
-                        throw Exception(QPID_MSG("Unexpected message received on status queue: " << m.getData()));
-                    }
-                }
-            }
-
-            if (args.transactional) {
-                session.txSelect();
-            }
-            session.queueDeclare(arg::queue="response");
-            session.exchangeBind(arg::exchange="amq.direct", arg::queue="response", arg::bindingKey="response");
-
-            Publisher publisher(session, "topic_control", args.transactional, args.durable);
-
-            int batchSize(args.batches);
-            int64_t max(0);
-            int64_t min(0);
-            int64_t sum(0);
-            for(int i = 0; i < batchSize; i++){
-                if(i > 0 && args.delay) qpid::sys::sleep(args.delay);
-                int64_t msecs =
-                    publisher.publish(args.messages,
-                                      args.subscribers,
-                                      args.size) / TIME_MSEC;
-                if(!max || msecs > max) max = msecs;
-                if(!min || msecs < min) min = msecs;
-                sum += msecs;
-                cout << "Completed " << (i+1) << " of " << batchSize
-                    << " in " << msecs << "ms" << endl;
-            }
-            publisher.terminate();
-            int64_t avg = sum / batchSize;
-            if(batchSize > 1){
-                cout << batchSize << " batches completed. avg=" << avg <<
-                    ", max=" << max << ", min=" << min << endl;
-            }
-            session.close();
-            connection.close();
-        }
-        return 0;
-    }catch(exception& error) {
-        cout << error.what() << endl;
-    }
-    return 1;
-}
diff --git a/qpid/cpp/src/tests/topictest b/qpid/cpp/src/tests/topictest
index 8fd680e..257c24b 100755
--- a/qpid/cpp/src/tests/topictest
+++ b/qpid/cpp/src/tests/topictest
@@ -46,11 +46,11 @@ done
 subscribe() {
     echo Start subscriber $1
     LOG="subscriber_$1.log"
-    ./topic_listener $TRANSACTIONAL > $LOG 2>&1 && rm -f $LOG 
+    ./qpid-topic-listener $TRANSACTIONAL > $LOG 2>&1 && rm -f $LOG 
 }
 
 publish() {
-    ./topic_publisher --messages $MESSAGES --batches $BATCHES --subscribers $SUBSCRIBERS $HOST $TRANSACTIONAL
+    ./qpid-topic-publisher --messages $MESSAGES --batches $BATCHES --subscribers $SUBSCRIBERS $HOST $TRANSACTIONAL
 }
 
 for ((i=$SUBSCRIBERS ; i--; )); do
diff --git a/qpid/cpp/src/tests/txtest.cpp b/qpid/cpp/src/tests/txtest.cpp
deleted file mode 100644
index d0ba2f1..0000000
--- a/qpid/cpp/src/tests/txtest.cpp
+++ /dev/null
@@ -1,340 +0,0 @@
-/*
- *
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- *
- */
-
-#include <algorithm>
-#include <iomanip>
-#include <iostream>
-#include <memory>
-#include <sstream>
-#include <vector>
-
-#include "TestOptions.h"
-#include "qpid/client/Connection.h"
-#include "qpid/client/Message.h"
-#include "qpid/client/AsyncSession.h"
-#include "qpid/client/SubscriptionManager.h"
-#include "qpid/framing/Array.h"
-#include "qpid/framing/Buffer.h"
-#include "qpid/framing/Uuid.h"
-#include "qpid/sys/Thread.h"
-
-using namespace qpid;
-using namespace qpid::client;
-using namespace qpid::sys;
-using std::string;
-
-namespace qpid {
-namespace tests {
-
-typedef std::vector<std::string> StringSet;
-
-struct Args : public qpid::TestOptions {
-    bool init, transfer, check;//actions
-    uint size;
-    bool durable;
-    uint queues;
-    string base;
-    uint msgsPerTx;
-    uint txCount;
-    uint totalMsgCount;
-    bool dtx;
-    bool quiet;
-
-    Args() : init(true), transfer(true), check(true),
-             size(256), durable(true), queues(2),
-             base("tx-test"), msgsPerTx(1), txCount(1), totalMsgCount(10),
-             dtx(false), quiet(false)
-    {
-        addOptions()
-
-            ("init", optValue(init, "yes|no"), "Declare queues and populate one with the initial set of messages.")
-            ("transfer", optValue(transfer, "yes|no"), "'Move' messages from one queue to another using transactions to ensure no message loss.")
-            ("check", optValue(check, "yes|no"), "Check that the initial messages are all still available.")
-            ("size", optValue(size, "N"), "message size")
-            ("durable", optValue(durable, "yes|no"), "use durable messages")
-            ("queues", optValue(queues, "N"), "number of queues")
-            ("queue-base-name", optValue(base, "<name>"), "base name for queues")
-            ("messages-per-tx", optValue(msgsPerTx, "N"), "number of messages transferred per transaction")
-            ("tx-count", optValue(txCount, "N"), "number of transactions per 'agent'")
-            ("total-messages", optValue(totalMsgCount, "N"), "total number of messages in 'circulation'")
-            ("dtx", optValue(dtx, "yes|no"), "use distributed transactions")
-            ("quiet", optValue(quiet), "reduce output from test");
-    }
-};
-
-const std::string chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
-
-std::string generateData(uint size)
-{
-    if (size < chars.length()) {
-        return chars.substr(0, size);
-    }
-    std::string data;
-    for (uint i = 0; i < (size / chars.length()); i++) {
-        data += chars;
-    }
-    data += chars.substr(0, size % chars.length());
-    return data;
-}
-
-void generateSet(const std::string& base, uint count, StringSet& collection)
-{
-    for (uint i = 0; i < count; i++) {
-        std::ostringstream out;
-        out << base << "-" << (i+1);
-        collection.push_back(out.str());
-    }
-}
-
-Args opts;
-
-struct Client
-{
-    Connection connection;
-    AsyncSession session;
-
-    Client()
-    {
-        opts.open(connection);
-        session = connection.newSession();
-    }
-
-    ~Client()
-    {
-        try{
-            session.close();
-            connection.close();
-        } catch(const std::exception& e) {
-            std::cout << e.what() << std::endl;
-        }
-    }
-};
-
-struct Transfer : public Client, public Runnable
-{
-    std::string src;
-    std::string dest;
-    Thread thread;
-    framing::Xid xid;
-
-    Transfer(const std::string& to, const std::string& from) : src(to), dest(from), xid(0x4c414e47, "", from) {}
-
-    void run()
-    {
-        try {
-
-            if (opts.dtx) session.dtxSelect();
-            else session.txSelect();
-            SubscriptionManager subs(session);
-
-            LocalQueue lq;
-            SubscriptionSettings settings(FlowControl::messageWindow(opts.msgsPerTx));
-            settings.autoAck = 0; // Disabled
-            Subscription sub = subs.subscribe(lq, src, settings);
-
-            for (uint t = 0; t < opts.txCount; t++) {
-                Message in;
-                Message out("", dest);
-                if (opts.dtx) {
-                    setNewXid(xid);
-                    session.dtxStart(arg::xid=xid);
-                }
-                for (uint m = 0; m < opts.msgsPerTx; m++) {
-                    in = lq.pop();
-                    std::string& data = in.getData();
-                    if (data.size() != opts.size) {
-                        std::ostringstream oss;
-                        oss << "Message size incorrect: size=" << in.getData().size() << "; expected " << opts.size;
-                        throw std::runtime_error(oss.str());
-                    }
-                    out.setData(data);
-                    out.getMessageProperties().setCorrelationId(in.getMessageProperties().getCorrelationId());
-                    out.getDeliveryProperties().setDeliveryMode(in.getDeliveryProperties().getDeliveryMode());
-                    session.messageTransfer(arg::content=out, arg::acceptMode=1);
-                }
-                sub.accept(sub.getUnaccepted());
-                if (opts.dtx) {
-                    session.dtxEnd(arg::xid=xid);
-                    session.dtxPrepare(arg::xid=xid);
-                    session.dtxCommit(arg::xid=xid);
-                } else {
-                    session.txCommit();
-                }
-            }
-        } catch(const std::exception& e) {
-            std::cout << "Transfer interrupted: " << e.what() << std::endl;
-        }
-    }
-
-    void setNewXid(framing::Xid& xid) {
-        framing::Uuid uuid(true);
-        xid.setGlobalId(uuid.str());
-    }
-};
-
-struct Controller : public Client
-{
-    StringSet ids;
-    StringSet queues;
-
-    Controller()
-    {
-        generateSet(opts.base, opts.queues, queues);
-        generateSet("msg", opts.totalMsgCount, ids);
-    }
-
-    void init()
-    {
-        //declare queues
-        for (StringSet::iterator i = queues.begin(); i != queues.end(); i++) {
-            session.queueDeclare(arg::queue=*i, arg::durable=opts.durable);
-            session.sync();
-        }
-
-        Message msg(generateData(opts.size), *queues.begin());
-        if (opts.durable) {
-            msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
-        }
-
-        //publish messages
-        for (StringSet::iterator i = ids.begin(); i != ids.end(); i++) {
-            msg.getMessageProperties().setCorrelationId(*i);
-            session.messageTransfer(arg::content=msg, arg::acceptMode=1);
-        }
-    }
-
-    void transfer()
-    {
-        boost::ptr_vector<Transfer> agents(opts.queues);
-        //launch transfer agents
-        for (StringSet::iterator i = queues.begin(); i != queues.end(); i++) {
-            StringSet::iterator next = i + 1;
-            if (next == queues.end()) next = queues.begin();
-
-            if (!opts.quiet) std::cout << "Transfering from " << *i << " to " << *next << std::endl;
-            agents.push_back(new Transfer(*i, *next));
-            agents.back().thread = Thread(agents.back());
-        }
-
-        for (boost::ptr_vector<Transfer>::iterator i = agents.begin(); i != agents.end(); i++) {
-            i->thread.join();
-        }
-    }
-
-    int check()
-    {
-        SubscriptionManager subs(session);
-
-        // Recover DTX transactions (if any)
-        if (opts.dtx) {
-            std::vector<std::string> inDoubtXids;
-            framing::DtxRecoverResult dtxRes = session.dtxRecover().get();
-            const framing::Array& xidArr = dtxRes.getInDoubt();
-            xidArr.collect(inDoubtXids);
-
-            if (inDoubtXids.size()) {
-                if (!opts.quiet) std::cout << "Recovering DTX in-doubt transaction(s):" << std::endl;
-                framing::StructHelper decoder;
-                framing::Xid xid;
-                // abort even, commit odd transactions
-                for (unsigned i = 0; i < inDoubtXids.size(); i++) {
-                    decoder.decode(xid, inDoubtXids[i]);
-                    if (!opts.quiet) std::cout << (i%2 ? " * aborting " : " * committing ");
-                    xid.print(std::cout);
-                    std::cout << std::endl;
-                    if (i%2) {
-                        session.dtxRollback(arg::xid=xid);
-                    } else {
-                        session.dtxCommit(arg::xid=xid);
-                    }
-                }
-            }
-        }
-
-        StringSet drained;
-        //drain each queue and verify the correct set of messages are available
-        for (StringSet::iterator i = queues.begin(); i != queues.end(); i++) {
-            //subscribe, allocate credit and flushn
-            LocalQueue lq;
-            SubscriptionSettings settings(FlowControl::unlimited(), ACCEPT_MODE_NONE);
-            subs.subscribe(lq, *i, settings);
-            session.messageFlush(arg::destination=*i);
-            session.sync();
-
-            uint count(0);
-            while (!lq.empty()) {
-                Message m = lq.pop();
-                //add correlation ids of received messages to drained
-                drained.push_back(m.getMessageProperties().getCorrelationId());
-                ++count;
-            }
-            if (!opts.quiet) std::cout << "Drained " << count << " messages from " << *i << std::endl;
-        }
-
-        sort(ids.begin(), ids.end());
-        sort(drained.begin(), drained.end());
-
-        //check that drained == ids
-        StringSet missing;
-        set_difference(ids.begin(), ids.end(), drained.begin(), drained.end(), back_inserter(missing));
-
-        StringSet extra;
-        set_difference(drained.begin(), drained.end(), ids.begin(), ids.end(), back_inserter(extra));
-
-        if (missing.empty() && extra.empty()) {
-            std::cout << "All expected messages were retrieved." << std::endl;
-            return 0;
-        } else {
-            if (!missing.empty()) {
-                std::cout << "The following ids were missing:" << std::endl;
-                for (StringSet::iterator i = missing.begin(); i != missing.end(); i++) {
-                    std::cout << "    '" << *i << "'" << std::endl;
-                }
-            }
-            if (!extra.empty()) {
-                std::cout << "The following extra ids were encountered:" << std::endl;
-                for (StringSet::iterator i = extra.begin(); i != extra.end(); i++) {
-                    std::cout << "    '" << *i << "'" << std::endl;
-                }
-            }
-            return 1;
-        }
-    }
-};
-
-}} // namespace qpid::tests
-
-using namespace qpid::tests;
-
-int main(int argc, char** argv)
-{
-    try {
-        opts.parse(argc, argv);
-        Controller controller;
-        if (opts.init) controller.init();
-        if (opts.transfer) controller.transfer();
-        if (opts.check) return controller.check();
-        return 0;
-    } catch(const std::exception& e) {
-	std::cout << e.what() << std::endl;
-    }
-    return 2;
-}
-- 
1.5.5.6

From f80f6ebf6ae83cc456ad225b18c9a92afd33e0fd Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Thu, 20 May 2010 19:52:55 +0000
Subject: [PATCH] Removed the logic in the broker's management agent that detected name collisions.
 The new logic will disambiguate colliding names by adding an underscore to the one
 being inserted.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@946773 13f79535-47bb-0310-9956-ffa450edef68
---
 .../cpp/include/qpid/management/ManagementObject.h |    1 +
 qpid/cpp/src/qpid/management/ManagementAgent.cpp   |  113 +++-----------------
 qpid/cpp/src/qpid/management/ManagementAgent.h     |    2 -
 qpid/cpp/src/qpid/management/ManagementObject.cpp  |   36 ++++---
 4 files changed, 37 insertions(+), 115 deletions(-)

diff --git a/qpid/cpp/include/qpid/management/ManagementObject.h b/qpid/cpp/include/qpid/management/ManagementObject.h
index 9c2d14f..6bbd7ec 100644
--- a/qpid/cpp/include/qpid/management/ManagementObject.h
+++ b/qpid/cpp/include/qpid/management/ManagementObject.h
@@ -78,6 +78,7 @@ public:
     QPID_COMMON_EXTERN bool equalV1(const ObjectId &other) const;
     QPID_COMMON_EXTERN void setV2Key(const std::string& _key) { v2Key = _key; }
     QPID_COMMON_EXTERN void setV2Key(const ManagementObject& object);
+    QPID_COMMON_EXTERN void disambiguate();
     QPID_COMMON_EXTERN void setAgentName(const std::string& _name) { agentName = _name; }
     QPID_COMMON_EXTERN const std::string& getAgentName() const { return agentName; }
     QPID_COMMON_EXTERN const std::string& getV2Key() const { return v2Key; }
diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.cpp b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
index d4649a7..7f2dd69 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.cpp
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
@@ -135,12 +135,6 @@ ManagementAgent::~ManagementAgent ()
             delete object;
         }
         managementObjects.clear();
-
-        while (!deletedManagementObjects.empty()) {
-            ManagementObject* object = deletedManagementObjects.back();
-            delete object;
-            deletedManagementObjects.pop_back();
-        }
     }
 }
 
@@ -285,17 +279,11 @@ ObjectId ManagementAgent::addObject(ManagementObject* object, uint64_t persistId
     object->setObjectId(objId);
 
     {
-        sys::Mutex::ScopedLock lock (addLock);
+        sys::Mutex::ScopedLock lock(addLock);
         ManagementObjectMap::iterator destIter = newManagementObjects.find(objId);
-        if (destIter != newManagementObjects.end()) {
-            if (destIter->second->isDeleted()) {
-                newDeletedManagementObjects.push_back(destIter->second);
-                newManagementObjects.erase(destIter);
-            } else {
-                QPID_LOG(error, "ObjectId collision in addObject. class=" << object->getClassName() <<
-                         " key=" << objId.getV2Key());
-                return objId;
-            }
+        while (destIter != newManagementObjects.end()) {
+            objId.disambiguate();
+            destIter = newManagementObjects.find(objId);
         }
         newManagementObjects[objId] = object;
     }
@@ -323,17 +311,11 @@ ObjectId ManagementAgent::addObject(ManagementObject* object,
     object->setObjectId(objId);
 
     {
-        sys::Mutex::ScopedLock lock (addLock);
+        sys::Mutex::ScopedLock lock(addLock);
         ManagementObjectMap::iterator destIter = newManagementObjects.find(objId);
-        if (destIter != newManagementObjects.end()) {
-            if (destIter->second->isDeleted()) {
-                newDeletedManagementObjects.push_back(destIter->second);
-                newManagementObjects.erase(destIter);
-            } else {
-                QPID_LOG(error, "ObjectId collision in addObject. class=" << object->getClassName() <<
-                         " key=" << objId.getV2Key());
-                return objId;
-            }
+        while (destIter != newManagementObjects.end()) {
+            objId.disambiguate();
+            destIter = newManagementObjects.find(objId);
         }
         newManagementObjects[objId] = object;
     }
@@ -583,30 +565,16 @@ void ManagementAgent::moveNewObjectsLH()
     for (ManagementObjectMap::iterator iter = newManagementObjects.begin ();
          iter != newManagementObjects.end ();
          iter++) {
-        bool skip = false;
-        ManagementObjectMap::iterator destIter = managementObjects.find(iter->first);
-        if (destIter != managementObjects.end()) {
-            // We have an objectId collision with an existing object.  If the old object
-            // is deleted, move it to the deleted list.
-            if (destIter->second->isDeleted()) {
-                deletedManagementObjects.push_back(destIter->second);
-                managementObjects.erase(destIter);
-            } else {
-                QPID_LOG(error, "ObjectId collision in moveNewObjects. class=" <<
-                         iter->second->getClassName() << " key=" << iter->first.getV2Key());
-                skip = true;
-            }
+        ObjectId oid = iter->first;
+        ManagementObjectMap::iterator destIter = managementObjects.find(oid);
+        while (destIter != managementObjects.end()) {
+            oid.disambiguate();
+            destIter = managementObjects.find(oid);
         }
 
-        if (!skip)
-            managementObjects[iter->first] = iter->second;
+        managementObjects[oid] = iter->second;
     }
     newManagementObjects.clear();
-
-    while (!newDeletedManagementObjects.empty()) {
-        deletedManagementObjects.push_back(newDeletedManagementObjects.back());
-        newDeletedManagementObjects.pop_back();
-    }
 }
 
 void ManagementAgent::periodicProcessing (void)
@@ -760,58 +728,7 @@ void ManagementAgent::periodicProcessing (void)
         managementObjects.erase(iter->first);
     }
 
-    // Publish the deletion of objects created by insert-collision
-    bool collisionDeletions = false;
-    for (ManagementObjectVector::iterator cdIter = deletedManagementObjects.begin();
-         cdIter != deletedManagementObjects.end(); cdIter++) {
-        collisionDeletions = true;
-        {
-            if (qmf1Support) {
-                Buffer msgBuffer(msgChars, BUFSIZE);
-                encodeHeader(msgBuffer, 'c');
-                sBuf.clear();
-                (*cdIter)->writeProperties(sBuf);
-                msgBuffer.putRawData(sBuf);
-                contentSize = BUFSIZE - msgBuffer.available ();
-                msgBuffer.reset ();
-                stringstream key;
-                key << "console.obj.1.0." << (*cdIter)->getPackageName() << "." << (*cdIter)->getClassName();
-                sendBufferLH(msgBuffer, contentSize, mExchange, key.str());
-                QPID_LOG(trace, "SEND ContentInd for deleted object to=" << key.str());
-            }
-
-            if (qmf2Support) {
-                Variant::List list_;
-                Variant::Map  map_;
-                Variant::Map  values;
-                Variant::Map  headers;
-
-                map_["_schema_id"] = mapEncodeSchemaId((*cdIter)->getPackageName(),
-                                                       (*cdIter)->getClassName(),
-                                                       "_data",
-                                                       (*cdIter)->getMd5Sum());
-                (*cdIter)->writeTimestamps(map_);
-                (*cdIter)->mapEncodeValues(values, true, false);
-                map_["_values"] = values;
-                list_.push_back(map_);
-
-                headers["method"] = "indication";
-                headers["qmf.opcode"] = "_data_indication";
-                headers["qmf.content"] = "_data";
-                headers["qmf.agent"] = name_address;
-
-                stringstream key;
-                key << "agent.ind.data." << (*cdIter)->getPackageName() << "." << (*cdIter)->getClassName();
-
-                string content;
-                ListCodec::encode(list_, content);
-                sendBufferLH(content, "", headers, "amqp/list", v2Topic, key.str());
-                QPID_LOG(trace, "SEND ContentInd for deleted object to=" << key.str());
-            }
-        }
-    }
-
-    if (!deleteList.empty() || collisionDeletions) {
+    if (!deleteList.empty()) {
         deleteList.clear();
         deleteOrphanedAgentsLH();
     }
diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.h b/qpid/cpp/src/qpid/management/ManagementAgent.h
index 8129c1e..d101ca1 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.h
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.h
@@ -242,13 +242,11 @@ private:
     // Protected by userLock
     //
     ManagementObjectMap          managementObjects;
-    ManagementObjectVector       deletedManagementObjects;
 
     //
     // Protected by addLock
     //
     ManagementObjectMap          newManagementObjects;
-    ManagementObjectVector       newDeletedManagementObjects;
 
     framing::Uuid                uuid;
 
diff --git a/qpid/cpp/src/qpid/management/ManagementObject.cpp b/qpid/cpp/src/qpid/management/ManagementObject.cpp
index 209c935..5cdf9ec 100644
--- a/qpid/cpp/src/qpid/management/ManagementObject.cpp
+++ b/qpid/cpp/src/qpid/management/ManagementObject.cpp
@@ -30,6 +30,7 @@
 
 #include <stdlib.h>
 
+using namespace std;
 using namespace qpid;
 using namespace qpid::management;
 
@@ -71,19 +72,19 @@ ObjectId::ObjectId(AgentAttachment* _agent, uint8_t flags, uint16_t seq)
 }
 
 
-ObjectId::ObjectId(std::istream& in) : agent(0)
+ObjectId::ObjectId(istream& in) : agent(0)
 {
-    std::string text;
+    string text;
     in >> text;
     fromString(text);
 }
 
-ObjectId::ObjectId(const std::string& text) : agent(0)
+ObjectId::ObjectId(const string& text) : agent(0)
 {
     fromString(text);
 }
 
-void ObjectId::fromString(const std::string& text)
+void ObjectId::fromString(const string& text)
 {
 #define FIELDS 5
 #if defined (_WIN32) && !defined (atoll)
@@ -94,7 +95,7 @@ void ObjectId::fromString(const std::string& text)
     // V1: <flags>-<sequence>-<broker-bank>-<agent-bank>-<uint64-app-id>
     // V2: Not used
 
-    std::string copy(text.c_str());
+    string copy(text.c_str());
     char* cText;
     char* field[FIELDS];
     bool  atFieldStart = true;
@@ -124,7 +125,7 @@ void ObjectId::fromString(const std::string& text)
         (atoll(field[1]) << 48) +
         (atoll(field[2]) << 28);
 
-    agentName = std::string(field[3]);
+    agentName = string(field[3]);
     second = atoll(field[4]);
 }
 
@@ -146,7 +147,7 @@ bool ObjectId::equalV1(const ObjectId &other) const
 }
 
 // encode as V1-format binary
-void ObjectId::encode(std::string& buffer) const
+void ObjectId::encode(string& buffer) const
 {
     const uint32_t len = 16;
     char _data[len];
@@ -163,7 +164,7 @@ void ObjectId::encode(std::string& buffer) const
 }
 
 // decode as V1-format binary
-void ObjectId::decode(const std::string& buffer)
+void ObjectId::decode(const string& buffer)
 {
     const uint32_t len = 16;
     char _data[len];
@@ -174,18 +175,23 @@ void ObjectId::decode(const std::string& buffer)
     body.reset();
     first  = body.getLongLong();
     second = body.getLongLong();
-    v2Key = boost::lexical_cast<std::string>(second);
+    v2Key = boost::lexical_cast<string>(second);
 }
 
 // generate the V2 key from the index fields defined
 // in the schema.
 void ObjectId::setV2Key(const ManagementObject& object)
 {
-    std::stringstream oname;
+    stringstream oname;
     oname << object.getPackageName() << ":" << object.getClassName() << ":" << object.getKey();
     v2Key = oname.str();
 }
 
+void ObjectId::disambiguate()
+{
+    v2Key = v2Key + "_";
+}
+
 // encode as V2-format map
 void ObjectId::mapEncode(types::Variant::Map& map) const
 {
@@ -226,7 +232,7 @@ ObjectId::operator types::Variant::Map() const
 namespace qpid {
 namespace management {
 
-std::ostream& operator<<(std::ostream& out, const ObjectId& i)
+ostream& operator<<(ostream& out, const ObjectId& i)
 {
     uint64_t virtFirst = i.first;
     if (i.agent)
@@ -263,7 +269,7 @@ void ManagementObject::resourceDestroy()
 int ManagementObject::maxThreads = 1;
 int ManagementObject::nextThreadIndex = 0;
 
-void ManagementObject::writeTimestamps (std::string& buf) const
+void ManagementObject::writeTimestamps (string& buf) const
 {
     char _data[4000];
     qpid::framing::Buffer body(_data, 4000);
@@ -279,16 +285,16 @@ void ManagementObject::writeTimestamps (std::string& buf) const
     body.reset();
     body.getRawData(buf, len);
 
-    std::string oid;
+    string oid;
     objectId.encode(oid);
     buf += oid;
 }
 
-void ManagementObject::readTimestamps (const std::string& buf)
+void ManagementObject::readTimestamps (const string& buf)
 {
     char _data[4000];
     qpid::framing::Buffer body(_data, 4000);
-    std::string unused;
+    string unused;
     uint8_t unusedUuid[16];
 
     body.checkAvailable(buf.length());
-- 
1.5.5.6

From 856c5276a219a35752564a0d5b4657d381c24285 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Fri, 21 May 2010 15:40:39 +0000
Subject: [PATCH] Added setEncoding call to strings encoded from maps and lists.  Encoding is "utf8" for now.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@947045 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/bindings/qpid/dotnet/src/Message.cpp |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
index a3e966e..9c28e72 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
@@ -320,6 +320,7 @@ namespace messaging {
                 rpString = System::Convert::ToString(theObjp);
                 rString = QpidMarshal::ToNative(rpString);
                 targetp = rString;
+				targetp.setEncoding(QpidMarshal::ToNative("utf8"));
             }
             break;
 
-- 
1.5.5.6

From c940805177c8276f2ee9331c8db6f86f7baee8fd Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Tue, 25 May 2010 14:02:49 +0000
Subject: [PATCH] Replaced the earlier-removed init function (in ManagementAgent.h) that uses
 ConnectionSettings.  Created a ConnectionSettings in the qpid::management name
 space that mirrors that from the qpid::client namespace.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@948046 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/include/qpid/agent/ManagementAgent.h      |    9 ++-
 .../include/qpid/management/ConnectionSettings.h   |  118 ++++++++++++++++++++
 qpid/cpp/src/CMakeLists.txt                        |    1 +
 qpid/cpp/src/Makefile.am                           |    2 +
 qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp    |   25 ++++-
 qpid/cpp/src/qpid/agent/ManagementAgentImpl.h      |    2 +-
 .../cpp/src/qpid/management/ConnectionSettings.cpp |   40 +++++++
 7 files changed, 192 insertions(+), 5 deletions(-)
 create mode 100644 qpid/cpp/include/qpid/management/ConnectionSettings.h
 create mode 100644 qpid/cpp/src/qpid/management/ConnectionSettings.cpp

diff --git a/qpid/cpp/include/qpid/agent/ManagementAgent.h b/qpid/cpp/include/qpid/agent/ManagementAgent.h
index 456b657..d534416 100644
--- a/qpid/cpp/include/qpid/agent/ManagementAgent.h
+++ b/qpid/cpp/include/qpid/agent/ManagementAgent.h
@@ -24,6 +24,7 @@
 #include "qpid/management/ManagementObject.h"
 #include "qpid/management/ManagementEvent.h"
 #include "qpid/management/Manageable.h"
+#include "qpid/management/ConnectionSettings.h"
 
 namespace qpid {
 namespace management {
@@ -103,6 +104,12 @@ class ManagementAgent
                       const std::string& mech = "PLAIN",
                       const std::string& proto = "tcp") = 0;
 
+    virtual void init(const management::ConnectionSettings& settings,
+                      uint16_t intervalSeconds = 10,
+                      bool useExternalThread = false,
+                      const std::string& storeFile = "") = 0;
+
+
     // Register a schema with the management agent.  This is normally called by the
     // package initializer generated by the management code generator.
     //
@@ -117,7 +124,7 @@ class ManagementAgent
                   const std::string& eventName,
                   uint8_t*    md5Sum,
                   management::ManagementEvent::writeSchemaCall_t schemaCall) = 0;
-
+
     // Add a management object to the agent.  Once added, this object shall be visible
     // in the greater management context.
     //
diff --git a/qpid/cpp/include/qpid/management/ConnectionSettings.h b/qpid/cpp/include/qpid/management/ConnectionSettings.h
new file mode 100644
index 0000000..b631ffa
--- /dev/null
+++ b/qpid/cpp/include/qpid/management/ConnectionSettings.h
@@ -0,0 +1,118 @@
+#ifndef _management_ConnectionSettings_h
+#define _management_ConnectionSettings_h
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+#include "qpid/CommonImportExport.h"
+#include "qpid/types/Variant.h"
+#include <string>
+
+namespace qpid {
+namespace management {
+
+/**
+ * Settings for a Connection.
+ */
+struct ConnectionSettings {
+
+    QPID_COMMON_EXTERN ConnectionSettings();
+    QPID_COMMON_EXTERN virtual ~ConnectionSettings();
+
+    /**
+     * The protocol used for the connection (defaults to 'tcp')
+     */
+    std::string protocol;
+
+    /**
+     * The host (or ip address) to connect to (defaults to 'localhost').
+     */
+    std::string host;
+    /**
+     * The port to connect to (defaults to 5672).
+     */
+    uint16_t port;
+    /**
+     * Allows an AMQP 'virtual host' to be specified for the
+     * connection.
+     */
+    std::string virtualhost;
+
+    /**
+     * The username to use when authenticating the connection. If not
+     * specified the current users login is used if available.
+     */
+    std::string username;
+    /**
+     * The password to use when authenticating the connection.
+     */
+    std::string password;
+    /**
+     * The SASL mechanism to use when authenticating the connection;
+     * the options are currently PLAIN or ANONYMOUS.
+     */
+    std::string mechanism;
+    /**
+     * Allows a locale to be specified for the connection.
+     */
+    std::string locale;
+    /**
+     * Allows a heartbeat frequency to be specified
+     */
+    uint16_t heartbeat;
+    /**
+     * The maximum number of channels that the client will request for
+     * use on this connection.
+     */
+    uint16_t maxChannels;
+    /**
+     * The maximum frame size that the client will request for this
+     * connection.
+     */
+    uint16_t maxFrameSize;
+    /**
+     * Limit the size of the connections send buffer . The buffer
+     * is limited to bounds * maxFrameSize.
+     */
+    unsigned int bounds;
+    /**
+     * If true, TCP_NODELAY will be set for the connection.
+     */
+    bool tcpNoDelay;
+    /**
+     * SASL service name
+     */
+    std::string service;
+    /**
+     * Minimum acceptable strength of any SASL negotiated security
+     * layer. 0 means no security layer required.
+     */
+    unsigned int minSsf;
+    /**
+     * Maximum acceptable strength of any SASL negotiated security
+     * layer. 0 means no security layer allowed.
+     */
+    unsigned int maxSsf;
+};
+
+}}
+
+#endif
+
diff --git a/qpid/cpp/src/CMakeLists.txt b/qpid/cpp/src/CMakeLists.txt
index aa40fd7..7083574 100644
--- a/qpid/cpp/src/CMakeLists.txt
+++ b/qpid/cpp/src/CMakeLists.txt
@@ -616,6 +616,7 @@ set (qpidcommon_SOURCES
      qpid/log/Selector.cpp
      qpid/log/Statement.cpp
      qpid/management/Buffer.cpp
+     qpid/management/ConnectionSettings.cpp
      qpid/management/Mutex.cpp
      qpid/management/Manageable.cpp
      qpid/management/ManagementObject.cpp
diff --git a/qpid/cpp/src/Makefile.am b/qpid/cpp/src/Makefile.am
index f2125eb..2df445e 100644
--- a/qpid/cpp/src/Makefile.am
+++ b/qpid/cpp/src/Makefile.am
@@ -421,6 +421,7 @@ libqpidcommon_la_SOURCES +=			\
   qpid/log/Selector.cpp				\
   qpid/log/Statement.cpp			\
   qpid/management/Buffer.cpp			\
+  qpid/management/ConnectionSettings.cpp	\
   qpid/management/Manageable.cpp		\
   qpid/management/ManagementObject.cpp		\
   qpid/management/Mutex.cpp			\
@@ -808,6 +809,7 @@ nobase_include_HEADERS +=			\
   ../include/qpid/log/Statement.h		\
   ../include/qpid/management/Args.h		\
   ../include/qpid/management/Buffer.h		\
+  ../include/qpid/management/ConnectionSettings.h \
   ../include/qpid/management/Manageable.h	\
   ../include/qpid/management/ManagementEvent.h	\
   ../include/qpid/management/ManagementObject.h	\
diff --git a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
index 5c2c6c5..6a07d8c 100644
--- a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
+++ b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
@@ -148,7 +148,7 @@ void ManagementAgentImpl::init(const string& brokerHost,
                                const string& mech,
                                const string& proto)
 {
-    client::ConnectionSettings settings;
+    management::ConnectionSettings settings;
     settings.protocol = proto;
     settings.host = brokerHost;
     settings.port = brokerPort;
@@ -158,7 +158,7 @@ void ManagementAgentImpl::init(const string& brokerHost,
     init(settings, intervalSeconds, useExternalThread, _storeFile);
 }
 
-void ManagementAgentImpl::init(const qpid::client::ConnectionSettings& settings,
+void ManagementAgentImpl::init(const qpid::management::ConnectionSettings& settings,
                                uint16_t intervalSeconds,
                                bool useExternalThread,
                                const string& _storeFile)
@@ -170,7 +170,26 @@ void ManagementAgentImpl::init(const qpid::client::ConnectionSettings& settings,
 
     QPID_LOG(info, "QMF Agent Initialized: broker=" << settings.host << ":" << settings.port <<
              " interval=" << intervalSeconds << " storeFile=" << _storeFile);
-    connectionSettings = settings;
+
+    //
+    // Convert from management::ConnectionSettings to client::ConnectionSettings
+    //
+    connectionSettings.protocol     = settings.protocol;
+    connectionSettings.host         = settings.host;
+    connectionSettings.port         = settings.port;
+    connectionSettings.virtualhost  = settings.virtualhost;
+    connectionSettings.username     = settings.username;
+    connectionSettings.password     = settings.password;
+    connectionSettings.mechanism    = settings.mechanism;
+    connectionSettings.locale       = settings.locale;
+    connectionSettings.heartbeat    = settings.heartbeat;
+    connectionSettings.maxChannels  = settings.maxChannels;
+    connectionSettings.maxFrameSize = settings.maxFrameSize;
+    connectionSettings.bounds       = settings.bounds;
+    connectionSettings.tcpNoDelay   = settings.tcpNoDelay;
+    connectionSettings.service      = settings.service;
+    connectionSettings.minSsf       = settings.minSsf;
+    connectionSettings.maxSsf       = settings.maxSsf;
 
     retrieveData();
     bootSequence++;
diff --git a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h
index d160934..7d4531f 100644
--- a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h
+++ b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h
@@ -63,7 +63,7 @@ class ManagementAgentImpl : public ManagementAgent, public client::MessageListen
               const std::string& pwd = "guest",
               const std::string& mech = "PLAIN",
               const std::string& proto = "tcp");
-    void init(const client::ConnectionSettings& settings,
+    void init(const management::ConnectionSettings& settings,
               uint16_t intervalSeconds = 10,
               bool useExternalThread = false,
               const std::string& storeFile = "");
diff --git a/qpid/cpp/src/qpid/management/ConnectionSettings.cpp b/qpid/cpp/src/qpid/management/ConnectionSettings.cpp
new file mode 100644
index 0000000..1421a26
--- /dev/null
+++ b/qpid/cpp/src/qpid/management/ConnectionSettings.cpp
@@ -0,0 +1,40 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+#include "qpid/management/ConnectionSettings.h"
+#include "qpid/Version.h"
+
+qpid::management::ConnectionSettings::ConnectionSettings() :
+    protocol("tcp"),
+    host("localhost"), 
+    port(5672),
+    locale("en_US"),
+    heartbeat(0),
+    maxChannels(32767),
+    maxFrameSize(65535),
+    bounds(2),
+    tcpNoDelay(false),
+    service(qpid::saslName),
+    minSsf(0),
+    maxSsf(256)
+{}
+
+qpid::management::ConnectionSettings::~ConnectionSettings() {}
+
-- 
1.5.5.6

From 87a548b4b5e525bd887fd486469e63ed9bd79c03 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Tue, 25 May 2010 18:05:54 +0000
Subject: [PATCH] Bug 592999: Fix "mismatched cluster-id" errors during start up.

Intermittent failure when starting a persistent cluster with all clean stores.
Some brokers fail with:
  critical Unexpected error: Cluster-ID mismatch. Stores belong to different clusters.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@948143 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 5b381f3f71c69ab356527965a639466bc3bc3615)
---
 qpid/cpp/src/qpid/cluster/Cluster.cpp |   47 +++++++++++++++++++--------------
 qpid/cpp/src/qpid/cluster/Cluster.h   |    2 +-
 2 files changed, 28 insertions(+), 21 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/Cluster.cpp b/qpid/cpp/src/qpid/cluster/Cluster.cpp
index 099c3ef..6b9fcec 100644
--- a/qpid/cpp/src/qpid/cluster/Cluster.cpp
+++ b/qpid/cpp/src/qpid/cluster/Cluster.cpp
@@ -266,7 +266,7 @@ Cluster::Cluster(const ClusterSettings& set, broker::Broker& b) :
     initMap(self, settings.size),
     store(broker.getDataDir().getPath()),
     elder(false),
-    lastSize(0),
+    lastAliveCount(0),
     lastBroker(false),
     updateRetracted(false),
     error(*this)
@@ -290,7 +290,7 @@ Cluster::Cluster(const ClusterSettings& set, broker::Broker& b) :
         store.load();
         clusterId = store.getClusterId(); 
         QPID_LOG(notice, "Cluster store state: " << store)
-    }
+            }
     cpg.join(name);
     // pump the CPG dispatch manually till we get past PRE_INIT.
     while (state == PRE_INIT)
@@ -326,7 +326,8 @@ void Cluster::initialize() {
         mgmtObject->set_status("JOINING");
     }
 
-    // Run initMapCompleted immediately to process the initial configuration.
+    // Run initMapCompleted immediately to process the initial configuration
+    // that allowed us to transition out of PRE_INIT
     assert(state == INIT);
     initMapCompleted(*(Mutex::ScopedLock*)0); // Fake lock, single-threaded context.
 
@@ -433,7 +434,7 @@ const ClusterUpdateOfferBody* castUpdateOffer(const framing::AMQBody* body) {
 const ClusterConnectionAnnounceBody* castAnnounce( const framing::AMQBody *body) {
     return  (body && body->getMethod() &&
              body->getMethod()->isA<ClusterConnectionAnnounceBody>()) ?
-      static_cast<const ClusterConnectionAnnounceBody*>(body) : 0;
+        static_cast<const ClusterConnectionAnnounceBody*>(body) : 0;
 }
 
 // Handler for deliverEventQueue.
@@ -616,8 +617,8 @@ void Cluster::initMapCompleted(Lock& l) {
                      << " members, waiting for at least " << initMap.getRequiredSize());
             return;
         }
-        initMap.checkConsistent();
 
+        initMap.checkConsistent();
         elders = initMap.getElders();
         QPID_LOG(debug, *this << " elders: " << elders);
         if (elders.empty())
@@ -657,11 +658,11 @@ void Cluster::configChange(const MemberId&,
     MemberSet members = decodeMemberSet(membersStr);
     MemberSet left = decodeMemberSet(leftStr);
     MemberSet joined = decodeMemberSet(joinedStr);
-    QPID_LOG(notice, *this << " Membership update: " << members);
+    QPID_LOG(notice, *this << " configuration change: " << members);
     QPID_LOG_IF(notice, !left.empty(), *this << " Members left: " << left);
     QPID_LOG_IF(notice, !joined.empty(), *this << " Members joined: " << joined);
 
-    // Update initital status for members joining or leaving.
+    // If we are still joining, make sure there is someone to give us an update.
     elders = intersection(elders, members);
     if (elders.empty() && INIT < state && state < CATCHUP) {
         QPID_LOG(critical, "Cannot update, all potential updaters left the cluster.");
@@ -882,6 +883,7 @@ void Cluster::checkUpdateIn(Lock& l) {
         failoverExchange->setUrls(getUrls(l));
         mcast.mcastControl(ClusterReadyBody(ProtocolVersion(), myUrl.str()), self);
         state = CATCHUP;
+        memberUpdate(l);
         broker.setClusterUpdatee(false);
         if (mAgent) mAgent->suppress(false); // Enable management output.
         discarding = false;     // ok to set, we're stalled for update.
@@ -908,7 +910,7 @@ void Cluster::updateOutDone(Lock& l) {
     QPID_LOG(notice, *this << " update sent");
     assert(state == UPDATER);
     state = READY;
-     deliverEventQueue.start();       // Start processing events again.
+    deliverEventQueue.start();       // Start processing events again.
     makeOffer(map.firstJoiner(), l); // Try another offer
 }
 
@@ -959,15 +961,18 @@ void Cluster::stopFullCluster(Lock& ) {
 }
 
 void Cluster::memberUpdate(Lock& l) {
+    // Ignore config changes while we are joining.
+    if (state < CATCHUP) return;
     QPID_LOG(info, *this << " member update: " << map);
     std::vector<Url> urls = getUrls(l);
     std::vector<string> ids = getIds(l);
-    size_t size = urls.size();
+    size_t aliveCount = map.aliveCount();
+    assert(map.isAlive(self));
     failoverExchange->updateUrls(urls);
 
+    // Mark store clean if I am the only broker, dirty otherwise.
     if (store.hasStore()) {
-        // Mark store clean if I am the only broker, dirty otherwise.
-        if (size == 1 ) {
+        if (aliveCount == 1) {
             if (store.getState() != STORE_STATE_CLEAN_STORE) {
                 QPID_LOG(notice, *this << "Sole member of cluster, marking store clean.");
                 store.clean(Uuid(true));
@@ -975,26 +980,28 @@ void Cluster::memberUpdate(Lock& l) {
         }
         else {
             if (store.getState() != STORE_STATE_DIRTY_STORE) {
-                QPID_LOG(notice, "No longer sole cluster member, marking store dirty.");
+                QPID_LOG(notice, "Running in a cluster, marking store dirty.");
                 store.dirty();
             }
         }
     }
 
-    if (size == 1 && lastSize > 1 && state >= CATCHUP) {
+    // If I am the last member standing, set queue policies.
+    if (aliveCount == 1 && lastAliveCount > 1 && state >= CATCHUP) {
         QPID_LOG(notice, *this << " last broker standing, update queue policies");
         lastBroker = true;
         broker.getQueues().updateQueueClusterState(true);
     }
-    else if (size > 1 && lastBroker) {
-        QPID_LOG(notice, *this << " last broker standing joined by " << size-1 << " replicas, updating queue policies" << size);
+    else if (aliveCount > 1 && lastBroker) {
+        QPID_LOG(notice, *this << " last broker standing joined by " << aliveCount-1
+                 << " replicas, updating queue policies.");
         lastBroker = false;
         broker.getQueues().updateQueueClusterState(false);
     }
-    lastSize = size;
+    lastAliveCount = aliveCount;
 
     if (mgmtObject) {
-        mgmtObject->set_clusterSize(size); 
+        mgmtObject->set_clusterSize(urls.size()); 
         string urlstr;
         for(std::vector<Url>::iterator iter = urls.begin(); iter != urls.end(); iter++ ) {
             if (iter != urls.begin()) urlstr += ";";
@@ -1029,7 +1036,7 @@ std::ostream& operator<<(std::ostream& o, const Cluster& cluster) {
     assert(sizeof(STATE)/sizeof(*STATE) == Cluster::LEFT+1);
     o << "cluster(" << cluster.self << " " << STATE[cluster.state];
     if (cluster.error.isUnresolved()) o << "/error";
-    return o << ")";;
+    return o << ")";
 }
 
 MemberId Cluster::getId() const {
@@ -1071,8 +1078,8 @@ void Cluster::timerWakeup(const MemberId& , const std::string& name, Lock&) {
 
 void Cluster::timerDrop(const MemberId& , const std::string& name, Lock&) {
     QPID_LOG(debug, "Cluster timer drop " << map.getFrameSeq() << ": " << name)
-    if (state >= CATCHUP) // Pre catchup our timer isn't set up.
-        timer->deliverDrop(name);
+        if (state >= CATCHUP) // Pre catchup our timer isn't set up.
+            timer->deliverDrop(name);
 }
 
 bool Cluster::isElder() const {
diff --git a/qpid/cpp/src/qpid/cluster/Cluster.h b/qpid/cpp/src/qpid/cluster/Cluster.h
index 343a664..0d8b55c 100644
--- a/qpid/cpp/src/qpid/cluster/Cluster.h
+++ b/qpid/cpp/src/qpid/cluster/Cluster.h
@@ -273,7 +273,7 @@ class Cluster : private Cpg::Handler, public management::Manageable {
     ClusterMap map;
     MemberSet elders;
     bool elder;
-    size_t lastSize;
+    size_t lastAliveCount;
     bool lastBroker;
     sys::Thread updateThread;
     boost::optional<ClusterMap> updatedMap;
-- 
1.5.5.6

From d040ae874743e188779161c54d9e460f5b9ab9fe Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Thu, 27 May 2010 18:09:13 +0000
Subject: [PATCH] Fix for BZ-587190, preventing blocking on bounds.

QPID-2631: For blocking Bounds::expand() calls, only increase the current count when there is space. In SessionImpl::send() expand bounds before queueing frame. Expand bounds for all frames sent (including connection frames and cluster specific frames).

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@948936 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 882b4c591fe13b1daf19eb65a8a2e2faf2bbb5b1)
---
 qpid/cpp/src/qpid/client/Bounds.cpp            |    6 +++---
 qpid/cpp/src/qpid/client/ConnectionHandler.cpp |   12 ++++++++++--
 qpid/cpp/src/qpid/client/ConnectionHandler.h   |    9 ++++++---
 qpid/cpp/src/qpid/client/ConnectionImpl.cpp    |    2 +-
 qpid/cpp/src/qpid/client/SessionImpl.cpp       |    2 +-
 qpid/cpp/src/qpid/cluster/UpdateClient.cpp     |   16 ++++++++++++++--
 qpid/cpp/src/tests/cluster_test.cpp            |    2 ++
 7 files changed, 37 insertions(+), 12 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/Bounds.cpp b/qpid/cpp/src/qpid/client/Bounds.cpp
index abb983a..cc2577d 100644
--- a/qpid/cpp/src/qpid/client/Bounds.cpp
+++ b/qpid/cpp/src/qpid/client/Bounds.cpp
@@ -33,19 +33,19 @@ Bounds::Bounds(size_t maxSize) : max(maxSize), current(0) {}
 bool Bounds::expand(size_t sizeRequired, bool block) {
     if (!max) return true;
     Waitable::ScopedLock l(lock);
-    current += sizeRequired;
     if (block) {
         Waitable::ScopedWait w(lock);
-        while (current > max) 
+        while (current + sizeRequired > max) 
             lock.wait();
     }
+    current += sizeRequired;
     return current <= max;
 }
 
 void Bounds::reduce(size_t size) {
     if (!max || size == 0) return;
     Waitable::ScopedLock l(lock);
-    if (current == 0) return;
+    assert(current >= size);
     current -= std::min(size, current);
     if (current < max && lock.hasWaiters()) {
         lock.notifyAll();
diff --git a/qpid/cpp/src/qpid/client/ConnectionHandler.cpp b/qpid/cpp/src/qpid/client/ConnectionHandler.cpp
index 9d68448..6aea4c4 100644
--- a/qpid/cpp/src/qpid/client/ConnectionHandler.cpp
+++ b/qpid/cpp/src/qpid/client/ConnectionHandler.cpp
@@ -22,6 +22,7 @@
 #include "qpid/client/ConnectionHandler.h"
 
 #include "qpid/client/SaslFactory.h"
+#include "qpid/client/Bounds.h"
 #include "qpid/framing/amqp_framing.h"
 #include "qpid/framing/all_method_bodies.h"
 #include "qpid/framing/ClientInvoker.h"
@@ -70,8 +71,15 @@ CloseCode ConnectionHandler::convert(uint16_t replyCode)
     }
 }
 
-ConnectionHandler::ConnectionHandler(const ConnectionSettings& s, ProtocolVersion& v)
-    : StateManager(NOT_STARTED), ConnectionSettings(s), outHandler(*this), proxy(outHandler),
+ConnectionHandler::Adapter::Adapter(ConnectionHandler& h, Bounds& b) : handler(h), bounds(b) {}
+void ConnectionHandler::Adapter::handle(framing::AMQFrame& f)
+{ 
+    bounds.expand(f.encodedSize(), false);
+    handler.out(f);
+}
+
+ConnectionHandler::ConnectionHandler(const ConnectionSettings& s, ProtocolVersion& v, Bounds& b)
+    : StateManager(NOT_STARTED), ConnectionSettings(s), outHandler(*this, b), proxy(outHandler),
       errorCode(CLOSE_CODE_NORMAL), version(v)
 {
     insist = true;
diff --git a/qpid/cpp/src/qpid/client/ConnectionHandler.h b/qpid/cpp/src/qpid/client/ConnectionHandler.h
index 5f4b454..61709db 100644
--- a/qpid/cpp/src/qpid/client/ConnectionHandler.h
+++ b/qpid/cpp/src/qpid/client/ConnectionHandler.h
@@ -47,6 +47,8 @@ struct SecuritySettings;
 
 namespace client {
 
+class Bounds;
+
 class ConnectionHandler : private StateManager,
                           public ConnectionSettings,
                           public ChainableFrameHandler,
@@ -60,9 +62,10 @@ class ConnectionHandler : private StateManager,
     class Adapter : public framing::FrameHandler
     {
         ConnectionHandler& handler;
+        Bounds& bounds;
     public:
-        Adapter(ConnectionHandler& h) : handler(h) {}
-        void handle(framing::AMQFrame& f) { handler.out(f); }
+        Adapter(ConnectionHandler& h, Bounds& bounds);
+        void handle(framing::AMQFrame& f);
     }; 
 
     Adapter outHandler;
@@ -102,7 +105,7 @@ public:
     typedef boost::function<void(uint16_t, const std::string&)> ErrorListener;
     typedef boost::function<const qpid::sys::SecuritySettings*()> GetSecuritySettings;
 
-    ConnectionHandler(const ConnectionSettings&, framing::ProtocolVersion&);
+    ConnectionHandler(const ConnectionSettings&, framing::ProtocolVersion&, Bounds&);
 
     void received(framing::AMQFrame& f) { incoming(f); } 
 
diff --git a/qpid/cpp/src/qpid/client/ConnectionImpl.cpp b/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
index d5fe748..99f4411 100644
--- a/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
+++ b/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
@@ -182,7 +182,7 @@ boost::shared_ptr<ConnectionImpl> ConnectionImpl::create(framing::ProtocolVersio
 
 ConnectionImpl::ConnectionImpl(framing::ProtocolVersion v, const ConnectionSettings& settings)
     : Bounds(settings.maxFrameSize * settings.bounds),
-      handler(settings, v),
+      handler(settings, v, *this),
       version(v),
       nextChannel(1),
       shutdownComplete(false),
diff --git a/qpid/cpp/src/qpid/client/SessionImpl.cpp b/qpid/cpp/src/qpid/client/SessionImpl.cpp
index b7ff430..b507625 100644
--- a/qpid/cpp/src/qpid/client/SessionImpl.cpp
+++ b/qpid/cpp/src/qpid/client/SessionImpl.cpp
@@ -510,8 +510,8 @@ void SessionImpl::proxyOut(AMQFrame& frame) // network thread
 
 void SessionImpl::sendFrame(AMQFrame& frame, bool canBlock)
 {
-    channel.handle(frame);
     connection->expand(frame.encodedSize(), canBlock);
+    channel.handle(frame);
 }
 
 void SessionImpl::deliver(AMQFrame& frame) // network thread
diff --git a/qpid/cpp/src/qpid/cluster/UpdateClient.cpp b/qpid/cpp/src/qpid/cluster/UpdateClient.cpp
index 1b74015..6499519 100644
--- a/qpid/cpp/src/qpid/cluster/UpdateClient.cpp
+++ b/qpid/cpp/src/qpid/cluster/UpdateClient.cpp
@@ -73,11 +73,22 @@ using namespace framing;
 namespace arg=client::arg;
 using client::SessionBase_0_10Access;
 
-struct ClusterConnectionProxy : public AMQP_AllProxy::ClusterConnection {
+struct ClusterConnectionProxy : public AMQP_AllProxy::ClusterConnection, public framing::FrameHandler 
+{
+    boost::shared_ptr<qpid::client::ConnectionImpl> connection;
+
     ClusterConnectionProxy(client::Connection c) :
-        AMQP_AllProxy::ClusterConnection(*client::ConnectionAccess::getImpl(c)) {}
+        AMQP_AllProxy::ClusterConnection(*static_cast<framing::FrameHandler*>(this)),
+        connection(client::ConnectionAccess::getImpl(c)) {}
     ClusterConnectionProxy(client::AsyncSession s) :
         AMQP_AllProxy::ClusterConnection(SessionBase_0_10Access(s).get()->out) {}
+
+    void handle(framing::AMQFrame& f)
+    {
+        assert(connection);
+        connection->expand(f.encodedSize(), false);
+        connection->handle(f);
+    }
 };
 
 // Create a connection with special version that marks it as a catch-up connection.
@@ -153,6 +164,7 @@ void UpdateClient::update() {
     ClusterConnectionMembershipBody membership;
     map.toMethodBody(membership);
     AMQFrame frame(membership);
+    client::ConnectionAccess::getImpl(connection)->expand(frame.encodedSize(), false);
     client::ConnectionAccess::getImpl(connection)->handle(frame);
 
     connection.close();
diff --git a/qpid/cpp/src/tests/cluster_test.cpp b/qpid/cpp/src/tests/cluster_test.cpp
index 8c18e57..d5f2c45 100644
--- a/qpid/cpp/src/tests/cluster_test.cpp
+++ b/qpid/cpp/src/tests/cluster_test.cpp
@@ -124,6 +124,7 @@ class Sender {
         f.setLastSegment(lastSeg);
         f.setFirstFrame(firstFrame);
         f.setLastFrame(lastFrame);
+        connection->expand(f.encodedSize(), false);
         connection->handle(f);
     }
 
@@ -209,6 +210,7 @@ QPID_AUTO_TEST_CASE(testBadClientData) {
     boost::shared_ptr<client::ConnectionImpl> ci =
         client::ConnectionAccess::getImpl(c0.connection);
     AMQFrame poison(boost::intrusive_ptr<AMQBody>(new PoisonPill));
+    ci->expand(poison.encodedSize(), false);
     ci->handle(poison);
     {
         ScopedSuppressLogging sl;
-- 
1.5.5.6

From 939a12c7d1f3fc56f328a23e496a87514f7bd42d Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Thu, 27 May 2010 20:02:18 +0000
Subject: [PATCH] Bug 558526: Fix issues with cluster+security

- was using "none" not empty string for no ID.
- was multicasting secure id for update and shadow connections.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@948967 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit e41664eafd017f9eb9c675f573c4ae75eb476402)
---
 qpid/cpp/src/qpid/broker/ConnectionHandler.cpp |   17 ++++++-------
 qpid/cpp/src/qpid/broker/ConnectionHandler.h   |    7 +----
 qpid/cpp/src/qpid/cluster/Connection.cpp       |   30 ++++++++++++------------
 3 files changed, 24 insertions(+), 30 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp b/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
index b2d4210..bf1af2f 100644
--- a/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
+++ b/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
@@ -181,14 +181,6 @@ void ConnectionHandler::Handler::tuneOk(uint16_t /*channelmax*/,
     connection.setHeartbeatInterval(heartbeat);
 }
 
-void ConnectionHandler::Handler::callUserIdCallbacks ( ) {
-    string s;
-    if ( false == authenticator->getUsername(s) )
-        s = "none";
-    if ( userIdCallback )
-      userIdCallback ( s );
-}
-
 void ConnectionHandler::Handler::open(const string& /*virtualHost*/,
                                       const framing::Array& /*capabilities*/, bool /*insist*/)
 {
@@ -204,7 +196,14 @@ void ConnectionHandler::Handler::open(const string& /*virtualHost*/,
         if (sl.get()) secured->activateSecurityLayer(sl);
     }
 
-    callUserIdCallbacks ( );
+    if ( userIdCallback ) {
+        string s;
+        // Not checking the return value of getUsername, if there is
+        // no username then we want to call the userIdCallback anyway
+        // with an empty string.
+        authenticator->getUsername(s);
+        userIdCallback(s);
+    }
 }
 
 
diff --git a/qpid/cpp/src/qpid/broker/ConnectionHandler.h b/qpid/cpp/src/qpid/broker/ConnectionHandler.h
index 0372942..ecc8868 100644
--- a/qpid/cpp/src/qpid/broker/ConnectionHandler.h
+++ b/qpid/cpp/src/qpid/broker/ConnectionHandler.h
@@ -68,12 +68,7 @@ class ConnectionHandler : public framing::FrameHandler
         void closeOk();
 
         UserIdCallback userIdCallback;
-        void setUserIdCallback ( UserIdCallback fn ) {
-                 userIdCallback = fn;
-             };
-
-
-        void callUserIdCallbacks ( );
+        void setUserIdCallback ( UserIdCallback fn ) { userIdCallback = fn; };
 
 
         void start(const qpid::framing::FieldTable& serverProperties,
diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index d7e5ee5..18d0e0e 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -620,26 +620,26 @@ void Connection::managementAgents(const std::string& data) {
 }
 
 
-// Only the direct, non-shadow gets this call.
 void Connection::mcastUserId ( std::string & id ) {
-    cluster.getMulticast().mcastControl( ClusterConnectionSecureUserIdBody(ProtocolVersion(), string(id)), getId() );
-
-  {
-      sys::Mutex::ScopedLock l(connectionNegotiationMonitor);
-      inConnectionNegotiation = false;
-      mcastSentButNotReceived = false;
-      connectionNegotiationMonitor.notify();
-  }
+    // Only the directly connected broker will mcast the secure user id, and only
+    // for client connections (not update connections)
+    if (isLocalClient())
+        cluster.getMulticast().mcastControl(
+            ClusterConnectionSecureUserIdBody(ProtocolVersion(), string(id)), getId() );
+    {
+        // This call signals the end of the connection negotiation phase.
+        sys::Mutex::ScopedLock l(connectionNegotiationMonitor);
+        inConnectionNegotiation = false;
+        mcastSentButNotReceived = false;
+        connectionNegotiationMonitor.notify();
+    }
 }
 
 // All connections, shadow or not, get this call.
 void Connection::secureUserId(const std::string& id) {
-    if ( isShadow() ) {
-        // If the user ID is "none", it is not legitimate.  Take no action.
-        if ( strcmp ( id.c_str(), "none" ) ) {
-            connection->setUserId ( id );
-        }
-    }
+    // Only set the user ID on shadow connections, and only if id is not the empty string.
+    if ( isShadow() && !id.empty() )
+        connection->setUserId ( id );
 }
 
 
-- 
1.5.5.6

From 20d5d896b2ae01b717fc8c70ce67a95e6fb2c737 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@redhat.com>
Date: Thu, 27 May 2010 17:15:35 -0400
Subject: [PATCH] Bug 558526: Fixed: authentication with bad credentials causes cluster broker to exit.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@948969 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 148033c59cf1b1f36ec4e80eef6e5c9beb65577b)
---
 qpid/cpp/src/qpid/cluster/Connection.cpp |   14 ++++++++++++--
 1 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index 18d0e0e..0772215 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -573,12 +573,22 @@ void Connection::queue(const std::string& encoded) {
 }
 
 void Connection::sessionError(uint16_t , const std::string& msg) {
-    cluster.flagError(*this, ERROR_TYPE_SESSION, msg);
+    // If we are negotiating the connection when it fails just close the connectoin.
+    // If it fails after that then we have to flag the error to the cluster.
+    if (inConnectionNegotiation)
+        cluster.getMulticast().mcastControl(ClusterConnectionDeliverCloseBody(), self);
+    else
+        cluster.flagError(*this, ERROR_TYPE_SESSION, msg);
     
 }
 
 void Connection::connectionError(const std::string& msg) {
-    cluster.flagError(*this, ERROR_TYPE_CONNECTION, msg);
+    // If we are negotiating the connection when it fails just close the connectoin.
+    // If it fails after that then we have to flag the error to the cluster.
+    if (inConnectionNegotiation)
+        cluster.getMulticast().mcastControl(ClusterConnectionDeliverCloseBody(), self);
+    else
+        cluster.flagError(*this, ERROR_TYPE_CONNECTION, msg);
 }
 
 void Connection::addQueueListener(const std::string& q, uint32_t listener) {
-- 
1.5.5.6

From bebf319d41b4f4abb9cd3b6cbb3af0183d249825 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Fri, 28 May 2010 13:37:22 +0000
Subject: [PATCH] BZ-591420: C++ clients on windows hang at program end

QPID-2598: Prevent exit hang on windows (at the expense of intermittent leak on exit under linux)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@949176 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 23ce1e7140ce5dd66788a0af066f3f12893046ac)
---
 qpid/cpp/src/qpid/client/ConnectionImpl.cpp |   18 ++++++++----------
 1 files changed, 8 insertions(+), 10 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/ConnectionImpl.cpp b/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
index 99f4411..8848554 100644
--- a/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
+++ b/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
@@ -83,7 +83,6 @@ class IOThread {
     int ioThreads;
     int connections;
     Mutex threadLock;
-    Condition noConnections;
     std::vector<Thread> t;
     Poller::shared_ptr poller_;
 
@@ -103,8 +102,6 @@ public:
     void sub() {
         ScopedLock<Mutex> l(threadLock);
         --connections;
-        if (connections == 0)
-            noConnections.notifyAll();
     }
 
     Poller::shared_ptr poller() const {
@@ -128,14 +125,15 @@ public:
     // and we can't do that before we're unloaded as we can't
     // restart the Poller after shutting it down
     ~IOThread() {
-        ScopedLock<Mutex> l(threadLock);
-        while (connections > 0) {
-            noConnections.wait(threadLock);
+        std::vector<Thread> threads;
+        {
+            ScopedLock<Mutex> l(threadLock);
+            if (poller_)
+                poller_->shutdown();
+            t.swap(threads);
         }
-        if (poller_)
-            poller_->shutdown();
-        for (int i=0; i<ioThreads; ++i) {
-            t[i].join();
+        for (std::vector<Thread>::iterator i = threads.begin(); i != threads.end(); ++i) {
+            i->join();
         }
     }
 };
-- 
1.5.5.6

From ad3a7e4927edc01a262a0ee3903f55592b41d337 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Mon, 31 May 2010 15:14:54 +0000
Subject: [PATCH] Bug 597362 Sporadic failure of check-long in cluster_tests.py test_failover.

Fixed assertion error in cluster_tests.py test_failover.

Added missing call to expandd in cluster/RetractClient.cpp

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@949767 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 866d10b0fdd44c6df8ea8fd2f497b1bc28fc432d)
---
 qpid/cpp/src/qpid/cluster/Connection.cpp    |    2 +-
 qpid/cpp/src/qpid/cluster/RetractClient.cpp |    1 +
 2 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index 0772215..43a4793 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -439,7 +439,7 @@ void Connection::membership(const FieldTable& joiners, const FieldTable& members
 }
 
 void Connection::retractOffer() {
-    QPID_LOG(debug, cluster << " incoming update retracted on connection " << *this);
+    QPID_LOG(info, cluster << " incoming update retracted on connection " << *this);
     cluster.updateInRetracted();
     self.second = 0;        // Mark this as completed update connection.
 }
diff --git a/qpid/cpp/src/qpid/cluster/RetractClient.cpp b/qpid/cpp/src/qpid/cluster/RetractClient.cpp
index 7d9f52f..a8c4b0d 100644
--- a/qpid/cpp/src/qpid/cluster/RetractClient.cpp
+++ b/qpid/cpp/src/qpid/cluster/RetractClient.cpp
@@ -52,6 +52,7 @@ void RetractClient::run() {
         c.open(url, connectionSettings);
         AutoClose ac(c);
         AMQFrame retract((ClusterConnectionRetractOfferBody()));
+        client::ConnectionAccess::getImpl(c)->expand(retract.encodedSize(), false);
         client::ConnectionAccess::getImpl(c)->handle(retract);
     } catch (const std::exception& e) {
         QPID_LOG(error, " while retracting retract to " << url << ": " << e.what()); 
-- 
1.5.5.6

From 93c3927ec66f0c98332286fe36a93d9ab0c2a752 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Fri, 28 May 2010 14:10:57 +0000
Subject: [PATCH] BZ-598350 - Fixed compilation error on windows

Fix compilation error on windows

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@949182 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 3453f90ba58b5036cb48210ed38883261bec1304)
---
 qpid/cpp/src/qpid/client/ConnectionHandler.cpp |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/ConnectionHandler.cpp b/qpid/cpp/src/qpid/client/ConnectionHandler.cpp
index 6aea4c4..ba15e63 100644
--- a/qpid/cpp/src/qpid/client/ConnectionHandler.cpp
+++ b/qpid/cpp/src/qpid/client/ConnectionHandler.cpp
@@ -72,7 +72,7 @@ CloseCode ConnectionHandler::convert(uint16_t replyCode)
 }
 
 ConnectionHandler::Adapter::Adapter(ConnectionHandler& h, Bounds& b) : handler(h), bounds(b) {}
-void ConnectionHandler::Adapter::handle(framing::AMQFrame& f)
+void ConnectionHandler::Adapter::handle(qpid::framing::AMQFrame& f)
 { 
     bounds.expand(f.encodedSize(), false);
     handler.out(f);
-- 
1.5.5.6

From 7f006841387b54cb0165cfa6d1423cd3fae06ce2 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Tue, 1 Jun 2010 09:25:23 +0000
Subject: [PATCH] BZ-597066

Don't use guest/guest default username/password, use None instead (this allows sasl implementation to infer the correct choice while retaining the ability to override it should that be desired)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@949971 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 5d7e22ba6f96a800a0af166559bea35652665951)
---
 qpid/python/qpid/messaging/endpoints.py |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/qpid/python/qpid/messaging/endpoints.py b/qpid/python/qpid/messaging/endpoints.py
index 3016543..f5f957c 100644
--- a/qpid/python/qpid/messaging/endpoints.py
+++ b/qpid/python/qpid/messaging/endpoints.py
@@ -127,8 +127,8 @@ class Connection:
     else:
       self.port = default(url.port, options.get("port", AMQP_PORT))
     self.heartbeat = options.get("heartbeat")
-    self.username = default(url.user, options.get("username", "guest"))
-    self.password = default(url.password, options.get("password", "guest"))
+    self.username = default(url.user, options.get("username", None))
+    self.password = default(url.password, options.get("password", None))
 
     self.sasl_mechanisms = options.get("sasl_mechanisms")
     self.sasl_service = options.get("sasl_service", "qpidd")
-- 
1.5.5.6

From c9a6a956b126ccc27e03cb32cea269cc3a0b495f Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Tue, 1 Jun 2010 18:54:56 +0000
Subject: [PATCH] BZ-591650

QPID-2636: Ensure close is called for a disconnect preventing occasional leaks of abruptly terminated connections

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950201 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit fff0a43d69db6e62f1a21d52f752bf59c35fbd2a)
---
 qpid/cpp/src/qpid/sys/AsynchIOHandler.cpp |   11 +++++------
 qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp  |   10 +++-------
 2 files changed, 8 insertions(+), 13 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/AsynchIOHandler.cpp b/qpid/cpp/src/qpid/sys/AsynchIOHandler.cpp
index 5771141..30a87d9 100644
--- a/qpid/cpp/src/qpid/sys/AsynchIOHandler.cpp
+++ b/qpid/cpp/src/qpid/sys/AsynchIOHandler.cpp
@@ -173,9 +173,8 @@ void AsynchIOHandler::readbuff(AsynchIO& , AsynchIO::BufferBase* buff) {
     }
 }
 
-void AsynchIOHandler::eof(AsynchIO&) {
-    QPID_LOG(debug, "DISCONNECTED [" << identifier << "]");
-    if (codec) codec->closed();
+void AsynchIOHandler::eof(AsynchIO& a) {
+    disconnect(a);
     readError = true;
     aio->queueWriteClose();
 }
@@ -190,9 +189,9 @@ void AsynchIOHandler::closedSocket(AsynchIO&, const Socket& s) {
     delete this;
 }
 
-void AsynchIOHandler::disconnect(AsynchIO& a) {
-    // treat the same as eof
-    eof(a);
+void AsynchIOHandler::disconnect(AsynchIO&) {
+    QPID_LOG(debug, "DISCONNECTED [" << identifier << "]");
+    if (codec) codec->closed();
 }
 
 // Notifications
diff --git a/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp b/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp
index fd78861..cef9f1f 100644
--- a/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp
+++ b/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp
@@ -554,13 +554,9 @@ void AsynchIO::writeable(DispatchHandle& h) {
 }
         
 void AsynchIO::disconnected(DispatchHandle& h) {
-    // If we've already queued close do it instead of disconnected callback
-    if (queuedClose) {
-        close(h);
-    } else if (disCallback) {
-        disCallback(*this);
-        h.unwatch();
-    }
+    // If we have not already queued close then call disconnected callback before closing
+    if (!queuedClose && disCallback) disCallback(*this);
+    close(h);
 }
 
 /*
-- 
1.5.5.6

From 01a4cfaf9b3a3c5539f80f301722852d6ae37425 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Tue, 1 Jun 2010 18:59:52 +0000
Subject: [PATCH] BZ-598597 (fix client leaks on linux)

QPID-2004: Send disconnected event to any handles still registered after shutdown to ensure they can clean themselves up

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950205 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 292347fdbd7ef8e204ff3486b21497f33bff50fd)
---
 qpid/cpp/src/qpid/cluster/PollerDispatch.cpp |    6 ++-
 qpid/cpp/src/qpid/sys/Poller.h               |    2 +
 qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp  |   46 ++++++++++++++++++++++++++
 qpid/cpp/src/qpid/sys/solaris/ECFPoller.cpp  |    5 +++
 qpid/cpp/src/qpid/sys/windows/IocpPoller.cpp |    5 +++
 5 files changed, 62 insertions(+), 2 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/PollerDispatch.cpp b/qpid/cpp/src/qpid/cluster/PollerDispatch.cpp
index a839ef8..b8d94b9 100644
--- a/qpid/cpp/src/qpid/cluster/PollerDispatch.cpp
+++ b/qpid/cpp/src/qpid/cluster/PollerDispatch.cpp
@@ -60,8 +60,10 @@ void PollerDispatch::dispatch(sys::DispatchHandle& h) {
 
 // Entry point: called if disconnected from  CPG.
 void PollerDispatch::disconnect(sys::DispatchHandle& ) {
-    QPID_LOG(critical, "Disconnected from cluster");
-    onError();
+    if (!poller->hasShutdown()) {
+        QPID_LOG(critical, "Disconnected from cluster");
+        onError();
+    }
 }
 
 }} // namespace qpid::cluster
diff --git a/qpid/cpp/src/qpid/sys/Poller.h b/qpid/cpp/src/qpid/sys/Poller.h
index 413d424..47b7606 100644
--- a/qpid/cpp/src/qpid/sys/Poller.h
+++ b/qpid/cpp/src/qpid/sys/Poller.h
@@ -99,6 +99,8 @@ public:
     QPID_COMMON_EXTERN void monitorHandle(PollerHandle& handle, Direction dir);
     QPID_COMMON_EXTERN void unmonitorHandle(PollerHandle& handle, Direction dir);
     QPID_COMMON_EXTERN Event wait(Duration timeout = TIME_INFINITE);
+
+    QPID_COMMON_EXTERN bool hasShutdown();
 };
 
 /**
diff --git a/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp b/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp
index 7b0d0aa..9ae9bce 100644
--- a/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp
+++ b/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp
@@ -22,6 +22,7 @@
 #include "qpid/sys/Poller.h"
 #include "qpid/sys/IOHandle.h"
 #include "qpid/sys/Mutex.h"
+#include "qpid/sys/AtomicCount.h"
 #include "qpid/sys/DeletionManager.h"
 #include "qpid/sys/posix/check.h"
 #include "qpid/sys/posix/PrivatePosix.h"
@@ -33,6 +34,7 @@
 
 #include <assert.h>
 #include <queue>
+#include <set>
 #include <exception>
 
 namespace qpid {
@@ -156,6 +158,37 @@ PollerHandle::~PollerHandle() {
     PollerHandleDeletionManager.markForDeletion(impl);
 }
 
+class HandleSet
+{
+    Mutex lock;
+    std::set<PollerHandle*> handles;
+  public:
+    void add(PollerHandle*);
+    void remove(PollerHandle*);
+    void cleanup();
+};
+
+void HandleSet::add(PollerHandle* h)
+{
+    ScopedLock<Mutex> l(lock);
+    handles.insert(h);
+}
+void HandleSet::remove(PollerHandle* h)
+{
+    ScopedLock<Mutex> l(lock);
+    handles.erase(h);
+}
+void HandleSet::cleanup()
+{
+    // Inform all registered handles of disconnection
+    std::set<PollerHandle*> copy;
+    handles.swap(copy);
+    for (std::set<PollerHandle*>::const_iterator i = copy.begin(); i != copy.end(); ++i) {
+        Poller::Event event(*i, Poller::DISCONNECTED);
+        event.process();
+    }
+}
+
 /**
  * Concrete implementation of Poller to use the Linux specific epoll
  * interface
@@ -230,6 +263,8 @@ class PollerPrivate {
     bool isShutdown;
     InterruptHandle interruptHandle;
     ::sigset_t sigMask;
+    HandleSet registeredHandles;
+    AtomicCount threadCount;
 
     static ::__uint32_t directionToEpollEvent(Poller::Direction dir) {
         switch (dir) {
@@ -308,6 +343,7 @@ void Poller::registerHandle(PollerHandle& handle) {
     epe.data.u64 = 0; // Keep valgrind happy
     epe.data.ptr = &eh;
 
+    impl->registeredHandles.add(&handle);
     QPID_POSIX_CHECK(::epoll_ctl(impl->epollFd, EPOLL_CTL_ADD, eh.fd(), &epe));
 
     eh.setActive();
@@ -318,6 +354,7 @@ void Poller::unregisterHandle(PollerHandle& handle) {
     ScopedLock<Mutex> l(eh.lock);
     assert(!eh.isIdle());
 
+    impl->registeredHandles.remove(&handle);
     int rc = ::epoll_ctl(impl->epollFd, EPOLL_CTL_DEL, eh.fd(), 0);
     // Ignore EBADF since deleting a nonexistent fd has the overall required result!
     // And allows the case where a sloppy program closes the fd and then does the delFd()
@@ -475,6 +512,7 @@ void Poller::run() {
         ::sigfillset(&ss);
         ::pthread_sigmask(SIG_SETMASK, &ss, 0);
 
+        ++(impl->threadCount);
         do {
             Event event = wait();
 
@@ -486,6 +524,8 @@ void Poller::run() {
                 switch (event.type) {
                 case SHUTDOWN:
                     PollerHandleDeletionManager.destroyThreadState();
+                    //last thread to respond to shutdown cleans up:
+                    if (--(impl->threadCount) == 0) impl->registeredHandles.cleanup();
                     return;
                 default:
                     // This should be impossible
@@ -497,6 +537,12 @@ void Poller::run() {
         QPID_LOG(error, "IO worker thread exiting with unhandled exception: " << e.what());
     }
     PollerHandleDeletionManager.destroyThreadState();
+    --(impl->threadCount);
+}
+
+bool Poller::hasShutdown()
+{
+    return impl->isShutdown;
 }
 
 Poller::Event Poller::wait(Duration timeout) {
diff --git a/qpid/cpp/src/qpid/sys/solaris/ECFPoller.cpp b/qpid/cpp/src/qpid/sys/solaris/ECFPoller.cpp
index f12012c..06d542c 100644
--- a/qpid/cpp/src/qpid/sys/solaris/ECFPoller.cpp
+++ b/qpid/cpp/src/qpid/sys/solaris/ECFPoller.cpp
@@ -293,6 +293,11 @@ void Poller::shutdown() {
     impl->interrupt();
 }
 
+bool Poller::hasShutdown()
+{
+    return impl->isShutdown;
+}
+
 bool Poller::interrupt(PollerHandle& handle) {
     PollerPrivate::InterruptHandle& ih = impl->interruptHandle;
     PollerHandlePrivate& eh = *static_cast<PollerHandle&>(ih).impl;
diff --git a/qpid/cpp/src/qpid/sys/windows/IocpPoller.cpp b/qpid/cpp/src/qpid/sys/windows/IocpPoller.cpp
index 4fcc915..d326ab0 100755
--- a/qpid/cpp/src/qpid/sys/windows/IocpPoller.cpp
+++ b/qpid/cpp/src/qpid/sys/windows/IocpPoller.cpp
@@ -100,6 +100,11 @@ void Poller::shutdown() {
     PostQueuedCompletionStatus(impl->iocp, 0, key, 0);
 }
 
+bool Poller::hasShutdown()
+{
+    return impl->isShutdown;
+}
+
 bool Poller::interrupt(PollerHandle&) {
     return false;  // There's no concept of a registered handle.
 }
-- 
1.5.5.6

From 9e7d9497b8665b51075ddcfd1d01d805f009f78b Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 2 Jun 2010 10:24:10 +0000
Subject: [PATCH] Bug 538188 - Fixed connection.start() hangs if connection is not accepted

QPID-2637: Mark connection as failed if read from socket fails

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950472 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit ee264c0fdaede4c4fee624b289aad475c9bd31b0)
---
 qpid/python/qpid/connection.py |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/python/qpid/connection.py b/qpid/python/qpid/connection.py
index 2c61e5a..7dbefb8 100644
--- a/qpid/python/qpid/connection.py
+++ b/qpid/python/qpid/connection.py
@@ -132,6 +132,7 @@ class Connection(Framer):
 
   def detach_all(self):
     self.lock.acquire()
+    self.failed = True
     try:
       for ssn in self.attached.values():
         if self.close_code[0] != 200:
-- 
1.5.5.6

From e61456d966e7f4d35aaf9a0e04d2f4d5142c7ae3 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 2 Jun 2010 10:39:10 +0000
Subject: [PATCH] Bug 596907 - Fixed Default behaviour of new messaging client is to retry forever

QPID-664: Changed default for reconnect to false as that is more intuitive (e.g. when you specify the wrong broker address to start with)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950480 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit d5632b8d700ac1fdec1c9d380f6478c59f7a7f1b)
---
 .../src/qpid/client/amqp0_10/ConnectionImpl.cpp    |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp b/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp
index 58f4f2a..f93df90 100644
--- a/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp
+++ b/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp
@@ -111,7 +111,7 @@ void convert(const Variant::Map& from, ConnectionSettings& to)
 }
 
 ConnectionImpl::ConnectionImpl(const std::string& url, const Variant::Map& options) : 
-    reconnect(true), timeout(-1), limit(-1),
+    reconnect(false), timeout(-1), limit(-1),
     minReconnectInterval(3), maxReconnectInterval(60),
     retries(0), reconnectOnLimitExceeded(true)
 {
-- 
1.5.5.6

From b63360247ac0a9a8faf5a47c2dc4c53e079125c0 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Wed, 2 Jun 2010 15:49:49 +0000
Subject: [PATCH] Bug 598516: Fixed sporadic client "reserved bits not 0" exceptions with cluster + encryption.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950608 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit e15ce475ce200560b650f8d6c512ffdaa42e76f5)
---
 qpid/cpp/src/qpid/broker/ConnectionHandler.cpp |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp b/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
index bf1af2f..225735d 100644
--- a/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
+++ b/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
@@ -188,7 +188,6 @@ void ConnectionHandler::Handler::open(const string& /*virtualHost*/,
     framing::Array array(0x95); // str16 array
     for (std::vector<Url>::iterator i = urls.begin(); i < urls.end(); ++i)
         array.add(boost::shared_ptr<Str16Value>(new Str16Value(i->str())));
-    proxy.openOk(array);
 
     //install security layer if one has been negotiated:
     if (secured) {
@@ -204,6 +203,7 @@ void ConnectionHandler::Handler::open(const string& /*virtualHost*/,
         authenticator->getUsername(s);
         userIdCallback(s);
     }
+    proxy.openOk(array);
 }
 
 
-- 
1.5.5.6

From 548ca3db11f4ce05063393bf402e4467684ca624 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 2 Jun 2010 19:45:34 +0000
Subject: [PATCH] BZ-598597: Relax cluster assertions, necessitated by previous fix for leaks.

QPID-2004: Now that connections are cleaned up on shutdown, some cluster safety assertions need to be relaxed.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950735 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 7776e2efa144a6179311a8e95e27c298a233d494)
---
 qpid/cpp/src/qpid/broker/Queue.cpp         |    1 -
 qpid/cpp/src/qpid/broker/SemanticState.cpp |    2 --
 2 files changed, 0 insertions(+), 3 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Queue.cpp b/qpid/cpp/src/qpid/broker/Queue.cpp
index 42c678c..8c9e5b8 100644
--- a/qpid/cpp/src/qpid/broker/Queue.cpp
+++ b/qpid/cpp/src/qpid/broker/Queue.cpp
@@ -374,7 +374,6 @@ bool Queue::browseNextMessage(QueuedMessage& m, Consumer::shared_ptr c)
 
 void Queue::removeListener(Consumer::shared_ptr c)
 {
-    assertClusterSafe();
     QueueListeners::NotificationSet set;
     {
         Mutex::ScopedLock locker(messageLock);
diff --git a/qpid/cpp/src/qpid/broker/SemanticState.cpp b/qpid/cpp/src/qpid/broker/SemanticState.cpp
index e85d835..b8981b4 100644
--- a/qpid/cpp/src/qpid/broker/SemanticState.cpp
+++ b/qpid/cpp/src/qpid/broker/SemanticState.cpp
@@ -391,7 +391,6 @@ SemanticState::ConsumerImpl::~ConsumerImpl()
 
 void SemanticState::cancel(ConsumerImpl::shared_ptr c)
 {
-    assertClusterSafe();
     c->disableNotify();
     if (session.isAttached())
         session.getConnection().outputTasks.removeOutputTask(c.get());
@@ -698,7 +697,6 @@ void SemanticState::ConsumerImpl::enableNotify()
 void SemanticState::ConsumerImpl::disableNotify()
 {
     Mutex::ScopedLock l(lock);
-    assertClusterSafe();
     notifyEnabled = false;
 }
 
-- 
1.5.5.6

From b90d8b5e0fa2723dfb16c8d7b597d906e447b762 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Thu, 3 Jun 2010 10:07:23 +0000
Subject: [PATCH] Bug 599470 - Fixed - options string for connection does not work for some types

QPID-2640: Don't try to cast integer-like values during parsing; leave as strings and let the usage context determine the correct type to cast to.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950932 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit a1d95779da866899f1bdc0a2dd00f21dc131defb)
---
 qpid/cpp/src/qpid/messaging/AddressParser.cpp |    3 ---
 1 files changed, 0 insertions(+), 3 deletions(-)

diff --git a/qpid/cpp/src/qpid/messaging/AddressParser.cpp b/qpid/cpp/src/qpid/messaging/AddressParser.cpp
index 4f22410..aea9118 100644
--- a/qpid/cpp/src/qpid/messaging/AddressParser.cpp
+++ b/qpid/cpp/src/qpid/messaging/AddressParser.cpp
@@ -200,9 +200,6 @@ bool AddressParser::readSimpleValue(Variant& value)
     std::string s;
     if (readWord(s)) {
         value = s;
-        try { value = value.asInt32(); return true; } catch (const InvalidConversion&) {}
-        try { value = value.asInt64(); return true; } catch (const InvalidConversion&) {}
-        try { value = value.asDouble(); return true; } catch (const InvalidConversion&) {}
         return true;
     } else {
         return false;
-- 
1.5.5.6

From fec18359ad3c942fb2168bfbfdbe0c43e071fb27 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Wed, 2 Jun 2010 21:21:38 +0000
Subject: [PATCH] Fix error string for invalid options, fix exception handling in qpid_send/qpid_receive.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950763 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 7bbadfd55b56d1917c6b3f62601aedcc07ad2018)
---
 qpid/cpp/src/qpid/messaging/Connection.cpp |    2 +-
 qpid/cpp/src/tests/qpid_receive.cpp        |   19 ++++++++++---------
 qpid/cpp/src/tests/qpid_send.cpp           |   15 ++++++++-------
 3 files changed, 19 insertions(+), 17 deletions(-)

diff --git a/qpid/cpp/src/qpid/messaging/Connection.cpp b/qpid/cpp/src/qpid/messaging/Connection.cpp
index 53d3756..2bd5ba9 100644
--- a/qpid/cpp/src/qpid/messaging/Connection.cpp
+++ b/qpid/cpp/src/qpid/messaging/Connection.cpp
@@ -46,7 +46,7 @@ Connection::Connection(const std::string& url, const std::string& o)
     if (o.empty() || parser.parseMap(options)) {
         PI::ctor(*this, new qpid::client::amqp0_10::ConnectionImpl(url, options));
     } else {
-        throw InvalidOptionString(o);
+        throw InvalidOptionString("Invalid option string: " + o);
     }
 }
 Connection::Connection(const std::string& url, const Variant::Map& options)
diff --git a/qpid/cpp/src/tests/qpid_receive.cpp b/qpid/cpp/src/tests/qpid_receive.cpp
index 15b8d76..294a60b 100644
--- a/qpid/cpp/src/tests/qpid_receive.cpp
+++ b/qpid/cpp/src/tests/qpid_receive.cpp
@@ -103,7 +103,7 @@ struct Options : public qpid::Options
             ("report-total", qpid::optValue(reportTotal), "Report total throughput and latency statistics")
             ("report-every", qpid::optValue(reportEvery,"N"), "Report throughput and latency statistics every N messages.")
             ("report-header", qpid::optValue(reportHeader, "yes|no"), "Headers on report.")            ("ready-address", qpid::optValue(readyAddress, "ADDRESS"),
-             "send a message to this address when ready to receive")
+                                                                                                        "send a message to this address when ready to receive")
             ("help", qpid::optValue(help), "print this usage statement");
         add(log);
     }
@@ -162,10 +162,11 @@ using namespace qpid::tests;
 
 int main(int argc, char ** argv)
 {
-    Options opts;
-    if (opts.parse(argc, argv)) {
-        Connection connection(opts.url, opts.connectionOptions);
-        try {
+    Connection connection;
+    try {
+        Options opts;
+        if (opts.parse(argc, argv)) {
+            connection = Connection(opts.url, opts.connectionOptions);
             connection.open();
             std::auto_ptr<FailoverUpdates> updates(opts.failoverUpdates ? new FailoverUpdates(connection) : 0);
             Session session = opts.tx ? connection.createTransactionalSession() : connection.createSession();
@@ -227,10 +228,10 @@ int main(int argc, char ** argv)
             session.close();
             connection.close();
             return 0;
-        } catch(const std::exception& error) {
-            std::cerr << "Failure: " << error.what() << std::endl;
-            connection.close();
         }
+    } catch(const std::exception& error) {
+        std::cerr << "Failure: " << error.what() << std::endl;
+        connection.close();
+        return 1;
     }
-    return 1;
 }
diff --git a/qpid/cpp/src/tests/qpid_send.cpp b/qpid/cpp/src/tests/qpid_send.cpp
index 7fef57a..98d7cd6 100644
--- a/qpid/cpp/src/tests/qpid_send.cpp
+++ b/qpid/cpp/src/tests/qpid_send.cpp
@@ -247,10 +247,11 @@ class MapContentGenerator   : public ContentGenerator {
 
 int main(int argc, char ** argv)
 {
+    Connection connection;
     Options opts;
-    if (opts.parse(argc, argv)) {
-        Connection connection(opts.url, opts.connectionOptions);
-        try {
+    try {
+        if (opts.parse(argc, argv)) {
+             connection = Connection(opts.url, opts.connectionOptions);
             connection.open();
             std::auto_ptr<FailoverUpdates> updates(opts.failoverUpdates ? new FailoverUpdates(connection) : 0);
             Session session = opts.tx ? connection.createTransactionalSession() : connection.createSession();
@@ -327,10 +328,10 @@ int main(int argc, char ** argv)
             session.close();
             connection.close();
             return 0;
-        } catch(const std::exception& error) {
-            std::cout << "Failed: " << error.what() << std::endl;
-            connection.close();
         }
+    } catch(const std::exception& error) {
+        std::cout << "Failed: " << error.what() << std::endl;
+        connection.close();
+        return 1;
     }
-    return 1;
 }
-- 
1.5.5.6

From 4b96352abe88aa513434d59812a6d44679d2acd8 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Fri, 4 Jun 2010 15:23:32 +0000
Subject: [PATCH] Bug 589675 - Fix initialization-order problem with URL protocol tags.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@951441 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 4424bc7676367fef809d0de1fb720c1c50c6bd08)
---
 qpid/cpp/include/qpid/Url.h |    2 --
 qpid/cpp/src/qpid/Url.cpp   |   38 +++++++++++++++++++++++++++++++-------
 2 files changed, 31 insertions(+), 9 deletions(-)

diff --git a/qpid/cpp/include/qpid/Url.h b/qpid/cpp/include/qpid/Url.h
index 8093161..353e9d5 100644
--- a/qpid/cpp/include/qpid/Url.h
+++ b/qpid/cpp/include/qpid/Url.h
@@ -82,8 +82,6 @@ struct Url : public std::vector<Address> {
     QPID_COMMON_EXTERN std::string getPass() const;
 
   private:
-    static std::vector<std::string> protocols;
-
     mutable std::string cache;  // cache string form for efficiency.
     std::string user, pass;
 
diff --git a/qpid/cpp/src/qpid/Url.cpp b/qpid/cpp/src/qpid/Url.cpp
index 0b9fdbf..ab796f4 100644
--- a/qpid/cpp/src/qpid/Url.cpp
+++ b/qpid/cpp/src/qpid/Url.cpp
@@ -22,10 +22,12 @@
 #include "qpid/sys/SystemInfo.h"
 #include "qpid/sys/StrError.h"
 #include "qpid/client/Connector.h"
-
+#include "qpid/sys/Mutex.h"
 #include <boost/lexical_cast.hpp>
 
 #include <algorithm>
+#include <vector>
+#include <string>
 
 #include <string.h>
 
@@ -34,6 +36,32 @@ using boost::lexical_cast;
 
 namespace qpid {
 
+class ProtocolTags {
+  public:
+    bool find(const string& tag) {
+        sys::Mutex::ScopedLock l(lock);
+        return std::find(tags.begin(), tags.end(), tag) != tags.end();
+    }
+
+    void add(const string& tag) {
+        sys::Mutex::ScopedLock l(lock);
+        if (std::find(tags.begin(), tags.end(), tag) == tags.end())
+            tags.push_back(tag);
+    }
+
+    static ProtocolTags& instance() {
+        /** First call must be made while program is still single threaded.
+         * This will be the case since tags are registered in static initializers.
+         */
+        static ProtocolTags tags;
+        return tags;
+    }
+    
+  private:
+    sys::Mutex lock;
+    vector<string> tags;
+};
+
 Url::Invalid::Invalid(const string& s) : Exception(s) {}
 
 Url Url::getHostNameUrl(uint16_t port) {
@@ -119,9 +147,7 @@ class UrlParser {
         const char* j = std::find(i,end,':');
         if (j != end) {
             string tag(i,j);
-            if (std::find(Url::protocols.begin(), Url::protocols.end(), tag) !=
-                Url::protocols.end())
-            {
+            if (ProtocolTags::instance().find(tag)) {
                 i = j+1;
                 result = tag;
                 return true;
@@ -234,8 +260,6 @@ std::istream& operator>>(std::istream& is, Url& url) {
     return is;
 }
 
-std::vector<std::string> Url::protocols;
-
-void Url::addProtocol(const std::string& tag) { protocols.push_back(tag); }
+void Url::addProtocol(const std::string& tag) { ProtocolTags::instance().add(tag); }
 
 } // namespace qpid
-- 
1.5.5.6

From 8504208f6107251003272fec9055cc937cef5f70 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@redhat.com>
Date: Fri, 4 Jun 2010 11:43:49 -0400
Subject: [PATCH] Fixed sporadic failure of cluster_tests.py sasl_test

- added missing initializer for cluster::Connection::inConnectionNegotiation

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@951452 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 888a7d9b4d896314a4515dfb0c9f172b87e0a1cd)
---
 qpid/cpp/src/qpid/cluster/Connection.cpp |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index 43a4793..9a8cab2 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -108,7 +108,8 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
     mcastFrameHandler(cluster.getMulticast(), self),
     updateIn(c.getUpdateReceiver()),
     secureConnection(0),
-    mcastSentButNotReceived(false)
+    mcastSentButNotReceived(false),
+    inConnectionNegotiation(true)
 {
     cluster.addLocalConnection(this);
     if (isLocalClient()) {
-- 
1.5.5.6

From f2fd925d0846d940af997d9c6451404fa054a137 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Fri, 4 Jun 2010 17:36:47 -0400
Subject: [PATCH] Trivial change: Eliminate windows warning

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@951502 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/include/qpid/framing/FieldValue.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/include/qpid/framing/FieldValue.h b/qpid/cpp/include/qpid/framing/FieldValue.h
index 8af1f8d..19220e7 100644
--- a/qpid/cpp/include/qpid/framing/FieldValue.h
+++ b/qpid/cpp/include/qpid/framing/FieldValue.h
@@ -123,7 +123,7 @@ template <>
 inline bool FieldValue::convertsTo<std::string>() const { return data->convertsToString(); }
 
 template <>
-inline int FieldValue::get<int>() const { return data->getInt(); }
+inline int FieldValue::get<int>() const { return static_cast<int>(data->getInt()); }
 
 template <>
 inline int64_t FieldValue::get<int64_t>() const { return data->getInt(); }
-- 
1.5.5.6

From bb0b3b1a4014604dd951ae67e566d1ef3ecfccc1 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Fri, 4 Jun 2010 17:48:44 -0400
Subject: [PATCH] BZ 582460: Remove dependency on qpid::sys::AbsTime (which uses boost on Windows)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@951150 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/examples/messaging/spout.cpp |   12 ++++++------
 1 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/qpid/cpp/examples/messaging/spout.cpp b/qpid/cpp/examples/messaging/spout.cpp
index 05d66f6..e100560 100644
--- a/qpid/cpp/examples/messaging/spout.cpp
+++ b/qpid/cpp/examples/messaging/spout.cpp
@@ -25,19 +25,16 @@
 #include <qpid/messaging/Sender.h>
 #include <qpid/messaging/Session.h>
 #include <qpid/types/Variant.h>
-#include <qpid/sys/Time.h>
 
 #include <iostream>
 #include <sstream>
 #include <vector>
+#include <ctime>
 
 #include "OptionParser.h"
 
 using namespace qpid::messaging;
 using namespace qpid::types;
-using qpid::sys::AbsTime;
-using qpid::sys::now;
-using qpid::sys::TIME_INFINITE;
 
 typedef std::vector<std::string> string_vector;
 
@@ -152,8 +149,11 @@ int main(int argc, char** argv)
                 message.setContent(options.content);
                 message.setContentType("text/plain");
             }
-            AbsTime end(now(), options.timeout * qpid::sys::TIME_SEC);
-            for (int count = 0; (count < options.count || options.count == 0) && (options.timeout == 0 || end > now()); count++) {
+            std::time_t start = std::time(0);
+            for (int count = 0; 
+                (count < options.count || options.count == 0) && 
+                (options.timeout == 0 || std::difftime(std::time(0), start) < options.timeout); 
+                count++) {
                 if (!options.replyto.empty()) message.setReplyTo(Address(options.replyto));
                 std::string id = options.id.empty() ? Uuid(true).str() : options.id;
                 std::stringstream spoutid;
-- 
1.5.5.6

From 4dfbb074af5cd176b94ab532fa901c0b716070c1 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Fri, 4 Jun 2010 17:54:33 -0400
Subject: [PATCH] BZ 582460, BZ577274

Windows SDK work:
* Added message_drain & message_spout programs back into the SDK examples
* Modified messaging example project files to use qpidmessaging library (instead of old qpidclient lib)
* Removed all x64 configurations from the example messaging projects
  as we don't include the x64 libs in the SDK
* Put import libs in lib directory to separate them from dlls
* Removed use of BOOST_ROOT env var from example projects as no boost headers are needed by the SDK

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@951572 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/bld-winsdk.ps1                            |   19 +-
 qpid/cpp/examples/examples.sln                     |   32 +--
 .../cpp/examples/messaging/messaging_client.vcproj |  221 +++-----------------
 qpid/cpp/examples/messaging/messaging_drain.vcproj |  183 +---------------
 .../messaging/messaging_map_receiver.vcproj        |  221 +++-----------------
 .../examples/messaging/messaging_map_sender.vcproj |  221 +++-----------------
 .../cpp/examples/messaging/messaging_server.vcproj |  221 +++-----------------
 qpid/cpp/examples/messaging/messaging_spout.vcproj |  182 +---------------
 qpid/cpp/examples/old-examples.sln                 |   12 -
 9 files changed, 159 insertions(+), 1153 deletions(-)

diff --git a/qpid/cpp/bld-winsdk.ps1 b/qpid/cpp/bld-winsdk.ps1
index 3e13c18..8618160 100644
--- a/qpid/cpp/bld-winsdk.ps1
+++ b/qpid/cpp/bld-winsdk.ps1
@@ -59,11 +59,13 @@ devenv qpid-cpp.sln /build "Release|Win32" /project docs-user-api
 devenv qpid-cpp.sln /build "Debug|Win32" /project INSTALL
 devenv qpid-cpp.sln /build "Release|Win32" /project INSTALL
 
-# This is kludgy until we have more than one entry as the array declaration syntax
+# This would be kludgy if we have only one entry as the array declaration syntax
 # can't cope with just one nested array
-$move1=('bin/boost/*','bin')
-$move=@(0)
-$move[0]=$move1
+# Target must be a directory
+$move=(
+	('bin/*.lib','lib'),
+	('bin/boost/*.dll','bin')
+)
 
 $preserve=(
 	'include/qpid/agent',
@@ -77,16 +79,12 @@ $preserve=(
 $remove=(
 	'bin/qpidd.exe', 'bin/qpidbroker*.*',
 	'bin/qmfengine*.*', 'bin/qpidxarm*.*',
-	'bin/boost_regex*.*', 'bin/boost*.lib',
+	'bin/boost_regex*.*',
 	'bin/boost',
 	'conf',
 	'examples/direct',
 	'examples/failover',
 	'examples/fanout',
-	'examples/messaging/drain.cpp',
-	'examples/messaging/spout.cpp',
-	'examples/messaging/messaging_drain.vcproj',
-	'examples/messaging/messaging_spout.vcproj',
 	'examples/pub-sub',
 	'examples/qmf-console',
 	'examples/request-response',
@@ -100,8 +98,7 @@ $remove=(
 # Move some files around in the install tree
 foreach ($pattern in $move) {
 	$target = Join-Path $install_dir $pattern[1]
-	$tparent = Split-Path -parent $target
-	New-Item -force -type directory $tparent
+	New-Item -force -type directory $target
 	Move-Item -force -path "$install_dir/$($pattern[0])" -destination "$install_dir/$($pattern[1])"
 }
 # Copy aside the files to preserve
diff --git a/qpid/cpp/examples/examples.sln b/qpid/cpp/examples/examples.sln
index 14dcc34..4a26ac7 100644
--- a/qpid/cpp/examples/examples.sln
+++ b/qpid/cpp/examples/examples.sln
@@ -26,15 +26,11 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_map_receiver", "m
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_map_sender", "messaging\messaging_map_sender.vcproj", "{3B9EA507-FECA-1BAD-1FEE-AE349A6B75AA}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_queue_receiver", "messaging\messaging_queue_receiver.vcproj", "{64932FB7-FECA-1BAD-1FEE-AE349A6B75AA}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_queue_sender", "messaging\messaging_queue_sender.vcproj", "{2668EEDD-FECA-1BAD-1FEE-AE349A6B75AA}"
-EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_server", "messaging\messaging_server.vcproj", "{E0A50687-FECA-1BAD-1FEE-AE349A6B75AA}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_topic_receiver", "messaging\messaging_topic_receiver.vcproj", "{64979B71-FECA-1BAD-1FEE-AE349A6B75AA}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_drain", "messaging\messaging_drain.vcproj", "{D79791E5-C593-4F23-B545-0CE72D181F2A}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_topic_sender", "messaging\messaging_topic_sender.vcproj", "{E068EA69-FECA-1BAD-1FEE-AE349A6B75AA}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_spout", "messaging\messaging_spout.vcproj", "{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}"
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -54,26 +50,18 @@ Global
 		{3B9EA507-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.Build.0 = Debug|Win32
 		{3B9EA507-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.ActiveCfg = Release|Win32
 		{3B9EA507-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.Build.0 = Release|Win32
-		{64932FB7-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.ActiveCfg = Debug|Win32
-		{64932FB7-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.Build.0 = Debug|Win32
-		{64932FB7-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.ActiveCfg = Release|Win32
-		{64932FB7-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.Build.0 = Release|Win32
-		{2668EEDD-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.ActiveCfg = Debug|Win32
-		{2668EEDD-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.Build.0 = Debug|Win32
-		{2668EEDD-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.ActiveCfg = Release|Win32
-		{2668EEDD-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.Build.0 = Release|Win32
 		{E0A50687-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.ActiveCfg = Debug|Win32
 		{E0A50687-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.Build.0 = Debug|Win32
 		{E0A50687-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.ActiveCfg = Release|Win32
 		{E0A50687-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.Build.0 = Release|Win32
-		{64979B71-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.ActiveCfg = Debug|Win32
-		{64979B71-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.Build.0 = Debug|Win32
-		{64979B71-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.ActiveCfg = Release|Win32
-		{64979B71-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.Build.0 = Release|Win32
-		{E068EA69-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.ActiveCfg = Debug|Win32
-		{E068EA69-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.Build.0 = Debug|Win32
-		{E068EA69-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.ActiveCfg = Release|Win32
-		{E068EA69-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.Build.0 = Release|Win32
+		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Debug|Win32.Build.0 = Debug|Win32
+		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Release|Win32.ActiveCfg = Release|Win32
+		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Release|Win32.Build.0 = Release|Win32
+		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Debug|Win32.Build.0 = Debug|Win32
+		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Release|Win32.ActiveCfg = Release|Win32
+		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Release|Win32.Build.0 = Release|Win32
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff --git a/qpid/cpp/examples/messaging/messaging_client.vcproj b/qpid/cpp/examples/messaging/messaging_client.vcproj
index e2f8c26..f6e5da0 100644
--- a/qpid/cpp/examples/messaging/messaging_client.vcproj
+++ b/qpid/cpp/examples/messaging/messaging_client.vcproj
@@ -26,15 +26,12 @@
 	ProjectGUID="{80B58CBC-FECA-1BAD-1FEE-AE349A6B75AA}"
 	RootNamespace="messaging_client"
 	Keyword="Win32Proj"
-	SignManifests="true"
+	TargetFrameworkVersion="0"
 	>
 	<Platforms>
 		<Platform
 			Name="Win32"
 		/>
-		<Platform
-			Name="x64"
-		/>
 	</Platforms>
 	<ToolFiles>
 	</ToolFiles>
@@ -45,7 +42,6 @@
 			IntermediateDirectory="Debug\messaging_client\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -71,7 +67,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				MinimalRebuild="false"
 				BasicRuntimeChecks="3"
@@ -95,11 +91,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
+				AdditionalDependencies="qpidmessagingd.lib qpidcommond.lib"
 				OutputFile="$(OutDir)\client.exe"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				TargetMachine="1"
@@ -108,6 +104,9 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
 				Name="VCXDCMakeTool"
 			/>
 			<Tool
@@ -117,6 +116,9 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
@@ -126,7 +128,6 @@
 			IntermediateDirectory="Release\messaging_client\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -152,7 +153,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
@@ -173,11 +174,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
+				AdditionalDependencies="qpidmessaging.lib qpidcommon.lib"
 				OutputFile="$(OutDir)\client.exe"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				OptimizeReferences="2"
@@ -188,86 +189,7 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="."
-			IntermediateDirectory="Debug\messaging_client\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				MinimalRebuild="false"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
-				OutputFile="$(OutDir)\client.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
+				Name="VCManifestTool"
 			/>
 			<Tool
 				Name="VCXDCMakeTool"
@@ -279,85 +201,7 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="Release"
-			IntermediateDirectory="Release\messaging_client\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				RuntimeLibrary="2"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
-				OutputFile="$(OutDir)\client.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
+				Name="VCAppVerifierTool"
 			/>
 			<Tool
 				Name="VCPostBuildEventTool"
@@ -369,39 +213,34 @@
 	<Files>
 		<Filter
 			Name="Source Files"
-			Filter="cpp;cxx;cc;c;C">
+			Filter="cpp;cxx;cc;c;C"
+			>
 			<File
-				RelativePath="client.cpp">
+				RelativePath="client.cpp"
+				>
 			</File>
 		</Filter>
 		<Filter
 			Name="Documentation"
-			Filter="">
+			>
 			<File
-				RelativePath="CMakeLists.txt">
+				RelativePath="CMakeLists.txt"
+				>
 				<FileConfiguration
 					Name="Debug|Win32"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 				<FileConfiguration
 					Name="Release|Win32"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|x64"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|x64"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 			</File>
 		</Filter>
diff --git a/qpid/cpp/examples/messaging/messaging_drain.vcproj b/qpid/cpp/examples/messaging/messaging_drain.vcproj
index ea7704c..78f89d6 100644
--- a/qpid/cpp/examples/messaging/messaging_drain.vcproj
+++ b/qpid/cpp/examples/messaging/messaging_drain.vcproj
@@ -26,14 +26,12 @@
 	ProjectGUID="{D79791E5-C593-4F23-B545-0CE72D181F2A}"
 	RootNamespace="messaging_drain"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="0"
 	>
 	<Platforms>
 		<Platform
 			Name="Win32"
 		/>
-		<Platform
-			Name="x64"
-		/>
 	</Platforms>
 	<ToolFiles>
 	</ToolFiles>
@@ -63,7 +61,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				MinimalRebuild="false"
 				BasicRuntimeChecks="3"
@@ -84,11 +82,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
+				AdditionalDependencies="qpidmessagingd.lib qpidcommond.lib"
 				OutputFile="$(OutDir)\drain.exe"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				TargetMachine="1"
@@ -140,7 +138,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
@@ -158,11 +156,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
+				AdditionalDependencies="qpidmessaging.lib qpidcommon.lib"
 				OutputFile="$(OutDir)\drain.exe"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				OptimizeReferences="2"
@@ -191,169 +189,6 @@
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="."
-			IntermediateDirectory="Debug\messaging_drain\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				MinimalRebuild="false"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
-				OutputFile="$(OutDir)\drain.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="Release"
-			IntermediateDirectory="Release\messaging_drain\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				RuntimeLibrary="2"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
-				OutputFile="$(OutDir)\drain.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
 	</Configurations>
 	<References>
 	</References>
@@ -367,6 +202,10 @@
 				RelativePath="drain.cpp"
 				>
 			</File>
+			<File
+				RelativePath=".\OptionParser.cpp"
+				>
+			</File>
 		</Filter>
 	</Files>
 	<Globals>
diff --git a/qpid/cpp/examples/messaging/messaging_map_receiver.vcproj b/qpid/cpp/examples/messaging/messaging_map_receiver.vcproj
index ed806c0..a928198 100644
--- a/qpid/cpp/examples/messaging/messaging_map_receiver.vcproj
+++ b/qpid/cpp/examples/messaging/messaging_map_receiver.vcproj
@@ -26,15 +26,12 @@
 	ProjectGUID="{92D8F5AA-FECA-1BAD-1FEE-AE349A6B75AA}"
 	RootNamespace="messaging_map_receiver"
 	Keyword="Win32Proj"
-	SignManifests="true"
+	TargetFrameworkVersion="0"
 	>
 	<Platforms>
 		<Platform
 			Name="Win32"
 		/>
-		<Platform
-			Name="x64"
-		/>
 	</Platforms>
 	<ToolFiles>
 	</ToolFiles>
@@ -45,7 +42,6 @@
 			IntermediateDirectory="Debug\messaging_map_receiver\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -71,7 +67,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				MinimalRebuild="false"
 				BasicRuntimeChecks="3"
@@ -95,11 +91,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
+				AdditionalDependencies="qpidmessagingd.lib qpidcommond.lib"
 				OutputFile="$(OutDir)\map_receiver.exe"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				TargetMachine="1"
@@ -108,6 +104,9 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
 				Name="VCXDCMakeTool"
 			/>
 			<Tool
@@ -117,6 +116,9 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
@@ -126,7 +128,6 @@
 			IntermediateDirectory="Release\messaging_map_receiver\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -152,7 +153,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
@@ -173,11 +174,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
+				AdditionalDependencies="qpidmessaging.lib qpidcommon.lib"
 				OutputFile="$(OutDir)\map_receiver.exe"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				OptimizeReferences="2"
@@ -188,86 +189,7 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="."
-			IntermediateDirectory="Debug\messaging_map_receiver\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				MinimalRebuild="false"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
-				OutputFile="$(OutDir)\map_receiver.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
+				Name="VCManifestTool"
 			/>
 			<Tool
 				Name="VCXDCMakeTool"
@@ -279,85 +201,7 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="Release"
-			IntermediateDirectory="Release\messaging_map_receiver\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				RuntimeLibrary="2"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
-				OutputFile="$(OutDir)\map_receiver.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
+				Name="VCAppVerifierTool"
 			/>
 			<Tool
 				Name="VCPostBuildEventTool"
@@ -369,39 +213,34 @@
 	<Files>
 		<Filter
 			Name="Source Files"
-			Filter="cpp;cxx;cc;c;C">
+			Filter="cpp;cxx;cc;c;C"
+			>
 			<File
-				RelativePath="map_receiver.cpp">
+				RelativePath="map_receiver.cpp"
+				>
 			</File>
 		</Filter>
 		<Filter
 			Name="Documentation"
-			Filter="">
+			>
 			<File
-				RelativePath="CMakeLists.txt">
+				RelativePath="CMakeLists.txt"
+				>
 				<FileConfiguration
 					Name="Debug|Win32"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 				<FileConfiguration
 					Name="Release|Win32"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|x64"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|x64"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 			</File>
 		</Filter>
diff --git a/qpid/cpp/examples/messaging/messaging_map_sender.vcproj b/qpid/cpp/examples/messaging/messaging_map_sender.vcproj
index 55d1606..29b3114 100644
--- a/qpid/cpp/examples/messaging/messaging_map_sender.vcproj
+++ b/qpid/cpp/examples/messaging/messaging_map_sender.vcproj
@@ -26,15 +26,12 @@
 	ProjectGUID="{3B9EA507-FECA-1BAD-1FEE-AE349A6B75AA}"
 	RootNamespace="messaging_map_sender"
 	Keyword="Win32Proj"
-	SignManifests="true"
+	TargetFrameworkVersion="0"
 	>
 	<Platforms>
 		<Platform
 			Name="Win32"
 		/>
-		<Platform
-			Name="x64"
-		/>
 	</Platforms>
 	<ToolFiles>
 	</ToolFiles>
@@ -45,7 +42,6 @@
 			IntermediateDirectory="Debug\messaging_map_sender\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -71,7 +67,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				MinimalRebuild="false"
 				BasicRuntimeChecks="3"
@@ -95,11 +91,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
+				AdditionalDependencies="qpidmessagingd.lib qpidcommond.lib"
 				OutputFile="$(OutDir)\map_sender.exe"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				TargetMachine="1"
@@ -108,6 +104,9 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
 				Name="VCXDCMakeTool"
 			/>
 			<Tool
@@ -117,6 +116,9 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
@@ -126,7 +128,6 @@
 			IntermediateDirectory="Release\messaging_map_sender\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -152,7 +153,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
@@ -173,11 +174,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
+				AdditionalDependencies="qpidmessaging.lib qpidcommon.lib"
 				OutputFile="$(OutDir)\map_sender.exe"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				OptimizeReferences="2"
@@ -188,86 +189,7 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="."
-			IntermediateDirectory="Debug\messaging_map_sender\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				MinimalRebuild="false"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
-				OutputFile="$(OutDir)\map_sender.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
+				Name="VCManifestTool"
 			/>
 			<Tool
 				Name="VCXDCMakeTool"
@@ -279,85 +201,7 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="Release"
-			IntermediateDirectory="Release\messaging_map_sender\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				RuntimeLibrary="2"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
-				OutputFile="$(OutDir)\map_sender.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
+				Name="VCAppVerifierTool"
 			/>
 			<Tool
 				Name="VCPostBuildEventTool"
@@ -369,39 +213,34 @@
 	<Files>
 		<Filter
 			Name="Source Files"
-			Filter="cpp;cxx;cc;c;C">
+			Filter="cpp;cxx;cc;c;C"
+			>
 			<File
-				RelativePath="map_sender.cpp">
+				RelativePath="map_sender.cpp"
+				>
 			</File>
 		</Filter>
 		<Filter
 			Name="Documentation"
-			Filter="">
+			>
 			<File
-				RelativePath="CMakeLists.txt">
+				RelativePath="CMakeLists.txt"
+				>
 				<FileConfiguration
 					Name="Debug|Win32"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 				<FileConfiguration
 					Name="Release|Win32"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|x64"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|x64"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 			</File>
 		</Filter>
diff --git a/qpid/cpp/examples/messaging/messaging_server.vcproj b/qpid/cpp/examples/messaging/messaging_server.vcproj
index 5a4f614..38d43e7 100644
--- a/qpid/cpp/examples/messaging/messaging_server.vcproj
+++ b/qpid/cpp/examples/messaging/messaging_server.vcproj
@@ -26,15 +26,12 @@
 	ProjectGUID="{E0A50687-FECA-1BAD-1FEE-AE349A6B75AA}"
 	RootNamespace="messaging_server"
 	Keyword="Win32Proj"
-	SignManifests="true"
+	TargetFrameworkVersion="0"
 	>
 	<Platforms>
 		<Platform
 			Name="Win32"
 		/>
-		<Platform
-			Name="x64"
-		/>
 	</Platforms>
 	<ToolFiles>
 	</ToolFiles>
@@ -45,7 +42,6 @@
 			IntermediateDirectory="Debug\messaging_server\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -71,7 +67,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				MinimalRebuild="false"
 				BasicRuntimeChecks="3"
@@ -95,11 +91,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
+				AdditionalDependencies="qpidmessagingd.lib qpidcommond.lib"
 				OutputFile="$(OutDir)\server.exe"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				TargetMachine="1"
@@ -108,6 +104,9 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
 				Name="VCXDCMakeTool"
 			/>
 			<Tool
@@ -117,6 +116,9 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
@@ -126,7 +128,6 @@
 			IntermediateDirectory="Release\messaging_server\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -152,7 +153,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
@@ -173,11 +174,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
+				AdditionalDependencies="qpidmessaging.lib qpidcommon.lib"
 				OutputFile="$(OutDir)\server.exe"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				OptimizeReferences="2"
@@ -188,86 +189,7 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="."
-			IntermediateDirectory="Debug\messaging_server\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				MinimalRebuild="false"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
-				OutputFile="$(OutDir)\server.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
+				Name="VCManifestTool"
 			/>
 			<Tool
 				Name="VCXDCMakeTool"
@@ -279,85 +201,7 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="Release"
-			IntermediateDirectory="Release\messaging_server\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				RuntimeLibrary="2"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
-				OutputFile="$(OutDir)\server.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
+				Name="VCAppVerifierTool"
 			/>
 			<Tool
 				Name="VCPostBuildEventTool"
@@ -369,39 +213,34 @@
 	<Files>
 		<Filter
 			Name="Source Files"
-			Filter="cpp;cxx;cc;c;C">
+			Filter="cpp;cxx;cc;c;C"
+			>
 			<File
-				RelativePath="server.cpp">
+				RelativePath="server.cpp"
+				>
 			</File>
 		</Filter>
 		<Filter
 			Name="Documentation"
-			Filter="">
+			>
 			<File
-				RelativePath="CMakeLists.txt">
+				RelativePath="CMakeLists.txt"
+				>
 				<FileConfiguration
 					Name="Debug|Win32"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 				<FileConfiguration
 					Name="Release|Win32"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|x64"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|x64"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 			</File>
 		</Filter>
diff --git a/qpid/cpp/examples/messaging/messaging_spout.vcproj b/qpid/cpp/examples/messaging/messaging_spout.vcproj
index b4b941f..e10b00f 100644
--- a/qpid/cpp/examples/messaging/messaging_spout.vcproj
+++ b/qpid/cpp/examples/messaging/messaging_spout.vcproj
@@ -32,9 +32,6 @@
 		<Platform
 			Name="Win32"
 		/>
-		<Platform
-			Name="x64"
-		/>
 	</Platforms>
 	<ToolFiles>
 	</ToolFiles>
@@ -64,7 +61,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				MinimalRebuild="false"
 				BasicRuntimeChecks="3"
@@ -85,11 +82,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
+				AdditionalDependencies="qpidmessagingd.lib qpidcommond.lib"
 				OutputFile="$(OutDir)\spout.exe"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				TargetMachine="1"
@@ -141,7 +138,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
@@ -159,11 +156,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
+				AdditionalDependencies="qpidmessaging.lib qpidcommon.lib"
 				OutputFile="$(OutDir)\drain.exe"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				OptimizeReferences="2"
@@ -192,169 +189,6 @@
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="."
-			IntermediateDirectory="Debug\messaging_spout\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				MinimalRebuild="false"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
-				OutputFile="$(OutDir)\spout.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="Release"
-			IntermediateDirectory="Release\messaging_spout\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				RuntimeLibrary="2"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
-				OutputFile="$(OutDir)\spout.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
 	</Configurations>
 	<References>
 	</References>
@@ -365,6 +199,10 @@
 			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
 			>
 			<File
+				RelativePath=".\OptionParser.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\spout.cpp"
 				>
 			</File>
diff --git a/qpid/cpp/examples/old-examples.sln b/qpid/cpp/examples/old-examples.sln
index 7b84ba8..7f2fa3e 100644
--- a/qpid/cpp/examples/old-examples.sln
+++ b/qpid/cpp/examples/old-examples.sln
@@ -58,10 +58,6 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tradedemo_topic_listener",
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tradedemo_topic_publisher", "tradedemo\tradedemo_topic_publisher.vcproj", "{E614CC2C-FECA-1BAD-23CE-CD4095BD3C8B}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_drain", "messaging\messaging_drain.vcproj", "{D79791E5-C593-4F23-B545-0CE72D181F2A}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_spout", "messaging\messaging_spout.vcproj", "{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}"
-EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Win32 = Debug|Win32
@@ -144,14 +140,6 @@ Global
 		{E614CC2C-FECA-1BAD-23CE-CD4095BD3C8B}.Debug|Win32.Build.0 = Debug|Win32
 		{E614CC2C-FECA-1BAD-23CE-CD4095BD3C8B}.Release|Win32.ActiveCfg = Release|Win32
 		{E614CC2C-FECA-1BAD-23CE-CD4095BD3C8B}.Release|Win32.Build.0 = Release|Win32
-		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Debug|Win32.ActiveCfg = Debug|Win32
-		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Debug|Win32.Build.0 = Debug|Win32
-		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Release|Win32.ActiveCfg = Release|Win32
-		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Release|Win32.Build.0 = Release|Win32
-		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Debug|Win32.ActiveCfg = Debug|Win32
-		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Debug|Win32.Build.0 = Debug|Win32
-		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Release|Win32.ActiveCfg = Release|Win32
-		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Release|Win32.Build.0 = Release|Win32
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
-- 
1.5.5.6

From 79804fa332a5c1b7a2ca7da5cbee843f91f7fa3b Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Mon, 7 Jun 2010 16:15:27 +0000
Subject: [PATCH] Bug 566691 - Fixed - Abort in qpid::management::ManagementAgent::periodicProcessing on shutting down qpidd

QPID-2649: Ensure timer is stopped before we start deleting broker members

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@952307 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 24a1aa7464f703084430b033c1c416391615cbab)
---
 qpid/cpp/src/qpid/broker/Broker.cpp |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Broker.cpp b/qpid/cpp/src/qpid/broker/Broker.cpp
index 09157c1..399ed58 100644
--- a/qpid/cpp/src/qpid/broker/Broker.cpp
+++ b/qpid/cpp/src/qpid/broker/Broker.cpp
@@ -359,6 +359,7 @@ Broker::~Broker() {
     finalize();                 // Finalize any plugins.
     if (config.auth)
         SaslAuthenticator::fini();
+    timer.stop();
     QPID_LOG(notice, "Shut down");
 }
 
-- 
1.5.5.6

From 395447da146aac21bc8ced9a1de3c75bc1008233 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Mon, 7 Jun 2010 19:46:55 +0000
Subject: [PATCH] Bug 598948 - Fixed - qpid c++ client occasionly fails to authenticate using GSSAPI

Don't set USER callback, AUTHNAME is sufficient

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@952390 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 20850221af97fba3fb4d055c623fc8eb53f70ea3)
---
 qpid/cpp/src/qpid/client/SaslFactory.cpp |    4 ----
 1 files changed, 0 insertions(+), 4 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/SaslFactory.cpp b/qpid/cpp/src/qpid/client/SaslFactory.cpp
index 5175c77..79acf3c 100644
--- a/qpid/cpp/src/qpid/client/SaslFactory.cpp
+++ b/qpid/cpp/src/qpid/client/SaslFactory.cpp
@@ -145,10 +145,6 @@ CyrusSasl::CyrusSasl(const ConnectionSettings& s) : conn(0), settings(s)
     callbacks[i++].context = 0;
 
     if (!settings.username.empty()) {
-        callbacks[i].id = SASL_CB_USER;
-        callbacks[i].proc = (CallbackProc*) &getUserFromSettings;
-        callbacks[i++].context = &settings;
-
         callbacks[i].id = SASL_CB_AUTHNAME;
         callbacks[i].proc = (CallbackProc*) &getUserFromSettings;
         callbacks[i++].context = &settings;
-- 
1.5.5.6

From c13cc742f961cb771f008cd19edf38cb43ee6aeb Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Tue, 8 Jun 2010 15:31:31 +0000
Subject: [PATCH] Bug 577362: Long failover_soak test hangs.

Cluster handle connection-negotiation phase in local broker.

The connection negotiation phase up to the "open" or "open-ok" frame
establishes whether/what encryption to use for the rest of the
connection.

With this patch a cluster broker completes the initial negotiation
with its local clients and only then begins multicasting to other
brokers. The local broker decrypts if necessary and multicasts in the
clear.

This replaces a problematic locking scheme that was formerly in place
which caused deadlocks.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@952692 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 4f6804221443259a89ff761f798d8c25b9cbffa7)
---
 qpid/cpp/src/qpid/broker/Connection.cpp        |    3 +-
 qpid/cpp/src/qpid/broker/Connection.h          |    8 +-
 qpid/cpp/src/qpid/broker/ConnectionHandler.cpp |   13 +-
 qpid/cpp/src/qpid/broker/ConnectionHandler.h   |   12 +--
 qpid/cpp/src/qpid/broker/SaslAuthenticator.h   |   10 --
 qpid/cpp/src/qpid/cluster/Connection.cpp       |  206 ++++++++++--------------
 qpid/cpp/src/qpid/cluster/Connection.h         |   20 +--
 qpid/cpp/src/qpid/cluster/Multicaster.cpp      |    1 -
 qpid/cpp/src/tests/cluster_test.cpp            |    8 +-
 qpid/cpp/xml/cluster.xml                       |   10 +-
 10 files changed, 112 insertions(+), 179 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Connection.cpp b/qpid/cpp/src/qpid/broker/Connection.cpp
index 51615e5..ac574fc 100644
--- a/qpid/cpp/src/qpid/broker/Connection.cpp
+++ b/qpid/cpp/src/qpid/broker/Connection.cpp
@@ -386,7 +386,6 @@ void Connection::restartTimeout()
         timeoutTimer->touch();
 }
 
-
-
+bool Connection::isOpen() { return adapter.isOpen(); }
 
 }}
diff --git a/qpid/cpp/src/qpid/broker/Connection.h b/qpid/cpp/src/qpid/broker/Connection.h
index 0639bcb..ad9f786 100644
--- a/qpid/cpp/src/qpid/broker/Connection.h
+++ b/qpid/cpp/src/qpid/broker/Connection.h
@@ -63,9 +63,6 @@ class LinkRegistry;
 class SecureConnection;
 struct ConnectionTimeoutTask;
 
-typedef boost::function<void ( std::string& )> userIdCallback;
-
-
 class Connection : public sys::ConnectionInputHandler,
                    public ConnectionState,
                    public RefCounted
@@ -146,9 +143,8 @@ class Connection : public sys::ConnectionInputHandler,
         return securitySettings;
     }
 
-    void setUserIdCallback ( UserIdCallback fn ) {
-        adapter.setUserIdCallback ( fn );
-    }
+    /** @return true if the initial connection negotiation is complete. */
+    bool isOpen();
 
   private:
     typedef boost::ptr_map<framing::ChannelId, SessionHandler> ChannelMap;
diff --git a/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp b/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
index 225735d..c349bc7 100644
--- a/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
+++ b/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
@@ -87,7 +87,8 @@ ConnectionHandler::ConnectionHandler(Connection& connection, bool isClient, bool
 
 ConnectionHandler::Handler::Handler(Connection& c, bool isClient, bool isShadow) :
     proxy(c.getOutput()),
-    connection(c), serverMode(!isClient), acl(0), secured(0), userIdCallback(0)
+    connection(c), serverMode(!isClient), acl(0), secured(0),
+    isOpen(false)
 {
     if (serverMode) {
 
@@ -195,14 +196,7 @@ void ConnectionHandler::Handler::open(const string& /*virtualHost*/,
         if (sl.get()) secured->activateSecurityLayer(sl);
     }
 
-    if ( userIdCallback ) {
-        string s;
-        // Not checking the return value of getUsername, if there is
-        // no username then we want to call the userIdCallback anyway
-        // with an empty string.
-        authenticator->getUsername(s);
-        userIdCallback(s);
-    }
+    isOpen = true;
     proxy.openOk(array);
 }
 
@@ -272,6 +266,7 @@ void ConnectionHandler::Handler::openOk(const framing::Array& knownHosts)
         Url url((*i)->get<std::string>());
         connection.getKnownHosts().push_back(url);
     }
+    isOpen = true;
 }
 
 void ConnectionHandler::Handler::redirect(const string& /*host*/, const framing::Array& /*knownHosts*/)
diff --git a/qpid/cpp/src/qpid/broker/ConnectionHandler.h b/qpid/cpp/src/qpid/broker/ConnectionHandler.h
index ecc8868..6d55cab 100644
--- a/qpid/cpp/src/qpid/broker/ConnectionHandler.h
+++ b/qpid/cpp/src/qpid/broker/ConnectionHandler.h
@@ -40,9 +40,6 @@ namespace broker {
 class Connection;
 class SecureConnection;
 
-typedef boost::function<void ( std::string& )> UserIdCallback;
-
-
 class ConnectionHandler : public framing::FrameHandler
 {
     struct Handler : public framing::AMQP_AllOperations::ConnectionHandler
@@ -53,6 +50,7 @@ class ConnectionHandler : public framing::FrameHandler
         std::auto_ptr<SaslAuthenticator> authenticator;
         AclModule* acl;
         SecureConnection* secured;
+        bool isOpen;
 
         Handler(Connection& connection, bool isClient, bool isShadow=false);
         ~Handler();
@@ -67,10 +65,6 @@ class ConnectionHandler : public framing::FrameHandler
         void close(uint16_t replyCode, const std::string& replyText);
         void closeOk();
 
-        UserIdCallback userIdCallback;
-        void setUserIdCallback ( UserIdCallback fn ) { userIdCallback = fn; };
-
-
         void start(const qpid::framing::FieldTable& serverProperties,
                    const framing::Array& mechanisms,
                    const framing::Array& locales);
@@ -95,9 +89,7 @@ class ConnectionHandler : public framing::FrameHandler
     void heartbeat();
     void handle(framing::AMQFrame& frame);
     void setSecureConnection(SecureConnection* secured);
-    void setUserIdCallback ( UserIdCallback fn ) {
-      handler->setUserIdCallback ( fn );
-    }
+    bool isOpen() { return handler->isOpen; }
 };
 
 
diff --git a/qpid/cpp/src/qpid/broker/SaslAuthenticator.h b/qpid/cpp/src/qpid/broker/SaslAuthenticator.h
index f4ad24b..f1f1039 100644
--- a/qpid/cpp/src/qpid/broker/SaslAuthenticator.h
+++ b/qpid/cpp/src/qpid/broker/SaslAuthenticator.h
@@ -36,12 +36,6 @@ namespace broker {
 
 class Connection;
 
-// Calls your fn with the user ID string, just 
-// after the security negotiation is complete.
-// Add your callback to the list with addUserIdCallback().
-typedef boost::function<void ( std::string& )> UserIdCallback;
-
-
 class SaslAuthenticator
 {
 public:
@@ -54,7 +48,6 @@ public:
     virtual void getError(std::string&) {}
     virtual std::auto_ptr<qpid::sys::SecurityLayer> getSecurityLayer(uint16_t maxFrameSize) = 0;
 
-    virtual void setUserIdCallback ( UserIdCallback ) { }
     static bool available(void);
 
     // Initialize the SASL mechanism; throw if it fails.
@@ -64,9 +57,6 @@ public:
     static std::auto_ptr<SaslAuthenticator> createAuthenticator(Connection& connection, bool isShadow);
 
     virtual void callUserIdCallbacks() { }
-
-private:
-    UserIdCallback userIdCallback;
 };
 
 }}
diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index 9a8cab2..08e31c1 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -39,7 +39,6 @@
 #include "qpid/framing/DeliveryProperties.h"
 #include "qpid/framing/ClusterConnectionDeliverCloseBody.h"
 #include "qpid/framing/ClusterConnectionAnnounceBody.h"
-#include "qpid/framing/ClusterConnectionSecureUserIdBody.h"
 #include "qpid/framing/ConnectionCloseBody.h"
 #include "qpid/framing/ConnectionCloseOkBody.h"
 #include "qpid/log/Statement.h"
@@ -48,15 +47,6 @@
 #include <boost/current_function.hpp>
 
 
-typedef boost::function<void ( std::string& )> UserIdCallback;
-
-// TODO aconway 2008-11-03:
-// 
-// Refactor code for receiving an update into a separate UpdateConnection
-// class.
-//
-
-
 namespace qpid {
 namespace cluster {
 
@@ -88,10 +78,8 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
       expectProtocolHeader(false),
       mcastFrameHandler(cluster.getMulticast(), self),
       updateIn(c.getUpdateReceiver()),
-      secureConnection(0),
-      mcastSentButNotReceived(false),
-      inConnectionNegotiation(true)
-{ }
+      secureConnection(0)
+{}
 
 // Local connection
 Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
@@ -107,9 +95,7 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
     expectProtocolHeader(isLink),
     mcastFrameHandler(cluster.getMulticast(), self),
     updateIn(c.getUpdateReceiver()),
-    secureConnection(0),
-    mcastSentButNotReceived(false),
-    inConnectionNegotiation(true)
+    secureConnection(0)
 {
     cluster.addLocalConnection(this);
     if (isLocalClient()) {
@@ -117,11 +103,7 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
         // and initialized when the announce is received.
         QPID_LOG(info, "new client connection " << *this);
         giveReadCredit(cluster.getSettings().readMax); // Flow control
-        cluster.getMulticast().mcastControl(
-            ClusterConnectionAnnounceBody(ProtocolVersion(), mgmtId,
-                                          connectionCtor.external.ssf,
-                                          connectionCtor.external.authid,
-                                          connectionCtor.external.nodict), getId());
+        init();
     }
     else {
         // Catch-up shadow connections initialized using nextShadow id.
@@ -135,7 +117,8 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
 }
 
 void Connection::setSecureConnection(broker::SecureConnection* sc) {
-  secureConnection = sc;
+    secureConnection = sc;
+    if (connection.get()) connection->setSecureConnection(sc);
 }
 
 void Connection::init() {
@@ -155,30 +138,33 @@ void Connection::init() {
     }
     if (!isCatchUp())
         connection->setErrorListener(this);
-    UserIdCallback fn = boost::bind ( &Connection::mcastUserId, this, _1 );
-    connection->setUserIdCallback ( fn );
 }
 
 // Called when we have consumed a read buffer to give credit to the
 // connection layer to continue reading.
 void Connection::giveReadCredit(int credit) {
-    {
-        sys::Mutex::ScopedLock l(connectionNegotiationMonitor);
-        if (inConnectionNegotiation) {
-            mcastSentButNotReceived = false;
-            connectionNegotiationMonitor.notify();
-        }
-    }
     if (cluster.getSettings().readMax && credit) 
         output.giveReadCredit(credit);
 }
 
-void Connection::announce(const std::string& mgmtId, uint32_t ssf, const std::string& authid, bool nodict) {
+void Connection::announce(
+    const std::string& mgmtId, uint32_t ssf, const std::string& authid, bool nodict,
+    const std::string& username, const std::string& initialFrames)
+{
     QPID_ASSERT(mgmtId == connectionCtor.mgmtId);
     QPID_ASSERT(ssf == connectionCtor.external.ssf);
     QPID_ASSERT(authid == connectionCtor.external.authid);
     QPID_ASSERT(nodict == connectionCtor.external.nodict);
-    init();
+    // Local connections are already initialized.
+    if (isShadow()) {
+        init();
+        // Play initial frames into the connection.
+        Buffer buf(const_cast<char*>(initialFrames.data()), initialFrames.size());
+        AMQFrame frame;
+        while (frame.decode(buf))
+            connection->received(frame);
+         connection->setUserId(username);
+    }
 }
 
 Connection::~Connection() {
@@ -201,7 +187,6 @@ void Connection::received(framing::AMQFrame& f) {
     if (isLocal()) {            // Local catch-up connection.
         currentChannel = f.getChannel();
         if (!framing::invoke(*this, *f.getBody()).wasHandled())
-
             connection->received(f);
     }
     else {             // Shadow or updated catch-up connection.
@@ -235,7 +220,7 @@ struct GiveReadCreditOnExit {
     int credit;
     GiveReadCreditOnExit(Connection& connection_, int credit_) :
         connection(connection_), credit(credit_) {}
-    ~GiveReadCreditOnExit() { connection.giveReadCredit(credit); }
+    ~GiveReadCreditOnExit() { if (credit) connection.giveReadCredit(credit); }
 };
 
 void Connection::deliverDoOutput(uint32_t limit) {
@@ -307,57 +292,76 @@ void Connection::abort() {
 }
 
 // ConnectionCodec::decode receives read buffers from  directly-connected clients.
-size_t Connection::decode(const char* buffer, size_t size) {
-
-    if (catchUp) {  // Handle catch-up locally.
-        Buffer buf(const_cast<char*>(buffer), size);
+size_t Connection::decode(const char* data, size_t size) {
+    GiveReadCreditOnExit grc(*this, 1);   // Give a read credit by default.
+    const char* ptr = data;
+    const char* end = data + size;
+    if (catchUp) {              // Handle catch-up locally.
+        Buffer buf(const_cast<char*>(ptr), size);
+        ptr += size;
         while (localDecoder.decode(buf))
             received(localDecoder.getFrame());
-        return buf.getPosition();
     }
     else {                      // Multicast local connections.
-        assert(isLocal());
-        const char* remainingData = buffer;
-        size_t remainingSize = size;
-
-        if (expectProtocolHeader) {
-            //If this is an outgoing link, we will receive a protocol
-            //header which needs to be decoded first
-            framing::ProtocolInitiation pi;
-            Buffer buf(const_cast<char*>(buffer), size);
-            if (pi.decode(buf)) {
-                //TODO: check the version is correct
-                QPID_LOG(debug, "Outgoing clustered link connection received INIT(" << pi << ")");
-                expectProtocolHeader = false;
-                remainingData = buffer + pi.encodedSize();
-                remainingSize = size - pi.encodedSize();
-            } else {
-                QPID_LOG(debug, "Not enough data for protocol header on outgoing clustered link");
-                giveReadCredit(1); // We're not going to mcast so give read credit now.
-                return 0;
-            }
+        assert(isLocalClient());
+        assert(connection.get());
+        if (!checkProtocolHeader(ptr, size)) // Updates ptr
+            return 0; // Incomplete header
+
+        if (!connection->isOpen()) 
+            processInitialFrames(ptr, end-ptr); // Updates ptr
+        
+        if (connection->isOpen() && end - ptr > 0) {
+            // We're multi-casting, we will give read credit on delivery.
+            grc.credit = 0;
+            cluster.getMulticast().mcastBuffer(ptr, end - ptr, self);
+            ptr = end;
         }
-
-        // During connection negotiation wait for each multicast to be
-        // processed before sending the next, to ensure that the
-        // security layer is activated before we attempt to decode
-        // encrypted frames.
-        { 
-            sys::Mutex::ScopedLock l(connectionNegotiationMonitor);
-            if ( inConnectionNegotiation ) {
-                assert(!mcastSentButNotReceived);
-                mcastSentButNotReceived = true;
-            }
-        }
-        cluster.getMulticast().mcastBuffer(remainingData, remainingSize, self);
-        {
-            sys::Mutex::ScopedLock l(connectionNegotiationMonitor);
-            if (inConnectionNegotiation)
-                while (mcastSentButNotReceived)
-                    connectionNegotiationMonitor.wait();
-            assert(!mcastSentButNotReceived);
+    }
+    return ptr - data;
+}
+
+// Decode the protocol header if needed. Updates data and size
+// returns true if the header is complete or already read.
+bool Connection::checkProtocolHeader(const char*& data, size_t size) {
+    if (expectProtocolHeader) {
+        //If this is an outgoing link, we will receive a protocol
+        //header which needs to be decoded first
+        framing::ProtocolInitiation pi;
+        Buffer buf(const_cast<char*&>(data), size);
+        if (pi.decode(buf)) {
+            //TODO: check the version is correct
+            QPID_LOG(debug, "Outgoing clustered link connection received INIT(" << pi << ")");
+            expectProtocolHeader = false;
+            data += pi.encodedSize();
+        } else {
+            return false;
         }
-        return size;
+    }
+    return true;
+}
+
+void Connection::processInitialFrames(const char*& ptr, size_t size) {
+    // Process the initial negotiation locally and store it so
+    // it can be replayed on other brokers in announce()
+    Buffer buf(const_cast<char*>(ptr), size);
+    framing::AMQFrame frame;
+    while (!connection->isOpen() && frame.decode(buf))
+        received(frame);
+    initialFrames.append(ptr, buf.getPosition());
+    ptr += buf.getPosition();
+    if (connection->isOpen()) { // initial negotiation complete
+        cluster.getMulticast().mcastControl(
+            ClusterConnectionAnnounceBody(
+                ProtocolVersion(),
+                connectionCtor.mgmtId,
+                connectionCtor.external.ssf,
+                connectionCtor.external.authid,
+                connectionCtor.external.nodict,
+                connection->getUserId(),
+                initialFrames),
+            getId());
+        initialFrames.clear();
     }
 }
 
@@ -574,21 +578,14 @@ void Connection::queue(const std::string& encoded) {
 }
 
 void Connection::sessionError(uint16_t , const std::string& msg) {
-    // If we are negotiating the connection when it fails just close the connectoin.
-    // If it fails after that then we have to flag the error to the cluster.
-    if (inConnectionNegotiation)
-        cluster.getMulticast().mcastControl(ClusterConnectionDeliverCloseBody(), self);
-    else
+    // Ignore errors before isOpen(), we're not multicasting yet.
+    if (connection->isOpen())
         cluster.flagError(*this, ERROR_TYPE_SESSION, msg);
-    
 }
 
 void Connection::connectionError(const std::string& msg) {
-    // If we are negotiating the connection when it fails just close the connectoin.
-    // If it fails after that then we have to flag the error to the cluster.
-    if (inConnectionNegotiation)
-        cluster.getMulticast().mcastControl(ClusterConnectionDeliverCloseBody(), self);
-    else
+    // Ignore errors before isOpen(), we're not multicasting yet.
+    if (connection->isOpen())
         cluster.flagError(*this, ERROR_TYPE_CONNECTION, msg);
 }
 
@@ -630,30 +627,5 @@ void Connection::managementAgents(const std::string& data) {
     QPID_LOG(debug, cluster << " updated management agents");
 }
 
-
-void Connection::mcastUserId ( std::string & id ) {
-    // Only the directly connected broker will mcast the secure user id, and only
-    // for client connections (not update connections)
-    if (isLocalClient())
-        cluster.getMulticast().mcastControl(
-            ClusterConnectionSecureUserIdBody(ProtocolVersion(), string(id)), getId() );
-    {
-        // This call signals the end of the connection negotiation phase.
-        sys::Mutex::ScopedLock l(connectionNegotiationMonitor);
-        inConnectionNegotiation = false;
-        mcastSentButNotReceived = false;
-        connectionNegotiationMonitor.notify();
-    }
-}
-
-// All connections, shadow or not, get this call.
-void Connection::secureUserId(const std::string& id) {
-    // Only set the user ID on shadow connections, and only if id is not the empty string.
-    if ( isShadow() && !id.empty() )
-        connection->setUserId ( id );
-}
-
-
-
 }} // Namespace qpid::cluster
 
diff --git a/qpid/cpp/src/qpid/cluster/Connection.h b/qpid/cpp/src/qpid/cluster/Connection.h
index 4f69bf7..70c4d0e 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.h
+++ b/qpid/cpp/src/qpid/cluster/Connection.h
@@ -164,8 +164,9 @@ class Connection :
     void exchange(const std::string& encoded);
 
     void giveReadCredit(int credit);
-    void announce(const std::string& mgmtId, uint32_t ssf, const std::string& authid, bool nodict);
-    void secureUserId(const std::string&);
+    void announce(const std::string& mgmtId, uint32_t ssf, const std::string& authid,
+                  bool nodict, const std::string& username,
+                  const std::string& initFrames);
     void abort();
     void deliverClose();
 
@@ -175,16 +176,8 @@ class Connection :
     void managementSchema(const std::string& data);
     void managementAgents(const std::string& data);
     void managementSetupState(uint64_t objectNum, uint16_t bootSequence);
-
-    //uint32_t getSsf() const { return connectionCtor.external.ssf; }
-
     void setSecureConnection ( broker::SecureConnection * sc );
 
-    // This is a callback, registered with the broker connection.
-    // It gives me the user ID, if one is negotiated through Sasl.
-    void mcastUserId ( std::string & );
-
-
   private:
     struct NullFrameHandler : public framing::FrameHandler {
         void handle(framing::AMQFrame&) {}
@@ -228,6 +221,8 @@ class Connection :
     bool checkUnsupported(const framing::AMQBody& body);
     void deliverDoOutput(uint32_t limit);
 
+    bool checkProtocolHeader(const char*& data, size_t size);
+    void processInitialFrames(const char*& data, size_t size);
     boost::shared_ptr<broker::Queue> findQueue(const std::string& qname);
     broker::SessionState& sessionState();
     broker::SemanticState& semanticState();
@@ -247,13 +242,10 @@ class Connection :
     McastFrameHandler mcastFrameHandler;
     UpdateReceiver& updateIn;
     qpid::broker::SecureConnection* secureConnection;
+    std::string initialFrames;
 
     static qpid::sys::AtomicValue<uint64_t> catchUpId;
 
-    mutable sys::Monitor connectionNegotiationMonitor;
-    bool mcastSentButNotReceived;
-    bool inConnectionNegotiation;
-    
   friend std::ostream& operator<<(std::ostream&, const Connection&);
 };
 
diff --git a/qpid/cpp/src/qpid/cluster/Multicaster.cpp b/qpid/cpp/src/qpid/cluster/Multicaster.cpp
index d57ff76..8916de9 100644
--- a/qpid/cpp/src/qpid/cluster/Multicaster.cpp
+++ b/qpid/cpp/src/qpid/cluster/Multicaster.cpp
@@ -61,7 +61,6 @@ void Multicaster::mcast(const Event& e) {
     QPID_LOG(trace, "MCAST " << e);
     if (bypass) {               // direct, don't queue
         iovec iov = e.toIovec();
-        // FIXME aconway 2010-03-10: should do limited retry.
         while (!cpg.mcast(&iov, 1))
             ;
     }
diff --git a/qpid/cpp/src/tests/cluster_test.cpp b/qpid/cpp/src/tests/cluster_test.cpp
index d5f2c45..0565ecc 100644
--- a/qpid/cpp/src/tests/cluster_test.cpp
+++ b/qpid/cpp/src/tests/cluster_test.cpp
@@ -510,7 +510,7 @@ QPID_AUTO_TEST_CASE(testUpdateMessageBuilder) {
     Client c1(cluster[1], "c1");
     BOOST_CHECK(c1.subs.get(m, "q", TIMEOUT));
     BOOST_CHECK_EQUAL(m.getData(), "abcd");
-    BOOST_CHECK_EQUAL(2u, knownBrokerPorts(c1.connection).size());
+    BOOST_CHECK_EQUAL(2u, knownBrokerPorts(c1.connection, 2).size());
 }
 
 QPID_AUTO_TEST_CASE(testConnectionKnownHosts) {
@@ -518,13 +518,13 @@ QPID_AUTO_TEST_CASE(testConnectionKnownHosts) {
     prepareArgs(args, durableFlag);
     ClusterFixture cluster(1, args, -1);
     Client c0(cluster[0], "c0");
-    set<int> kb0 = knownBrokerPorts(c0.connection);
+    set<int> kb0 = knownBrokerPorts(c0.connection, 1);
     BOOST_CHECK_EQUAL(kb0.size(), 1u);
     BOOST_CHECK_EQUAL(kb0, makeSet(cluster));
 
     cluster.add();
     Client c1(cluster[1], "c1");
-    set<int> kb1 = knownBrokerPorts(c1.connection);
+    set<int> kb1 = knownBrokerPorts(c1.connection, 2);
     kb0 = knownBrokerPorts(c0.connection, 2);
     BOOST_CHECK_EQUAL(kb1.size(), 2u);
     BOOST_CHECK_EQUAL(kb1, makeSet(cluster));
@@ -532,7 +532,7 @@ QPID_AUTO_TEST_CASE(testConnectionKnownHosts) {
 
     cluster.add();
     Client c2(cluster[2], "c2");
-    set<int> kb2 = knownBrokerPorts(c2.connection);
+    set<int> kb2 = knownBrokerPorts(c2.connection, 3);
     kb1 = knownBrokerPorts(c1.connection, 3);
     kb0 = knownBrokerPorts(c0.connection, 3);
     BOOST_CHECK_EQUAL(kb2.size(), 3u);
diff --git a/qpid/cpp/xml/cluster.xml b/qpid/cpp/xml/cluster.xml
index 29157dc..30cd159 100644
--- a/qpid/cpp/xml/cluster.xml
+++ b/qpid/cpp/xml/cluster.xml
@@ -127,6 +127,10 @@
       <field name="authid" type="str16"/>
       <!-- exclude certain sasl mechs, used with ssl and sasl-external -->
       <field name="nodict" type="bit"/>
+      <!-- User name as negotiated by SASL -->
+      <field name="username" type="str32"/>
+      <!-- Frames forming the initial connection negotiation.  -->
+      <field name="initial-frames" type="str32"/>
     </control>
 
     <!-- Marks the cluster-wide point when a connection is considered closed. -->
@@ -263,11 +267,5 @@
     <control name="management-agents" code="0x37">
       <field name="data" type="vbin32"/>
     </control>
-
-    <!-- Announce the user ID on a secure connection -->
-    <control name="secureUserId" code="0x38">
-      <field name="secure-user-id" type="str16"/>
-    </control>
-
   </class>
 </amqp>
-- 
1.5.5.6

From d6ead34fe2802092c0dd6490df11a6cc763506c1 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 9 Jun 2010 10:21:59 +0000
Subject: [PATCH] Bug 508959 - Fixed - Attempt to propagate binding info over dynamic link can crash broker if session has already failed

Ensure that bindings for dynamic bridges are not propagated over failed sessions.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@952942 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 04e23a8984a81a869067ade50c445f17f8dafbea)
---
 qpid/cpp/src/qpid/broker/Bridge.cpp |   26 +++++++++++++++++---------
 qpid/cpp/src/qpid/broker/Bridge.h   |    2 ++
 2 files changed, 19 insertions(+), 9 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Bridge.cpp b/qpid/cpp/src/qpid/broker/Bridge.cpp
index 003d508..3e632f6 100644
--- a/qpid/cpp/src/qpid/broker/Bridge.cpp
+++ b/qpid/cpp/src/qpid/broker/Bridge.cpp
@@ -153,16 +153,12 @@ void Bridge::create(Connection& c)
     if (args.i_srcIsLocal) sessionHandler.getSession()->enableReceiverTracking();
 }
 
-void Bridge::cancel(Connection& c)
+void Bridge::cancel(Connection&)
 {
-    if (args.i_srcIsLocal) {    
-        //recreate peer to be sure that the session handler reference
-        //is valid (it could have been deleted due to a detach)
-        SessionHandler& sessionHandler = c.getChannel(id);
-        peer.reset(new framing::AMQP_ServerProxy(sessionHandler.out));
+    if (resetProxy()) {
+        peer->getMessage().cancel(args.i_dest);
+        peer->getSession().detach(name);
     }
-    peer->getMessage().cancel(args.i_dest);
-    peer->getSession().detach(name);
 }
 
 void Bridge::closed()
@@ -310,10 +306,22 @@ void Bridge::sendReorigin()
     conn->requestIOProcessing(boost::bind(&Bridge::ioThreadPropagateBinding, this,
                                           queueName, args.i_src, args.i_key, bindArgs));
 }
+bool Bridge::resetProxy() 
+{
+    SessionHandler& sessionHandler = conn->getChannel(id);
+    if (!sessionHandler.getSession()) peer.reset();
+    else peer.reset(new framing::AMQP_ServerProxy(sessionHandler.out));
+    return peer.get();
+}
 
 void Bridge::ioThreadPropagateBinding(const string& queue, const string& exchange, const string& key, FieldTable args)
 {
-    peer->getExchange().bind(queue, exchange, key, args);
+    if (resetProxy()) {
+        peer->getExchange().bind(queue, exchange, key, args);
+    } else {
+        QPID_LOG(error, "Cannot propagate binding for dynamic bridge as session has been detached, deleting dynamic bridge");
+        destroy();
+    }
 }
 
 bool Bridge::containsLocalTag(const string& tagList) const
diff --git a/qpid/cpp/src/qpid/broker/Bridge.h b/qpid/cpp/src/qpid/broker/Bridge.h
index 5f9a46a..f25d32e 100644
--- a/qpid/cpp/src/qpid/broker/Bridge.h
+++ b/qpid/cpp/src/qpid/broker/Bridge.h
@@ -101,6 +101,8 @@ private:
     mutable uint64_t  persistenceId;
     ConnectionState* connState;
     Connection* conn;
+
+    bool resetProxy();
 };
 
 
-- 
1.5.5.6

From 079143676f0881d15138059d328a5531ef6a307e Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 9 Jun 2010 14:40:26 +0000
Subject: [PATCH] Bug 591292 - Fixed - MRG-M Heartbeat causes core

Ensure heartbeat task is cancelled before ConnectionImpl it refers to is deleted

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953032 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit a43e46bbed2bc9449494ff1db039f11a1230405d)
---
 qpid/cpp/src/qpid/client/ConnectionImpl.cpp |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/ConnectionImpl.cpp b/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
index 8848554..397bd4e 100644
--- a/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
+++ b/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
@@ -198,6 +198,7 @@ ConnectionImpl::ConnectionImpl(framing::ProtocolVersion v, const ConnectionSetti
 const uint16_t ConnectionImpl::NEXT_CHANNEL = std::numeric_limits<uint16_t>::max();
 
 ConnectionImpl::~ConnectionImpl() {
+    if (heartbeatTask) heartbeatTask->cancel();
     theIO().sub();
 }
 
-- 
1.5.5.6

From 4ee966781844a3757eaa44ebf4690105c2f18850 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 9 Jun 2010 15:37:02 +0000
Subject: [PATCH] Bug 597149 - Fixed - qpid python high level API clients not runnable on RHEL4 incompatible with python 2.3.4 OptionParser

Minor adjustment to option definitions for Python 2.3

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953044 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 4f7efe697023e9b654e5ceef9648204a322ce779)
---
 qpid/python/examples/api/drain  |    8 ++++----
 qpid/python/examples/api/server |    4 ++--
 qpid/python/examples/api/spout  |    8 ++++----
 3 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/qpid/python/examples/api/drain b/qpid/python/examples/api/drain
index eaf86f9..5e30153 100755
--- a/qpid/python/examples/api/drain
+++ b/qpid/python/examples/api/drain
@@ -27,17 +27,17 @@ parser = optparse.OptionParser(usage="usage: %prog [options] ADDRESS ...",
                                description="Drain messages from the supplied address.")
 parser.add_option("-b", "--broker", default="localhost",
                   help="connect to specified BROKER (default %default)")
-parser.add_option("-c", "--count", type=int,
+parser.add_option("-c", "--count", type="int",
                   help="number of messages to drain")
 parser.add_option("-f", "--forever", action="store_true",
                   help="ignore timeout and wait forever")
 parser.add_option("-r", "--reconnect", action="store_true",
                   help="enable auto reconnect")
-parser.add_option("-i", "--reconnect-interval", type=float, default=3,
+parser.add_option("-i", "--reconnect-interval", type="float", default=3,
                   help="interval between reconnect attempts")
-parser.add_option("-l", "--reconnect-limit", type=int,
+parser.add_option("-l", "--reconnect-limit", type="int",
                   help="maximum number of reconnect attempts")
-parser.add_option("-t", "--timeout", type=float, default=0,
+parser.add_option("-t", "--timeout", type="float", default=0,
                   help="timeout in seconds to wait before exiting (default %default)")
 parser.add_option("-p", "--print", dest="format", default="%(M)s",
                   help="format string for printing messages (default %default)")
diff --git a/qpid/python/examples/api/server b/qpid/python/examples/api/server
index 0500e6f..3b9a356 100755
--- a/qpid/python/examples/api/server
+++ b/qpid/python/examples/api/server
@@ -30,9 +30,9 @@ parser.add_option("-b", "--broker", default="localhost",
                   help="connect to specified BROKER (default %default)")
 parser.add_option("-r", "--reconnect", action="store_true",
                   help="enable auto reconnect")
-parser.add_option("-i", "--reconnect-interval", type=float, default=3,
+parser.add_option("-i", "--reconnect-interval", type="float", default=3,
                   help="interval between reconnect attempts")
-parser.add_option("-l", "--reconnect-limit", type=int,
+parser.add_option("-l", "--reconnect-limit", type="int",
                   help="maximum number of reconnect attempts")
 parser.add_option("-v", dest="verbose", action="store_true",
                   help="enable logging")
diff --git a/qpid/python/examples/api/spout b/qpid/python/examples/api/spout
index dacebb5..c2dc4db 100755
--- a/qpid/python/examples/api/spout
+++ b/qpid/python/examples/api/spout
@@ -39,13 +39,13 @@ parser.add_option("-b", "--broker", default="localhost",
                   help="connect to specified BROKER (default %default)")
 parser.add_option("-r", "--reconnect", action="store_true",
                   help="enable auto reconnect")
-parser.add_option("-i", "--reconnect-interval", type=float, default=3,
+parser.add_option("-i", "--reconnect-interval", type="float", default=3,
                   help="interval between reconnect attempts")
-parser.add_option("-l", "--reconnect-limit", type=int,
+parser.add_option("-l", "--reconnect-limit", type="int",
                   help="maximum number of reconnect attempts")
-parser.add_option("-c", "--count", type=int, default=1,
+parser.add_option("-c", "--count", type="int", default=1,
                   help="stop after count messages have been sent, zero disables (default %default)")
-parser.add_option("-t", "--timeout", type=float, default=None,
+parser.add_option("-t", "--timeout", type="float", default=None,
                   help="exit after the specified time")
 parser.add_option("-I", "--id", help="use the supplied id instead of generating one")
 parser.add_option("-S", "--subject", help="specify a subject")
-- 
1.5.5.6

From d092a33ae3f83cf0cc6423a0990cd26b06de6087 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Wed, 9 Jun 2010 20:29:32 +0000
Subject: [PATCH] Bug 602347: Fix cluster-safe assertion in connection negotiation.

See https://bugzilla.redhat.com/show_bug.cgi?id=602347.
In a cluster, raise the management connect event when processing cluster.announce.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953147 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit bfd0ea5b4582f99fe423ec18d206e7f3d2a635dc)
---
 qpid/cpp/src/qpid/broker/Connection.cpp  |   12 +++++++++++-
 qpid/cpp/src/qpid/broker/Connection.h    |    1 +
 qpid/cpp/src/qpid/cluster/Connection.cpp |    2 ++
 qpid/cpp/src/qpid/sys/ClusterSafe.cpp    |    6 +++++-
 qpid/cpp/src/qpid/sys/ClusterSafe.h      |   17 ++++++++++++++++-
 qpid/cpp/src/tests/cluster_tests.py      |    6 ++++--
 6 files changed, 39 insertions(+), 5 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Connection.cpp b/qpid/cpp/src/qpid/broker/Connection.cpp
index ac574fc..619f1a1 100644
--- a/qpid/cpp/src/qpid/broker/Connection.cpp
+++ b/qpid/cpp/src/qpid/broker/Connection.cpp
@@ -24,6 +24,7 @@
 #include "qpid/broker/Bridge.h"
 #include "qpid/broker/Broker.h"
 #include "qpid/sys/SecuritySettings.h"
+#include "qpid/sys/ClusterSafe.h"
 
 #include "qpid/log/Statement.h"
 #include "qpid/ptr_map.h"
@@ -121,7 +122,9 @@ Connection::~Connection()
 {
     if (mgmtObject != 0) {
         mgmtObject->resourceDestroy();
-        if (!isLink)
+        // In a cluster, Connections destroyed during shutdown are in
+        // a cluster-unsafe context. Don't raise an event in that case.
+        if (!isLink && isClusterSafe())
             agent->raiseEvent(_qmf::EventClientDisconnect(mgmtId, ConnectionState::getUserId()));
     }
     if (isLink)
@@ -202,6 +205,13 @@ void Connection::notifyConnectionForced(const string& text)
 void Connection::setUserId(const string& userId)
 {
     ConnectionState::setUserId(userId);
+    // In a cluster, the cluster code will raise the connect event
+    // when the connection is replicated to the cluster.
+    if (!sys::isCluster())
+        raiseConnectEvent();
+}
+
+void Connection::raiseConnectEvent() {
     if (mgmtObject != 0) {
         mgmtObject->set_authIdentity(userId);
         agent->raiseEvent(_qmf::EventClientConnect(mgmtId, userId));
diff --git a/qpid/cpp/src/qpid/broker/Connection.h b/qpid/cpp/src/qpid/broker/Connection.h
index ad9f786..cf199fa 100644
--- a/qpid/cpp/src/qpid/broker/Connection.h
+++ b/qpid/cpp/src/qpid/broker/Connection.h
@@ -111,6 +111,7 @@ class Connection : public sys::ConnectionInputHandler,
     std::string getAuthCredentials();
     void notifyConnectionForced(const std::string& text);
     void setUserId(const string& uid);
+    void raiseConnectEvent();
     const std::string& getUserId() const { return ConnectionState::getUserId(); }
     const std::string& getMgmtId() const { return mgmtId; }
     management::ManagementAgent* getAgent() const { return agent; }
diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index 08e31c1..c402415 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -165,6 +165,8 @@ void Connection::announce(
             connection->received(frame);
          connection->setUserId(username);
     }
+    // Raise the connection management event now that the connection is replicated.
+    connection->raiseConnectEvent();
 }
 
 Connection::~Connection() {
diff --git a/qpid/cpp/src/qpid/sys/ClusterSafe.cpp b/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
index 498a46d..e051591 100644
--- a/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
+++ b/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
@@ -32,8 +32,12 @@ bool inCluster = false;
 QPID_TSS bool inContext = false;
 }
 
+bool isClusterSafe() { return !inCluster || inContext; }
+
+bool isCluster() { return inCluster; }
+
 void assertClusterSafe()  {
-    if (inCluster && !inContext) {
+    if (!isClusterSafe()) {
         QPID_LOG(critical, "Modified cluster state outside of cluster context");
         ::abort();
     }
diff --git a/qpid/cpp/src/qpid/sys/ClusterSafe.h b/qpid/cpp/src/qpid/sys/ClusterSafe.h
index abb9ad0..f338230 100644
--- a/qpid/cpp/src/qpid/sys/ClusterSafe.h
+++ b/qpid/cpp/src/qpid/sys/ClusterSafe.h
@@ -42,6 +42,20 @@ namespace sys {
 QPID_COMMON_EXTERN void assertClusterSafe();
 
 /**
+ * In a non-clustered broker, returns true.
+ *
+ * In a clustered broker returns true if we are in a context where it
+ * is safe to modify cluster state.
+ *
+ * This function is in the common library rather than the cluster
+ * library because it is called by code in the broker library.
+ */
+QPID_COMMON_EXTERN bool isClusterSafe();
+
+/** Return true in a clustered broker */
+QPID_COMMON_EXTERN bool isCluster();
+
+/**
  * Base class for classes that encapsulate state which is replicated
  * to all members of a cluster. Acts as a marker for clustered state
  * and provides functions to assist detecting bugs in cluster
@@ -53,7 +67,8 @@ struct ClusterSafeScope {
 };
 
 /**
- * Enable cluster-safe assertions. By defaul they are no-ops.
+ * Enable cluster-safe assertions. By default they are no-ops.
+ * Called by cluster code.
  */
 void enableClusterSafe();
 
diff --git a/qpid/cpp/src/tests/cluster_tests.py b/qpid/cpp/src/tests/cluster_tests.py
index f36cde9..983a8bd 100755
--- a/qpid/cpp/src/tests/cluster_tests.py
+++ b/qpid/cpp/src/tests/cluster_tests.py
@@ -211,6 +211,7 @@ class LongTests(BrokerTest):
             """Start ordinary clients for a broker. Start one client per broker.
             Round-robin on a colllection of different clients."""
             cmds=[
+                ["qpid-tool", "localhost:%s"%(broker.port())],
                 ["qpid-perftest", "--count", 50000,
                  "--base-name", str(qpid.datatypes.uuid4()), "--port", broker.port()],
                 ["qpid-queue-stats", "-a", "localhost:%s" %(broker.port())],
@@ -222,14 +223,15 @@ class LongTests(BrokerTest):
             cmd = ["qpid-stat", "-b", "localhost:%s" %(broker.port())]
             mclients.append(ClientLoop(broker, cmd))
 
-        endtime = time.time() + self.duration()
+        duration = max(self.duration(), 5)
+        endtime = time.time() + duration
         alive = 0                       # First live cluster member
         for i in range(len(cluster)):
             start_clients(cluster[i], i)
         start_mclients(cluster[alive])
 
         while time.time() < endtime:
-            time.sleep(min(5,self.duration()/2))
+            time.sleep(min(5,duration/2))
             for b in cluster[alive:]: b.ready() # Check if a broker crashed.
             # Kill the first broker, expect the clients to fail. 
             for c in clients[alive] + mclients: c.expect_fail()
-- 
1.5.5.6

From 46909ad1f9b0a01027da5fae7f41ccffb3778780 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Thu, 10 Jun 2010 13:36:15 +0000
Subject: [PATCH] Bug 602672 - Fixed -Message::getSubject() returns an empty string even if the message has a subject

QPID-664: Correct the name of the subject string used for incoming messages.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953321 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 1e4b6eddcbb9e45190c708967fce2097d2a69fa1)
---
 .../src/qpid/client/amqp0_10/IncomingMessages.cpp  |    2 +-
 qpid/cpp/src/tests/MessagingSessionTests.cpp       |    2 ++
 2 files changed, 3 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp b/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp
index cbf05fc..30cb634 100644
--- a/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp
+++ b/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp
@@ -289,7 +289,7 @@ void IncomingMessages::MessageTransfer::retrieve(qpid::messaging::Message* messa
 namespace {
 //TODO: unify conversion to and from 0-10 message that is currently
 //split between IncomingMessages and OutgoingMessage
-const std::string SUBJECT("subject");
+const std::string SUBJECT("qpid.subject");
 }
 
 void populateHeaders(qpid::messaging::Message& message, 
diff --git a/qpid/cpp/src/tests/MessagingSessionTests.cpp b/qpid/cpp/src/tests/MessagingSessionTests.cpp
index 2c51b9e..375af73 100644
--- a/qpid/cpp/src/tests/MessagingSessionTests.cpp
+++ b/qpid/cpp/src/tests/MessagingSessionTests.cpp
@@ -55,11 +55,13 @@ QPID_AUTO_TEST_CASE(testSimpleSendReceive)
     QueueFixture fix;
     Sender sender = fix.session.createSender(fix.queue);
     Message out("test-message");
+    out.setSubject("test-subject");
     sender.send(out);
     Receiver receiver = fix.session.createReceiver(fix.queue);
     Message in = receiver.fetch(Duration::SECOND * 5);
     fix.session.acknowledge();
     BOOST_CHECK_EQUAL(in.getContent(), out.getContent());
+    BOOST_CHECK_EQUAL(in.getSubject(), out.getSubject());
 }
 
 QPID_AUTO_TEST_CASE(testSyncSendReceive)
-- 
1.5.5.6

From 6227acefa2c27ad6b66ae7616e0b738ba3f9a754 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Fri, 11 Jun 2010 08:42:37 +0000
Subject: [PATCH] Bug 591292 - Further fix for heartbeat related segfault

Ensure that AsynchConnector is disassociated from Poller when aborting connection attempt due to a heartbeat timeout

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953610 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit ade27a1e658534e7188f90d91e6991bafac69870)
---
 qpid/cpp/src/qpid/client/TCPConnector.cpp |   12 ++++++++----
 qpid/cpp/src/qpid/client/TCPConnector.h   |    1 +
 qpid/cpp/src/qpid/sys/AsynchIO.h          |    2 +-
 qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp  |    6 ++++++
 4 files changed, 16 insertions(+), 5 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/TCPConnector.cpp b/qpid/cpp/src/qpid/client/TCPConnector.cpp
index d0a12c8..e284d57 100644
--- a/qpid/cpp/src/qpid/client/TCPConnector.cpp
+++ b/qpid/cpp/src/qpid/client/TCPConnector.cpp
@@ -76,10 +76,11 @@ TCPConnector::TCPConnector(Poller::shared_ptr p,
       initiated(false),
       closed(true),
       shutdownHandler(0),
+      connector(0),
       aio(0),
       poller(p)
 {
-    QPID_LOG(debug, "TCPConnector created for " << version.toString());
+    QPID_LOG(debug, "TCPConnector created for " << version);
     settings.configureSocket(socket);
 }
 
@@ -90,17 +91,18 @@ TCPConnector::~TCPConnector() {
 void TCPConnector::connect(const std::string& host, int port) {
     Mutex::ScopedLock l(lock);
     assert(closed);
-    AsynchConnector* c = AsynchConnector::create(
+    connector = AsynchConnector::create(
         socket,
         host, port,
         boost::bind(&TCPConnector::connected, this, _1),
         boost::bind(&TCPConnector::connectFailed, this, _3));
     closed = false;
 
-    c->start(poller);
+    connector->start(poller);
 }
 
 void TCPConnector::connected(const Socket&) {
+    connector = 0;
     aio = AsynchIO::create(socket,
                        boost::bind(&TCPConnector::readbuff, this, _1, _2),
                        boost::bind(&TCPConnector::eof, this, _1),
@@ -128,6 +130,7 @@ void TCPConnector::initAmqp() {
 }
 
 void TCPConnector::connectFailed(const std::string& msg) {
+    connector = 0;
     QPID_LOG(warning, "Connect failed: " << msg);
     socket.close();
     if (!closed)
@@ -158,8 +161,9 @@ void TCPConnector::abort() {
         if (aio) {
             // Established connection
             aio->requestCallback(boost::bind(&TCPConnector::eof, this, _1));
-        } else {
+        } else if (connector) {
             // We're still connecting
+            connector->stop();
             connectFailed("Connection timedout");
         }
     }
diff --git a/qpid/cpp/src/qpid/client/TCPConnector.h b/qpid/cpp/src/qpid/client/TCPConnector.h
index bce5f59..c756469 100644
--- a/qpid/cpp/src/qpid/client/TCPConnector.h
+++ b/qpid/cpp/src/qpid/client/TCPConnector.h
@@ -71,6 +71,7 @@ class TCPConnector : public Connector, public sys::Codec
 
     sys::Socket socket;
 
+    sys::AsynchConnector* connector;
     sys::AsynchIO* aio;
     std::string identifier;
     boost::shared_ptr<sys::Poller> poller;
diff --git a/qpid/cpp/src/qpid/sys/AsynchIO.h b/qpid/cpp/src/qpid/sys/AsynchIO.h
index f184163..50da8fa 100644
--- a/qpid/cpp/src/qpid/sys/AsynchIO.h
+++ b/qpid/cpp/src/qpid/sys/AsynchIO.h
@@ -69,7 +69,7 @@ public:
                                    ConnectedCallback connCb,
                                    FailedCallback failCb);
     virtual void start(boost::shared_ptr<Poller> poller) = 0;
-
+    virtual void stop() {};
 protected:
     AsynchConnector() {}
     virtual ~AsynchConnector() {}
diff --git a/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp b/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp
index cef9f1f..7d85b43 100644
--- a/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp
+++ b/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp
@@ -157,6 +157,7 @@ public:
                     ConnectedCallback connCb,
                     FailedCallback failCb);
     void start(Poller::shared_ptr poller);
+    void stop();
 };
 
 AsynchConnector::AsynchConnector(const Socket& s,
@@ -183,6 +184,11 @@ void AsynchConnector::start(Poller::shared_ptr poller)
     startWatch(poller);
 }
 
+void AsynchConnector::stop()
+{
+    stopWatch();
+}
+
 void AsynchConnector::connComplete(DispatchHandle& h)
 {
     h.stopWatch();
-- 
1.5.5.6

From 2e2fa6ccfda4ba82811fae63fa994ed99468245b Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Fri, 11 Jun 2010 09:10:13 +0000
Subject: [PATCH] Bug 598550 - Alleviates some of the broker load for QMF V2 format requests.

QPID-664: Avoid allocation for void Variant

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953615 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 0ef592408a84c9f55c33b5796e186b07a29bd6c9)
---
 qpid/cpp/src/qpid/types/Variant.cpp |   55 ++++++++++++++++++----------------
 1 files changed, 29 insertions(+), 26 deletions(-)

diff --git a/qpid/cpp/src/qpid/types/Variant.cpp b/qpid/cpp/src/qpid/types/Variant.cpp
index f22483f..1457449 100644
--- a/qpid/cpp/src/qpid/types/Variant.cpp
+++ b/qpid/cpp/src/qpid/types/Variant.cpp
@@ -482,7 +482,7 @@ VariantImpl* VariantImpl::create(const Variant& v)
     }
 }
 
-Variant::Variant() : impl(new VariantImpl()) {}
+Variant::Variant() : impl(0) {}
 Variant::Variant(bool b) : impl(new VariantImpl(b)) {}
 Variant::Variant(uint8_t i) : impl(new VariantImpl(i)) {}
 Variant::Variant(uint16_t i) : impl(new VariantImpl(i)) {}
@@ -506,7 +506,7 @@ Variant::~Variant() { if (impl) delete impl; }
 void Variant::reset()
 {
     if (impl) delete impl;
-    impl = new VariantImpl();
+    impl = 0;
 }
 
 
@@ -622,29 +622,32 @@ Variant& Variant::operator=(const Variant& v)
     return *this;
 }
 
-VariantType Variant::getType() const { return impl->getType(); }
-bool Variant::isVoid() const { return impl->getType() == VAR_VOID; }
-bool Variant::asBool() const { return impl->asBool(); }
-uint8_t Variant::asUint8() const { return impl->asUint8(); }
-uint16_t Variant::asUint16() const { return impl->asUint16(); }
-uint32_t Variant::asUint32() const { return impl->asUint32(); }
-uint64_t Variant::asUint64() const { return impl->asUint64(); }
-int8_t Variant::asInt8() const { return impl->asInt8(); }
-int16_t Variant::asInt16() const { return impl->asInt16(); }
-int32_t Variant::asInt32() const { return impl->asInt32(); }
-int64_t Variant::asInt64() const { return impl->asInt64(); }
-float Variant::asFloat() const { return impl->asFloat(); }
-double Variant::asDouble() const { return impl->asDouble(); }
-std::string Variant::asString() const { return impl->asString(); }
-Uuid Variant::asUuid() const { return impl->asUuid(); }
-const Variant::Map& Variant::asMap() const { return impl->asMap(); }
-Variant::Map& Variant::asMap() { return impl->asMap(); }
-const Variant::List& Variant::asList() const { return impl->asList(); }
-Variant::List& Variant::asList() { return impl->asList(); }
-const std::string& Variant::getString() const { return impl->getString(); }
-std::string& Variant::getString() { return impl->getString(); }
-void Variant::setEncoding(const std::string& s) { impl->setEncoding(s); }
-const std::string& Variant::getEncoding() const { return impl->getEncoding(); }
+VariantType Variant::getType() const { return impl ? impl->getType() : VAR_VOID; }
+bool Variant::isVoid() const { return getType() == VAR_VOID; }
+bool Variant::asBool() const { return impl && impl->asBool(); }
+uint8_t Variant::asUint8() const { return impl ? impl->asUint8() : 0; }
+uint16_t Variant::asUint16() const { return impl ? impl->asUint16() : 0; }
+uint32_t Variant::asUint32() const { return impl ? impl->asUint32() : 0; }
+uint64_t Variant::asUint64() const { return impl ? impl->asUint64() : 0; }
+int8_t Variant::asInt8() const { return impl ? impl->asInt8() : 0; }
+int16_t Variant::asInt16() const { return impl ? impl->asInt16() : 0; }
+int32_t Variant::asInt32() const { return impl ? impl->asInt32(): 0; }
+int64_t Variant::asInt64() const { return impl ? impl->asInt64() : 0; }
+float Variant::asFloat() const { return impl ? impl->asFloat() : 0; }
+double Variant::asDouble() const { return impl ? impl->asDouble() : 0; }
+std::string Variant::asString() const { return impl ? impl->asString() : EMPTY; }
+Uuid Variant::asUuid() const { return impl ? impl->asUuid() : Uuid(); }
+const Variant::Map& Variant::asMap() const { if (!impl) throw InvalidConversion("Can't convert VOID to MAP"); return impl->asMap(); }
+Variant::Map& Variant::asMap() { if (!impl) throw InvalidConversion("Can't convert VOID to MAP"); return impl->asMap(); }
+const Variant::List& Variant::asList() const { if (!impl) throw InvalidConversion("Can't convert VOID to LIST"); return impl->asList(); }
+Variant::List& Variant::asList() { if (!impl) throw InvalidConversion("Can't convert VOID to LIST"); return impl->asList(); }
+const std::string& Variant::getString() const { if (!impl) throw InvalidConversion("Can't convert VOID to STRING"); return impl->getString(); }
+std::string& Variant::getString() { if (!impl) throw InvalidConversion("Can't convert VOID to STRING"); return impl->getString(); }
+void Variant::setEncoding(const std::string& s) { 
+    if (!impl) impl = new VariantImpl();
+    impl->setEncoding(s); 
+}
+const std::string& Variant::getEncoding() const { return impl ? impl->getEncoding() : EMPTY; }
 
 Variant::operator bool() const { return asBool(); }
 Variant::operator uint8_t() const { return asUint8(); }
@@ -708,7 +711,7 @@ bool operator==(const Variant& a, const Variant& b)
 
 bool Variant::isEqualTo(const Variant& other) const
 {
-    return impl->isEqualTo(*other.impl);
+    return impl && impl->isEqualTo(*other.impl);
 }
 
 }} // namespace qpid::types
-- 
1.5.5.6

From 299fb71454960dbf62f635d846e5a4be9abb4429 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Wed, 9 Jun 2010 18:17:19 +0000
Subject: [PATCH] Bug 601277 - qpidd broker crash

Cleaned up the storage of RemoteAgents in ManagementAgent.
This closes a window of opportunity for a double-free.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953107 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit ffaa25d6c05dd381f603edb0107e914d3130480b)
---
 qpid/cpp/src/qpid/management/ManagementAgent.cpp |   27 +++++++++-------------
 qpid/cpp/src/qpid/management/ManagementAgent.h   |    6 +----
 2 files changed, 12 insertions(+), 21 deletions(-)

diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.cpp b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
index 7f2dd69..b1c2780 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.cpp
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
@@ -1390,31 +1390,26 @@ uint32_t ManagementAgent::assignBankLH (uint32_t requestedBank)
 
 void ManagementAgent::deleteOrphanedAgentsLH()
 {
-    vector<ObjectId> deleteList;
+    list<ObjectId> deleteList;
 
-    for (RemoteAgentMap::iterator aIter = remoteAgents.begin(); aIter != remoteAgents.end(); aIter++) {
-        ObjectId connectionRef = aIter->first;
+    for (RemoteAgentMap::const_iterator aIter = remoteAgents.begin(); aIter != remoteAgents.end(); aIter++) {
         bool found = false;
 
         for (ManagementObjectMap::iterator iter = managementObjects.begin();
              iter != managementObjects.end();
              iter++) {
-            if (iter->first == connectionRef && !iter->second->isDeleted()) {
+            if (iter->first == aIter->first && !iter->second->isDeleted()) {
                 found = true;
                 break;
             }
         }
 
-        if (!found) {
-            deleteList.push_back(connectionRef);
-            delete aIter->second;
-        }
+        if (!found)
+            deleteList.push_back(aIter->first);
     }
 
-    for (vector<ObjectId>::iterator dIter = deleteList.begin(); dIter != deleteList.end(); dIter++)
+    for (list<ObjectId>::const_iterator dIter = deleteList.begin(); dIter != deleteList.end(); dIter++)
         remoteAgents.erase(*dIter);
-
-    deleteList.clear();
 }
 
 void ManagementAgent::handleAttachRequestLH (Buffer& inBuffer, const string& replyToKey, uint32_t sequence, const ConnectionToken* connToken)
@@ -1444,12 +1439,12 @@ void ManagementAgent::handleAttachRequestLH (Buffer& inBuffer, const string& rep
 
     assignedBank = assignBankLH(requestedAgentBank);
 
-    RemoteAgent* agent = new RemoteAgent(*this);
+    boost::shared_ptr<RemoteAgent> agent(new RemoteAgent(*this));
     agent->brokerBank = brokerBank;
     agent->agentBank  = assignedBank;
     agent->routingKey = replyToKey;
     agent->connectionRef = connectionRef;
-    agent->mgmtObject = new _qmf::Agent (this, agent);
+    agent->mgmtObject = new _qmf::Agent (this, agent.get());
     agent->mgmtObject->set_connectionRef(agent->connectionRef);
     agent->mgmtObject->set_label        (label);
     agent->mgmtObject->set_registeredTo (broker->GetManagementObject()->getObjectId());
@@ -2289,7 +2284,7 @@ void ManagementAgent::exportAgents(string& out) {
          ++i)
     {
         // TODO aconway 2010-03-04: see comment in ManagementAgent::RemoteAgent::encode
-        RemoteAgent* agent = i->second;
+        boost::shared_ptr<RemoteAgent> agent(i->second);
 
         map_.clear();
         amap.clear();
@@ -2310,7 +2305,7 @@ void ManagementAgent::importAgents(qpid::framing::Buffer& inBuf) {
     sys::Mutex::ScopedLock lock(userLock);
 
     for (l = content.begin(); l != content.end(); l++) {
-        auto_ptr<RemoteAgent> agent(new RemoteAgent(*this));
+        boost::shared_ptr<RemoteAgent> agent(new RemoteAgent(*this));
         Variant::Map map_;
         Variant::Map::const_iterator i;
 
@@ -2321,7 +2316,7 @@ void ManagementAgent::importAgents(qpid::framing::Buffer& inBuf) {
             agent->mapDecode(i->second.asMap());
 
             addObject (agent->mgmtObject, 0, false);
-            remoteAgents[agent->connectionRef] = agent.release();
+            remoteAgents[agent->connectionRef] = agent;
         }
     }
 }
diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.h b/qpid/cpp/src/qpid/management/ManagementAgent.h
index d101ca1..44e3eb1 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.h
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.h
@@ -175,11 +175,7 @@ private:
         void mapDecode(const qpid::types::Variant::Map& _map);
     };
 
-    // TODO: Eventually replace string with entire reply-to structure.  reply-to
-    //       currently assumes that the exchange is "amq.direct" even though it could
-    //       in theory be specified differently.
-    typedef std::map<ObjectId, RemoteAgent*> RemoteAgentMap;
-    typedef std::vector<std::string>         ReplyToVector;
+    typedef std::map<ObjectId, boost::shared_ptr<RemoteAgent> > RemoteAgentMap;
 
     //  Storage for known schema classes:
     //
-- 
1.5.5.6

From 043f40b8dbf45d45f2342108dc977298a7afbe6a Mon Sep 17 00:00:00 2001
From: Kim van der Riet <kpvdr@apache.org>
Date: Fri, 11 Jun 2010 12:49:52 +0000
Subject: [PATCH] Bug 589683 - Broker misconfiguration causes broker stop to fail

QPID-2666: Fix for init script problem where config file has "log-to-file" set with a relative path.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953687 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 032866de5d7cccafac52faeaa333b9dae4811761)
---
 qpid/cpp/etc/qpidd |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/etc/qpidd b/qpid/cpp/etc/qpidd
index f391da3..07cbb82 100755
--- a/qpid/cpp/etc/qpidd
+++ b/qpid/cpp/etc/qpidd
@@ -72,7 +72,7 @@ start() {
 	    touch $pidfile
 	    chown qpidd.qpidd $pidfile
             [ -x /sbin/restorecon ] && /sbin/restorecon $pidfile
-	    runuser -s /bin/sh qpidd -c "/usr/sbin/$prog --check > $pidfile"
+	    runuser - -s /bin/sh qpidd -c "/usr/sbin/$prog --check > $pidfile"
 	fi
 	return $RETVAL
 }
-- 
1.5.5.6

From b3c11c4bf0a0417775763883c5576bcf2e797348 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Fri, 11 Jun 2010 21:46:57 +0000
Subject: [PATCH] Bug 601828 - QMF Agent returning STATUS_USER returns error 7 to QMF Console

Fixed a bug in which QMF error return codes were being sent back as 7 - Exception.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953885 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 2b9eb6bdbecc94d6dfdf2db148e422daf07ab2b1)
---
 qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp |   32 ++++++++--------------
 1 files changed, 12 insertions(+), 20 deletions(-)

diff --git a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
index 6a07d8c..e2a595c 100644
--- a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
+++ b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
@@ -499,8 +499,8 @@ void ManagementAgentImpl::invokeMethodRequest(const string& body, const string&
 
     if ((oid = inMap.find("_object_id")) == inMap.end() ||
         (mid = inMap.find("_method_name")) == inMap.end()) {
-        (outMap["_values"].asMap())["_status_code"] = Manageable::STATUS_PARAMETER_INVALID;
-        (outMap["_values"].asMap())["_status_text"] = Manageable::StatusText(Manageable::STATUS_PARAMETER_INVALID);
+        sendException(replyTo, cid, Manageable::StatusText(Manageable::STATUS_PARAMETER_INVALID),
+                      Manageable::STATUS_PARAMETER_INVALID);
         failed = true;
     } else {
         string methodName;
@@ -520,8 +520,8 @@ void ManagementAgentImpl::invokeMethodRequest(const string& body, const string&
 
             ManagementObjectMap::iterator iter = managementObjects.find(objId);
             if (iter == managementObjects.end() || iter->second->isDeleted()) {
-                (outMap["_values"].asMap())["_status_code"] = Manageable::STATUS_UNKNOWN_OBJECT;
-                (outMap["_values"].asMap())["_status_text"] = Manageable::StatusText(Manageable::STATUS_UNKNOWN_OBJECT);
+                sendException(replyTo, cid, Manageable::StatusText(Manageable::STATUS_UNKNOWN_OBJECT),
+                              Manageable::STATUS_UNKNOWN_OBJECT);
                 failed = true;
             } else {
                 iter->second->doMethod(methodName, inArgs, callMap);
@@ -534,33 +534,25 @@ void ManagementAgentImpl::invokeMethodRequest(const string& body, const string&
                     if (iter->first != "_status_code" && iter->first != "_status_text")
                         outMap["_arguments"].asMap()[iter->first] = iter->second;
             } else {
-                (outMap["_values"].asMap())["_status_code"] = callMap["_status_code"];
-                (outMap["_values"].asMap())["_status_text"] = callMap["_status_text"];
+                sendException(replyTo, cid, callMap["_status_text"], callMap["_status_code"]);
                 failed = true;
             }
 
         } catch(types::InvalidConversion& e) {
-            outMap.clear();
-            outMap["_values"] = Variant::Map();
-            (outMap["_values"].asMap())["_status_code"] = Manageable::STATUS_EXCEPTION;
-            (outMap["_values"].asMap())["_status_text"] = e.what();
+            sendException(replyTo, cid, e.what(), Manageable::STATUS_EXCEPTION);
             failed = true;
         }
     }
 
-    Variant::Map headers;
-    headers["method"] = "response";
-    headers["qmf.agent"] = name_address;
-    if (failed) {
-        headers["qmf.opcode"] = "_exception";
-        QPID_LOG(trace, "SENT Exception map=" << outMap);
-    } else {
+    if (!failed) {
+        Variant::Map headers;
+        headers["method"] = "response";
+        headers["qmf.agent"] = name_address;
         headers["qmf.opcode"] = "_method_response";
         QPID_LOG(trace, "SENT MethodResponse map=" << outMap);
+        MapCodec::encode(outMap, content);
+        connThreadBody.sendBuffer(content, cid, headers, "qmf.default.direct", replyTo);
     }
-
-    MapCodec::encode(outMap, content);
-    connThreadBody.sendBuffer(content, cid, headers, "qmf.default.direct", replyTo);
 }
 
 void ManagementAgentImpl::handleGetQuery(const string& body, const string& cid, const string& replyTo)
-- 
1.5.5.6

From fcf4a2aefda3d8d84b1abb0dea6d340a9fbdc546 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Thu, 3 Jun 2010 20:23:30 +0000
Subject: [PATCH] Bug 599700 - Console examples sometimes fail due to not waiting for the broker connection to complete

QPID-2644 - Console examples sometimes fail due to not waiting for the broker connection to complete
Moved 'Broker::waitForStable' from private to public, used this function in the examples to
hold off until the broker is fully connected.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@951141 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 095fb80c67258ab00a2654bdd4a094f4d37ed4b8)
---
 qpid/cpp/examples/qmf-console/console.cpp |    1 +
 qpid/cpp/examples/qmf-console/ping.cpp    |    1 +
 qpid/cpp/include/qpid/console/Broker.h    |   14 +++++++-------
 3 files changed, 9 insertions(+), 7 deletions(-)

diff --git a/qpid/cpp/examples/qmf-console/console.cpp b/qpid/cpp/examples/qmf-console/console.cpp
index 5700d55..b5375b6 100644
--- a/qpid/cpp/examples/qmf-console/console.cpp
+++ b/qpid/cpp/examples/qmf-console/console.cpp
@@ -81,6 +81,7 @@ int main_int(int /*argc*/, char** /*argv*/)
     Broker* broker;
 
     broker = sm.addBroker(settings);
+    broker->waitForStable();
 
     cout << "Package List:" << endl;
     vector<string> packages;
diff --git a/qpid/cpp/examples/qmf-console/ping.cpp b/qpid/cpp/examples/qmf-console/ping.cpp
index 405c15f..fe537d4 100644
--- a/qpid/cpp/examples/qmf-console/ping.cpp
+++ b/qpid/cpp/examples/qmf-console/ping.cpp
@@ -55,6 +55,7 @@ int main_int(int /*argc*/, char** /*argv*/)
     // Add a broker connection to the session manager.
     //
     Broker* broker = sm.addBroker(connSettings);
+    broker->waitForStable();
 
     uint32_t count = 5;  // The number of echo requests we will send to the broker.
     Object::Vector list; // A container for holding objects retrieved from the broker.
diff --git a/qpid/cpp/include/qpid/console/Broker.h b/qpid/cpp/include/qpid/console/Broker.h
index af163b8..0b2d1bc 100644
--- a/qpid/cpp/include/qpid/console/Broker.h
+++ b/qpid/cpp/include/qpid/console/Broker.h
@@ -55,15 +55,16 @@ namespace console {
                                    client::ConnectionSettings& settings);
         QPID_CONSOLE_EXTERN ~Broker();
 
-        bool isConnected() const { return connected; }
-        const std::string& getError() const { return error; }
-        const std::string& getSessionId() const { return amqpSessionId; }
-        const framing::Uuid& getBrokerId() const { return brokerId; }
-        uint32_t getBrokerBank() const { return 1; }
-        void addBinding(const std::string& key) {
+        QPID_CONSOLE_EXTERN bool isConnected() const { return connected; }
+        QPID_CONSOLE_EXTERN const std::string& getError() const { return error; }
+        QPID_CONSOLE_EXTERN const std::string& getSessionId() const { return amqpSessionId; }
+        QPID_CONSOLE_EXTERN const framing::Uuid& getBrokerId() const { return brokerId; }
+        QPID_CONSOLE_EXTERN uint32_t getBrokerBank() const { return 1; }
+        QPID_CONSOLE_EXTERN void addBinding(const std::string& key) {
             connThreadBody.bindExchange("qpid.management", key);
         }
         QPID_CONSOLE_EXTERN std::string getUrl() const;
+        QPID_CONSOLE_EXTERN void waitForStable();
 
     private:
         friend class SessionManager;
@@ -117,7 +118,6 @@ namespace console {
         void received(client::Message& msg);
         void resetAgents();
         void updateAgent(const Object& object);
-        void waitForStable();
         void incOutstanding();
         void decOutstanding();
         void setBrokerId(const framing::Uuid& id) { brokerId = id; }
-- 
1.5.5.6

From 779be75603ed95682b9dcdbffa24182243d72547 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:05 +0000
Subject: [PATCH] BZ 591139: Removed unnecessary parameter from Rdma::AsynchIO::dataEvent()

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954489 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp |    4 ++--
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.h   |    2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index 9244343..6f81450 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -42,7 +42,7 @@ namespace Rdma {
             ErrorCallback ec
     ) :
         qp(q),
-        dataHandle(*qp, boost::bind(&AsynchIO::dataEvent, this, _1), 0, 0),
+        dataHandle(*qp, boost::bind(&AsynchIO::dataEvent, this), 0, 0),
         bufferSize(size),
         recvCredit(0),
         xmitCredit(xCredit),
@@ -278,7 +278,7 @@ namespace Rdma {
         } while (true);
     }
 
-    void AsynchIO::dataEvent(qpid::sys::DispatchHandle&) {
+    void AsynchIO::dataEvent() {
         // Keep track of writable notifications
         // qpid::sys::ScopedLock<qpid::sys::Mutex> l(stateLock);
         State oldState;
diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
index 0b86461..d896217 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
@@ -103,7 +103,7 @@ namespace Rdma {
         const static int FlagsMask = 0x10000000; // Mask for all flag bits - be sure to update this if you add more command bits
         const static int IgnoreData = 0x10000000; // Message contains no application data
 
-        void dataEvent(qpid::sys::DispatchHandle& handle);
+        void dataEvent();
         void processCompletions();
         void doWriteCallback();
         void doStoppedCallback();
-- 
1.5.5.6

From 39751102ca8d384c4607664ed86abfae55723289 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:08 +0000
Subject: [PATCH] BZ 591139: Trivial code simplification

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954490 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp |    4 +---
 1 files changed, 1 insertions(+), 3 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp
index a5f54e8..c95cda7 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp
@@ -65,9 +65,7 @@ Duration fullTestDuration(TIME_INFINITE);
 vector<char> testString;
 
 void write(Rdma::AsynchIO& aio) {
-    while (aio.writable()) {
-        if (smsgs >= target)
-            return;
+    while (aio.writable() && aio.bufferAvailable() && smsgs < target) {
         Rdma::Buffer* b = aio.getBuffer();
         std::copy(testString.begin(), testString.end(), b->bytes);
         b->dataCount = msgsize;
-- 
1.5.5.6

From 97edcebbe4cba28829070f228b7da6f61bcafc3e Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:12 +0000
Subject: [PATCH] BZ 591139: Only set the draining flag when we delay calling the drained callback.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954491 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp |    3 +--
 1 files changed, 1 insertions(+), 2 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index 6f81450..32bd9cd 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -130,8 +130,6 @@ namespace Rdma {
 
     // Mark writing closed (so we don't accept any more writes or make any idle callbacks)
     void AsynchIO::drainWriteQueue(NotifyCallback nc) {
-        draining = true;
-
         State oldState;
         State newState;
         bool doReturn;
@@ -149,6 +147,7 @@ namespace Rdma {
             }
         } while (!state.boolCompareAndSwap(oldState, newState));
         if (doReturn) {
+            draining = true;
             notifyCallback = nc;
             return;
         }
-- 
1.5.5.6

From d4894bf43c8d1abc4bad633b2439502b458bb1d8 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:16 +0000
Subject: [PATCH] BZ 591139:
 In Rdma::AsynchIO::stop():
 - make sure we stop the underlying handle immediately whether or not
   we do the stopped callback now or have to defer it.

In qpid::client::RdmaConnector:
- make sure that the shutdown handler is called under all circumstances.
- make sure that the destructor doesn't delete the aio if it is
  already deleted

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954492 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/client/RdmaConnector.cpp |   19 +++++++++++++++----
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp      |    6 ++++--
 2 files changed, 19 insertions(+), 6 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/RdmaConnector.cpp b/qpid/cpp/src/qpid/client/RdmaConnector.cpp
index 9be9e71..624f457 100644
--- a/qpid/cpp/src/qpid/client/RdmaConnector.cpp
+++ b/qpid/cpp/src/qpid/client/RdmaConnector.cpp
@@ -162,7 +162,12 @@ namespace {
 RdmaConnector::~RdmaConnector() {
     QPID_LOG(debug, "~RdmaConnector " << identifier);
     close();
-    if (aio) aio->stop(deleteAsynchIO);
+    if (aio) {
+        aio->stop(deleteAsynchIO);
+    }
+    if (shutdownHandler) {
+        shutdownHandler->shutdown();
+    }
 }
 
 void RdmaConnector::connect(const std::string& host, int port){
@@ -244,15 +249,21 @@ void RdmaConnector::dataError(Rdma::AsynchIO&) {
     drained();
 }
 
-void RdmaConnector::stopped(Rdma::AsynchIO* aio) {
-    delete aio;
+void RdmaConnector::stopped(Rdma::AsynchIO* a) {
+    QPID_LOG(debug, "RdmaConnector::stopped " << identifier);
+    assert(!polling);
+    aio = 0;
+    delete a;
     if (shutdownHandler) {
-        shutdownHandler->shutdown();
+        ShutdownHandler* s = shutdownHandler;
+        shutdownHandler = 0;
+        s->shutdown();
     }
 }
 
 void RdmaConnector::drained() {
     QPID_LOG(debug, "RdmaConnector::drained " << identifier);
+    assert(!polling);
     if (aio) {
         aio->stop(boost::bind(&RdmaConnector::stopped, this, aio));
         aio = 0;
diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index 32bd9cd..e91127e 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -117,11 +117,14 @@ namespace Rdma {
             newState = SHUTDOWN;
 
         } while (!state.boolCompareAndSwap(oldState, newState));
+        
+        // Ensure we can't get any more callbacks (except for the stopped callback)
+        dataHandle.stopWatch();
+
         if (doReturn) {
             notifyCallback = nc;
             return;
         }
-        dataHandle.stopWatch();
         // Callback, but don't store it - SHUTDOWN state means callback has been called
         // we *are* allowed to delete the AsynchIO in this callback, so we have to return immediately
         // after the callback
@@ -473,7 +476,6 @@ namespace Rdma {
     }
 
     void AsynchIO::doStoppedCallback() {
-        dataHandle.stopWatch();
         NotifyCallback nc;
         nc.swap(notifyCallback);
         // Transition unconditionally to SHUTDOWN
-- 
1.5.5.6

From 7909518935fc6e164f6affa9447eb4a3cf5b8485 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:20 +0000
Subject: [PATCH] BZ 591139: Allow stopping even if we've got outstanding write buffers.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954493 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index e91127e..bd0005d 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -109,7 +109,7 @@ namespace Rdma {
         do {
             newState = oldState = state.get();
             doReturn = false;
-            if (outstandingWrites > 0 || (oldState != IDLE && oldState != DRAINED)) {
+            if (oldState != IDLE && oldState != DRAINED) {
                 doReturn = true;
                 break;
             }
-- 
1.5.5.6

From b0aacc99250bdd8c0202b667332fb17f741bca12 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:23 +0000
Subject: [PATCH] BZ 591139: Added asserts to ensure that we catch it if xmitCredit isn't sane

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954494 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp |    7 +++++++
 1 files changed, 7 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index bd0005d..45295d4 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -171,6 +171,7 @@ namespace Rdma {
             }
             ++outstandingWrites;
             --xmitCredit;
+            assert(xmitCredit>=0);
         } else {
             if (fullCallback) {
                 fullCallback(*this, buff);
@@ -397,8 +398,10 @@ namespace Rdma {
                 // Get our xmitCredit if it was sent
                 bool dataPresent = true;
                 if (e.immPresent() ) {
+                    assert(xmitCredit>=0);
                     xmitCredit += (e.getImm() & ~FlagsMask);
                     dataPresent = ((e.getImm() & IgnoreData) == 0);
+                    assert(xmitCredit>0);
                 }
 
                 // if there was no data sent then the message was only to update our credit
@@ -430,6 +433,7 @@ namespace Rdma {
                         recvCredit -= creditSent;
                         ++outstandingWrites;
                         --xmitCredit;
+                        assert(xmitCredit>=0);
                     } else {
                         QPID_LOG(warning, "RDMA: qp=" << qp << ":  Unable to send unsolicited credit");
                     }
@@ -453,6 +457,9 @@ namespace Rdma {
     void AsynchIO::doWriteCallback() {
         // TODO: maybe don't call idle unless we're low on write buffers
         // Keep on calling the idle routine as long as we are writable and we got something to write last call
+
+        // Do callback even if there are no available free buffers as the application itself might be
+        // holding onto buffers
         while (writable()) {
             int xc = xmitCredit;
             idleCallback(*this);
-- 
1.5.5.6

From 7cf228a337572cb24179abfb109c8ce105725abc Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:27 +0000
Subject: [PATCH] BZ 591139: Try to avoid getting into a state where we can't send credit because we
 sent the very last buffer without any credit. So in theory when we do have
 credit to send we should have a buffer and xmit credit to do it with.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954495 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.h |   11 ++++++++++-
 1 files changed, 10 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
index d896217..655119b 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
@@ -110,8 +110,17 @@ namespace Rdma {
         void doDrainedCallback();
     };
 
+    // We're only writable if:
+    // * not draining write queue
+    // * we've got space in the transmit queue
+    // * we've got credit to transmit
+    // * if there's only 1 transmit credit we must send some credit
     inline bool AsynchIO::writable() const {
-        return (!draining && outstandingWrites < xmitBufferCount && xmitCredit > 0);
+        assert(xmitCredit>=0);
+        return !draining &&
+               outstandingWrites < xmitBufferCount &&
+               xmitCredit > 0 &&
+               ( xmitCredit > 1 || recvCredit > 0);
     }
 
     inline int AsynchIO::incompletedWrites() const {
-- 
1.5.5.6

From bd95291efa29074a75163208990fe6f0a8e828ed Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:33 +0000
Subject: [PATCH] BZ 591139: Combine Rdma::Buffer and ibv_sge needed to send it

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954496 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/client/RdmaConnector.cpp |   11 +++----
 qpid/cpp/src/qpid/sys/RdmaIOPlugin.cpp     |   12 ++++----
 qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp  |    8 ++--
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp      |   13 +-------
 qpid/cpp/src/qpid/sys/rdma/RdmaServer.cpp  |    4 +-
 qpid/cpp/src/qpid/sys/rdma/rdma_wrap.cpp   |   46 ++++++++++-----------------
 qpid/cpp/src/qpid/sys/rdma/rdma_wrap.h     |   29 ++++++++++++++---
 7 files changed, 60 insertions(+), 63 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/RdmaConnector.cpp b/qpid/cpp/src/qpid/client/RdmaConnector.cpp
index 624f457..3b4e87d 100644
--- a/qpid/cpp/src/qpid/client/RdmaConnector.cpp
+++ b/qpid/cpp/src/qpid/client/RdmaConnector.cpp
@@ -326,10 +326,9 @@ void RdmaConnector::writebuff(Rdma::AsynchIO&) {
     Codec* codec = securityLayer.get() ? (Codec*) securityLayer.get() : (Codec*) this;
     if (codec->canEncode()) {
         std::auto_ptr<BufferBase> buffer = std::auto_ptr<BufferBase>(aio->getBuffer());
-        size_t encoded = codec->encode(buffer->bytes, buffer->byteCount);
+        size_t encoded = codec->encode(buffer->bytes(), buffer->byteCount());
 
-        buffer->dataStart = 0;
-        buffer->dataCount = encoded;
+        buffer->dataCount(encoded);
         aio->queueWrite(buffer.release());
     }
 }
@@ -362,7 +361,7 @@ size_t RdmaConnector::encode(const char* buffer, size_t size)
 
 void RdmaConnector::readbuff(Rdma::AsynchIO&, Rdma::Buffer* buff) {
     Codec* codec = securityLayer.get() ? (Codec*) securityLayer.get() : (Codec*) this;
-    codec->decode(buff->bytes+buff->dataStart, buff->dataCount);
+    codec->decode(buff->bytes(), buff->dataCount());
 }
 
 size_t RdmaConnector::decode(const char* buffer, size_t size) 
@@ -386,9 +385,9 @@ size_t RdmaConnector::decode(const char* buffer, size_t size)
 
 void RdmaConnector::writeDataBlock(const AMQDataBlock& data) {
     Rdma::Buffer* buff = aio->getBuffer();
-    framing::Buffer out(buff->bytes, buff->byteCount);
+    framing::Buffer out(buff->bytes(), buff->byteCount());
     data.encode(out);
-    buff->dataCount = data.encodedSize();
+    buff->dataCount(data.encodedSize());
     aio->queueWrite(buff);
 }
 
diff --git a/qpid/cpp/src/qpid/sys/RdmaIOPlugin.cpp b/qpid/cpp/src/qpid/sys/RdmaIOPlugin.cpp
index e3498fa..044e6b4 100644
--- a/qpid/cpp/src/qpid/sys/RdmaIOPlugin.cpp
+++ b/qpid/cpp/src/qpid/sys/RdmaIOPlugin.cpp
@@ -108,9 +108,9 @@ void RdmaIOHandler::write(const framing::ProtocolInitiation& data)
 {
     QPID_LOG(debug, "Rdma: SENT [" << identifier << "] INIT(" << data << ")");
     Rdma::Buffer* buff = aio->getBuffer();
-    framing::Buffer out(buff->bytes, buff->byteCount);
+    framing::Buffer out(buff->bytes(), buff->byteCount());
     data.encode(out);
-    buff->dataCount = data.encodedSize();
+    buff->dataCount(data.encodedSize());
     aio->queueWrite(buff);
 }
 
@@ -135,8 +135,8 @@ void RdmaIOHandler::idle(Rdma::AsynchIO&) {
     if (codec == 0) return;
     if (codec->canEncode()) {
         Rdma::Buffer* buff = aio->getBuffer();
-        size_t encoded=codec->encode(buff->bytes, buff->byteCount);
-        buff->dataCount = encoded;
+        size_t encoded=codec->encode(buff->bytes(), buff->byteCount());
+        buff->dataCount(encoded);
         aio->queueWrite(buff);
     }
     if (codec->isClosed())
@@ -178,7 +178,7 @@ void RdmaIOHandler::readbuff(Rdma::AsynchIO&, Rdma::Buffer* buff) {
     size_t decoded = 0;
     try {
         if (codec) {
-            decoded = codec->decode(buff->bytes+buff->dataStart, buff->dataCount);
+            decoded = codec->decode(buff->bytes(), buff->dataCount());
         }else{
             // Need to start protocol processing
             initProtocolIn(buff);
@@ -191,7 +191,7 @@ void RdmaIOHandler::readbuff(Rdma::AsynchIO&, Rdma::Buffer* buff) {
 }
 
 void RdmaIOHandler::initProtocolIn(Rdma::Buffer* buff) {
-    framing::Buffer in(buff->bytes+buff->dataStart, buff->dataCount);
+    framing::Buffer in(buff->bytes(), buff->dataCount());
     framing::ProtocolInitiation protocolInit;
     size_t decoded = 0;
     if (protocolInit.decode(in)) {
diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp
index c95cda7..d33c609 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp
@@ -67,8 +67,8 @@ vector<char> testString;
 void write(Rdma::AsynchIO& aio) {
     while (aio.writable() && aio.bufferAvailable() && smsgs < target) {
         Rdma::Buffer* b = aio.getBuffer();
-        std::copy(testString.begin(), testString.end(), b->bytes);
-        b->dataCount = msgsize;
+        std::copy(testString.begin(), testString.end(), b->bytes());
+        b->dataCount(msgsize);
         aio.queueWrite(b);
         ++smsgs;
         sbytes += msgsize;
@@ -81,7 +81,7 @@ void dataError(Rdma::AsynchIO&) {
 
 void data(Poller::shared_ptr p, Rdma::AsynchIO& aio, Rdma::Buffer* b) {
     ++rmsgs;
-    rbytes += b->dataCount;
+    rbytes += b->dataCount();
 
     // When all messages have been recvd stop
     if (rmsgs < target) {
@@ -99,7 +99,7 @@ void full(Rdma::AsynchIO& a, Rdma::Buffer* b) {
 
     // Don't need to keep buffer just adjust the counts
     --smsgs;
-    sbytes -= b->dataCount;
+    sbytes -= b->dataCount();
 
     // Give buffer back
     a.returnBuffer(b);
diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index 45295d4..3b49e97 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -65,7 +65,6 @@ namespace Rdma {
             // Allocate recv buffer
             Buffer* b = qp->createBuffer(bufferSize);
             buffers.push_front(b);
-            b->dataCount = b->byteCount;
             qp->postRecv(b);
         }
 
@@ -74,8 +73,6 @@ namespace Rdma {
             Buffer* b = qp->createBuffer(bufferSize);
             buffers.push_front(b);
             bufferQueue.push_front(b);
-            b->dataCount = 0;
-            b->dataStart = 0;
         }
     }
 
@@ -410,8 +407,6 @@ namespace Rdma {
                 }
 
                 // At this point the buffer has been consumed so put it back on the recv queue
-                b->dataStart = 0;
-                b->dataCount = 0;
                 qp->postRecv(b);
 
                 // Received another message
@@ -425,8 +420,8 @@ namespace Rdma {
                     if (writable()) {
                         Buffer* ob = getBuffer();
                         // Have to send something as adapters hate it when you try to transfer 0 bytes
-                        *reinterpret_cast< uint32_t* >(ob->bytes) = htonl(recvCredit);
-                        ob->dataCount = sizeof(uint32_t);
+                        *reinterpret_cast< uint32_t* >(ob->bytes()) = htonl(recvCredit);
+                        ob->dataCount(sizeof(uint32_t));
 
                         int creditSent = recvCredit & ~FlagsMask;
                         qp->postSend(creditSent | IgnoreData, ob);
@@ -498,16 +493,12 @@ namespace Rdma {
         assert(!bufferQueue.empty());
         Buffer* b = bufferQueue.front();
         bufferQueue.pop_front();
-        b->dataCount = 0;
-        b->dataStart = 0;
         return b;
     }
 
     void AsynchIO::returnBuffer(Buffer* b) {
         qpid::sys::ScopedLock<qpid::sys::Mutex> l(bufferQueueLock);
         bufferQueue.push_front(b);
-        b->dataCount = 0;
-        b->dataStart = 0;
     }
 
     ConnectionManager::ConnectionManager(
diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaServer.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaServer.cpp
index d42784f..9771532 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaServer.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaServer.cpp
@@ -70,8 +70,8 @@ void idle(ConRec* cr, Rdma::AsynchIO& a) {
 void data(ConRec* cr, Rdma::AsynchIO& a, Rdma::Buffer* b) {
     // Echo data back
     Rdma::Buffer* buf = a.getBuffer();
-    std::copy(b->bytes+b->dataStart, b->bytes+b->dataStart+b->dataCount, buf->bytes);
-    buf->dataCount = b->dataCount;
+    std::copy(b->bytes(), b->bytes()+b->dataCount(), buf->bytes());
+    buf->dataCount(b->dataCount());
     if (cr->queuedWrites.empty()) {
         // If can't write then full will be called and push buffer on back of queue
         a.queueWrite(buf);
diff --git a/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.cpp b/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.cpp
index 8944be2..2581aae 100644
--- a/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.cpp
@@ -50,19 +50,20 @@ namespace Rdma {
         return count;
     }
 
-    Buffer::Buffer(::ibv_pd* pd, char* const b, const int32_t s) :
-        bytes(b),
-        byteCount(s),
-        dataStart(0),
-        dataCount(0),
+    Buffer::Buffer(::ibv_pd* pd, const int32_t s) :
+        bufferSize(s),
         mr(CHECK_NULL(::ibv_reg_mr(
-        pd, bytes, byteCount,
+        pd, new char[s], s,
         ::IBV_ACCESS_LOCAL_WRITE)))
-    {}
+    {
+        sge.addr = (uintptr_t) mr->addr;
+        sge.length = 0;
+        sge.lkey = mr->lkey;
+    }
 
     Buffer::~Buffer() {
         (void) ::ibv_dereg_mr(mr);
-        delete [] bytes;
+        delete [] bytes();
     }
 
     QueuePairEvent::QueuePairEvent() :
@@ -106,7 +107,7 @@ namespace Rdma {
 
     Buffer* QueuePairEvent::getBuffer() const {
         Buffer* b = reinterpret_cast<Buffer*>(wc.wr_id);
-        b->dataCount = wc.byte_len;
+        b->dataCount(wc.byte_len);
         return b;
     }
 
@@ -157,7 +158,7 @@ namespace Rdma {
 
     // Create a buffer to use for writing
     Buffer* QueuePair::createBuffer(int s) {
-        return new Buffer(pd.get(), new char[s], s);
+        return new Buffer(pd.get(), s);
     }
 
     // Make channel non-blocking by making
@@ -213,14 +214,11 @@ namespace Rdma {
 
     void QueuePair::postRecv(Buffer* buf) {
         ::ibv_recv_wr rwr = {};
-        ::ibv_sge sge;
-
-        sge.addr = (uintptr_t) buf->bytes+buf->dataStart;
-        sge.length = buf->dataCount;
-        sge.lkey = buf->mr->lkey;
 
         rwr.wr_id = reinterpret_cast<uint64_t>(buf);
-        rwr.sg_list = &sge;
+        // We are given the whole buffer
+        buf->dataCount(buf->byteCount());
+        rwr.sg_list = &buf->sge;
         rwr.num_sge = 1;
 
         ::ibv_recv_wr* badrwr = 0;
@@ -231,16 +229,11 @@ namespace Rdma {
 
     void QueuePair::postSend(Buffer* buf) {
         ::ibv_send_wr swr = {};
-        ::ibv_sge sge;
-
-        sge.addr = (uintptr_t) buf->bytes+buf->dataStart;
-        sge.length = buf->dataCount;
-        sge.lkey = buf->mr->lkey;
 
         swr.wr_id = reinterpret_cast<uint64_t>(buf);
         swr.opcode = IBV_WR_SEND;
         swr.send_flags = IBV_SEND_SIGNALED;
-        swr.sg_list = &sge;
+        swr.sg_list = &buf->sge;
         swr.num_sge = 1;
 
         ::ibv_send_wr* badswr = 0;
@@ -251,17 +244,12 @@ namespace Rdma {
 
     void QueuePair::postSend(uint32_t imm, Buffer* buf) {
         ::ibv_send_wr swr = {};
-        ::ibv_sge sge;
-
-        sge.addr = (uintptr_t) buf->bytes+buf->dataStart;
-        sge.length = buf->dataCount;
-        sge.lkey = buf->mr->lkey;
-        swr.send_flags = IBV_SEND_SIGNALED;        
 
         swr.wr_id = reinterpret_cast<uint64_t>(buf);
         swr.imm_data = htonl(imm);
         swr.opcode = IBV_WR_SEND_WITH_IMM;
-        swr.sg_list = &sge;
+        swr.send_flags = IBV_SEND_SIGNALED;
+        swr.sg_list = &buf->sge;
         swr.num_sge = 1;
 
         ::ibv_send_wr* badswr = 0;
diff --git a/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.h b/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.h
index 5803ae5..54066d1 100644
--- a/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.h
+++ b/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.h
@@ -45,19 +45,38 @@ namespace Rdma {
 
     struct Buffer {
         friend class QueuePair;
+        friend class QueuePairEvent;
 
-        char* const bytes;
-        const int32_t byteCount;
-        int32_t dataStart;
-        int32_t dataCount;
+        char* bytes() const;
+        int32_t byteCount() const;
+        int32_t dataCount() const;
+        void dataCount(int32_t);
 
-        Buffer(::ibv_pd* pd, char* const b, const int32_t s);
+        Buffer(::ibv_pd* pd, const int32_t s);
         ~Buffer();
 
     private:
+        const int32_t bufferSize;
         ::ibv_mr* mr;
+        ::ibv_sge sge;
     };
 
+    inline char* Buffer::bytes() const {
+      return (char*) sge.addr;
+    }
+
+    inline int32_t Buffer::byteCount() const {
+        return bufferSize;
+    }
+
+    inline int32_t Buffer::dataCount() const {
+        return sge.length;
+    }
+
+    inline void Buffer::dataCount(int32_t s) {
+        sge.length = s;
+    }
+
     class Connection;
 
     enum QueueDirection {
-- 
1.5.5.6

From 6bd302f9945099ce7d0d1c021b2aee44c5d6a368 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:36 +0000
Subject: [PATCH] BZ 591139: Ensure that we can't shutdown in the middle of writing a buffer

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954497 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/client/RdmaConnector.cpp |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/RdmaConnector.cpp b/qpid/cpp/src/qpid/client/RdmaConnector.cpp
index 3b4e87d..504c5bd 100644
--- a/qpid/cpp/src/qpid/client/RdmaConnector.cpp
+++ b/qpid/cpp/src/qpid/client/RdmaConnector.cpp
@@ -320,6 +320,7 @@ void RdmaConnector::send(AMQFrame& frame) {
 // This is NOT only called in response to previously calling notifyPendingWrite
 void RdmaConnector::writebuff(Rdma::AsynchIO&) {
     // It's possible to be disconnected and be writable
+    Mutex::ScopedLock l(pollingLock);
     if (!polling)
         return;
 
-- 
1.5.5.6

From 196b1674c86d5c0fbea21ddf8f19b0c18f590d85 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:40 +0000
Subject: [PATCH] BZ 591139: Move QueuePair member in Rdma::AsynchIO to ensure that it get destroyed before
 the buffers it uses, so that there is no hardware activity using them after
 they are deleted

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954498 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp |    4 ++--
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.h   |    6 ++++--
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index 3b49e97..25301e9 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -41,8 +41,6 @@ namespace Rdma {
             FullCallback fc,
             ErrorCallback ec
     ) :
-        qp(q),
-        dataHandle(*qp, boost::bind(&AsynchIO::dataEvent, this), 0, 0),
         bufferSize(size),
         recvCredit(0),
         xmitCredit(xCredit),
@@ -51,6 +49,8 @@ namespace Rdma {
         outstandingWrites(0),
         draining(false),
         state(IDLE),
+        qp(q),
+        dataHandle(*qp, boost::bind(&AsynchIO::dataEvent, this), 0, 0),
         readCallback(rc),
         idleCallback(ic),
         fullCallback(fc),
diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
index 655119b..4cd0e08 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
@@ -47,8 +47,6 @@ namespace Rdma {
         typedef boost::function2<void, AsynchIO&, Buffer*> FullCallback;
         typedef boost::function1<void, AsynchIO&> NotifyCallback;
 
-        QueuePair::intrusive_ptr qp;
-        qpid::sys::DispatchHandleRef dataHandle;
         int bufferSize;
         int recvCredit;
         int xmitCredit;
@@ -62,6 +60,10 @@ namespace Rdma {
         std::deque<Buffer*> bufferQueue;
         qpid::sys::Mutex bufferQueueLock;
         boost::ptr_deque<Buffer> buffers;
+        // The QueuePair must be after the buffers so that the connection is destroyed before the buffers
+        // are deallocated so that the hardware doesn't write into memory that's been given back.
+        QueuePair::intrusive_ptr qp;
+        qpid::sys::DispatchHandleRef dataHandle;
 
         ReadCallback readCallback;
         IdleCallback idleCallback;
-- 
1.5.5.6

From ae9ad6a317c1e9ecf47a675f32ebbeda7970d248 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:44 +0000
Subject: [PATCH] BZ 591139: Allow entry into notifyPendingWrite() if already stopped as it is too hard
 to eliminate a race that can cause this, and it is essentially harmless if
 ignored

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954499 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index 25301e9..845e84e 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -210,8 +210,8 @@ namespace Rdma {
                 newState = NOTIFY_WRITE;
                 break;
             case SHUTDOWN:
-                // This is not allowed - we can't make any more writes as we shut the connection down.
-                assert(oldState!=SHUTDOWN);
+                // We can get here because it is too hard to eliminate all races of stop() and notifyPendingWrite()
+                // just do nothing.
                 doReturn = true;
             case DRAINED:
                 // This is not allowed - we can't make any more writes as we're draining the write queue.
-- 
1.5.5.6

From 0050474676ddfd57fc10e5b845dd085f5841aec4 Mon Sep 17 00:00:00 2001
From: Stephen D. Huston <shuston@apache.org>
Date: Wed, 19 May 2010 21:28:38 +0000
Subject: [PATCH] Correct class/struct reference; resolves compile warning on Windows.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@946407 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 0f5cd165647af0c5d0791bad309c249bc0996af1)
---
 qpid/cpp/include/qpid/Address.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/include/qpid/Address.h b/qpid/cpp/include/qpid/Address.h
index 71da7b2..57c9139 100755
--- a/qpid/cpp/include/qpid/Address.h
+++ b/qpid/cpp/include/qpid/Address.h
@@ -25,7 +25,7 @@
 #include <string>
 
 namespace qpid {
-namespace client { class ConnectionSettings; }
+namespace client { struct ConnectionSettings; }
 
 
 /**
-- 
1.5.5.6

From 512db9306e1ac6cf8f05f7a646d36f282f88293e Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Tue, 25 May 2010 15:13:08 +0000
Subject: [PATCH] QPID-2617: Fix the windows build for modified method signature

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@948072 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 14862cf97c47355ba21e96429c73848a4d2f6f64)
---
 .../src/qpid/broker/windows/SaslAuthenticator.cpp  |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp b/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp
index 642be29..608a8f7 100644
--- a/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp
+++ b/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp
@@ -68,7 +68,7 @@ bool SaslAuthenticator::available(void)
 }
 
 // Initialize the SASL mechanism; throw if it fails.
-void SaslAuthenticator::init(const std::string& /*saslName*/)
+void SaslAuthenticator::init(const std::string& /*saslName*/, const std::string& /*saslConfig*/)
 {
     return;
 }
-- 
1.5.5.6

From 088dea32ededd4c4e205202c7733f3db08846a1c Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Fri, 28 May 2010 18:09:10 +0000
Subject: [PATCH] Bug 603805 - .NET bindings for the C++ Messaging API

QPID-2628 - Patch from Chuck Rolke

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@949245 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 9e522de1ececed29fa9c0a02caa535c4f235b486)
---
 qpid/cpp/bindings/qpid/dotnet/ReadMe.txt           |   33 +-
 .../csharp.direct.receiver.cs                      |   19 +-
 .../csharp.direct.receiver.csproj                  |   12 +-
 .../csharp.direct.sender/csharp.direct.sender.cs   |   15 +-
 .../csharp.direct.sender.csproj                    |   12 +-
 .../Properties/AssemblyInfo.cs                     |   54 ++
 .../csharp.map.callback.receiver.cs                |  280 +++++++++++
 .../csharp.map.callback.receiver.csproj            |   69 +++
 .../Properties/AssemblyInfo.cs                     |   54 ++
 .../csharp.map.callback.sender.cs                  |  146 ++++++
 .../csharp.map.callback.sender.csproj              |   66 +++
 .../csharp.map.receiver/csharp.map.receiver.csproj |   16 +-
 .../csharp.map.receiver/csharp.map.recevier.cs     |    4 +-
 .../csharp.map.sender/csharp.map.sender.csproj     |   12 +-
 .../qpid/dotnet/org.apache.qpid.messaging.sln      |   44 ++
 qpid/cpp/bindings/qpid/dotnet/src/Address.cpp      |  186 +++++++
 qpid/cpp/bindings/qpid/dotnet/src/Address.h        |   89 ++++
 qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp   |  194 +++++++-
 qpid/cpp/bindings/qpid/dotnet/src/Connection.h     |   21 +-
 qpid/cpp/bindings/qpid/dotnet/src/Duration.h       |   65 ++-
 qpid/cpp/bindings/qpid/dotnet/src/Message.cpp      |  515 +++++---------------
 qpid/cpp/bindings/qpid/dotnet/src/Message.h        |   82 ++--
 qpid/cpp/bindings/qpid/dotnet/src/QpidException.h  |   38 ++
 qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h    |    1 +
 qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h  |   75 +++
 qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp     |  145 +++++-
 qpid/cpp/bindings/qpid/dotnet/src/Receiver.h       |   20 +-
 qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp       |   29 +-
 qpid/cpp/bindings/qpid/dotnet/src/Sender.h         |   33 +-
 qpid/cpp/bindings/qpid/dotnet/src/Session.cpp      |  305 ++++++++++--
 qpid/cpp/bindings/qpid/dotnet/src/Session.h        |   47 ++-
 .../bindings/qpid/dotnet/src/TypeTranslator.cpp    |  411 ++++++++++++++++
 qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h |   70 +++
 qpid/cpp/bindings/qpid/dotnet/src/app.rc           |    1 +
 .../qpid/dotnet/src/org.apache.qpid.messaging.rc   |  101 ++++
 .../dotnet/src/org.apache.qpid.messaging.vcproj    |   34 +-
 qpid/cpp/bindings/qpid/dotnet/src/qpid.snk         |  Bin 0 -> 596 bytes
 qpid/cpp/bindings/qpid/dotnet/src/resource.h       |   22 -
 qpid/cpp/bindings/qpid/dotnet/src/resource1.h      |   14 +
 .../src/sessionreceiver/Properties/AssemblyInfo.cs |   55 ++
 ...rg.apache.qpid.messaging.sessionreceiver.csproj |   65 +++
 .../dotnet/src/sessionreceiver/sessionreceiver.cs  |  133 +++++
 .../dotnet/test/messaging.test/messaging.test.cs   |   62 +++-
 .../test/messaging.test/messaging.test.csproj      |   18 +-
 44 files changed, 2997 insertions(+), 670 deletions(-)
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/Address.h
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/QpidException.h
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/qpid.snk
 delete mode 100644 qpid/cpp/bindings/qpid/dotnet/src/resource.h
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/resource1.h
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs

diff --git a/qpid/cpp/bindings/qpid/dotnet/ReadMe.txt b/qpid/cpp/bindings/qpid/dotnet/ReadMe.txt
index 66ac7ae..faa1b79 100644
--- a/qpid/cpp/bindings/qpid/dotnet/ReadMe.txt
+++ b/qpid/cpp/bindings/qpid/dotnet/ReadMe.txt
@@ -3,31 +3,46 @@ Qpid.cpp.bindings.qpid.dotnet binding package.
 1. Features
 ===========
 
-This binding package is a .NET Interop wrapper around the Qpid Messaging interface.
-It exposes the Messaging interface through a series of managed code classes that
-may be used by any .NET language.
+A. This binding package provides a .NET Interop wrapper around the C++ 
+   Qpid Messaging interface. It exposes the Messaging interface through 
+   a series of managed code classes that may be used by any .NET language.
+
+B. A sessionreceiver assembly provides session callback functionality
+   above the C++ layer.
 
 2. Prerequisites
 ================
 
-1. A build of the Qpid C++ libraries is available. 
+A. A build of the Qpid C++ libraries is available. 
 
-2. Refer to this library using environment variable QPID_BUILD_ROOT.
+B. Refer to this library using environment variable QPID_BUILD_ROOT.
 
    for example: SET QPID_BUILD_ROOT=D:\users\submitter\svn\qpid\cpp
 
 3. Building the solution
 ========================
 
-1. Build the solution.
+A. The solution is cpp\bindings\qpid\dotnet\org.apache.qpid.messaging.sln
+
+B. Build the solution (Debug only - Release is not set up yet).
 
-4. Runing the examples
+C. Project output goes to %QPID_BUILD_ROOT%\src\Debug. This puts all the
+   solution artifacts is the same directory as the C++ DLLs.
+   
+
+4. Running the examples
 ======================
 
-CWIP
+A. csharp.direct.receiver
+B. csharp.direct.sender
+C. csharp.map.receiver
+D. csharp.map.sender
+E. csharp.map.callback.receiver
+F. csharp.map.callback.sender
+
 
 5. Running the tests
 ====================
 
-CWIP
+A. messaging.test
 
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
index 6cc2a5e..4888023 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
@@ -37,7 +37,20 @@ namespace CSharpDirect
         {
             String host = "localhost:5672";
             String addr = "amq.direct/key";
-            int    nMsg = 10;
+            Int32 nMsg = 10;
+
+            if (args.Length > 0)
+                host = args[0];
+            if (args.Length > 1)
+                addr = args[1];
+            if (args.Length > 2)
+                nMsg = Convert.ToInt32(args[2]);
+
+            Console.WriteLine("csharp.direct.receiver");
+            Console.WriteLine("host : {0}", host);
+            Console.WriteLine("addr : {0}", addr);
+            Console.WriteLine("nMsg : {0}", nMsg);
+            Console.WriteLine();
 
             Connection conn = new Connection(host);
 
@@ -52,7 +65,7 @@ namespace CSharpDirect
 
                 Session sess = conn.createSession();
 
-                Duration dur = new Duration(1000 * 3600 * 24); // Wait one day
+                Duration dura = new Duration(3600000); // wait forever
 
                 Receiver rcv = sess.createReceiver(addr);
 
@@ -62,7 +75,7 @@ namespace CSharpDirect
                 {
                     try
                     {
-                        Message msg2 = rcv.fetch(dur);
+                        Message msg2 = rcv.fetch(dura);
                         Console.WriteLine("Rcvd msg {0} : {1}", i, msg2.getContent());
                     }
                     catch (Exception e)
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
index 8cb4826..7bfcfb8 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
@@ -17,7 +17,7 @@
     <DebugSymbols>true</DebugSymbols>
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
@@ -31,10 +31,6 @@
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
   <ItemGroup>
-    <Reference Include="org.apache.qpid.messagingd, Version=1.0.3779.23054, Culture=neutral, PublicKeyToken=679e1f50b62dbace, processorArchitecture=x86">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\bin\Debug\org.apache.qpid.messagingd.dll</HintPath>
-    </Reference>
     <Reference Include="System" />
     <Reference Include="System.Core">
       <RequiredTargetFramework>3.5</RequiredTargetFramework>
@@ -52,6 +48,12 @@
     <Compile Include="csharp.direct.receiver.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
   </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
index bf49787..1fe56aa 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
@@ -33,7 +33,20 @@ namespace csharp.direct.sender
         {
             String host = "localhost:5672";
             String addr = "amq.direct/key";
-            int nMsg = 10;
+            Int32 nMsg = 10;
+
+            if (args.Length > 0)
+                host = args[0];
+            if (args.Length > 1)
+                addr = args[1];
+            if (args.Length > 2)
+                nMsg = Convert.ToInt32(args[2]);
+
+            Console.WriteLine("csharp.direct.sender");
+            Console.WriteLine("host : {0}", host);
+            Console.WriteLine("addr : {0}", addr);
+            Console.WriteLine("nMsg : {0}", nMsg);
+            Console.WriteLine();
 
             Connection conn = new Connection(host);
 
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
index f109d64..7ff92e1 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
@@ -17,7 +17,7 @@
     <DebugSymbols>true</DebugSymbols>
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
@@ -31,10 +31,6 @@
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
   <ItemGroup>
-    <Reference Include="org.apache.qpid.messagingd, Version=1.0.3779.23054, Culture=neutral, PublicKeyToken=679e1f50b62dbace, processorArchitecture=x86">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\bin\Debug\org.apache.qpid.messagingd.dll</HintPath>
-    </Reference>
     <Reference Include="System" />
     <Reference Include="System.Core">
       <RequiredTargetFramework>3.5</RequiredTargetFramework>
@@ -52,6 +48,12 @@
     <Compile Include="csharp.direct.sender.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
   </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..8e2add1
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/Properties/AssemblyInfo.cs
@@ -0,0 +1,54 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.map.receiver")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.map.receiver")]
+[assembly: AssemblyCopyright("Copyright   2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("002049f9-41c5-420f-9ff6-45bb652dded6")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
new file mode 100644
index 0000000..e7294c6
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
@@ -0,0 +1,280 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using System.Collections.Generic;
+using org.apache.qpid.messaging;
+using org.apache.qpid.messaging.sessionreceiver;
+
+namespace org.apache.qpid.messaging.examples
+{
+    /// <summary>
+    /// A class with functions to display structured messages.
+    /// </summary>
+    public static class MessageViewer
+    {
+        /// <summary>
+        /// A Function to display a amqp/map message packaged as a Dictionary.
+        /// </summary>
+        /// <param name="dict">The AMQP map</param>
+        /// <param name="level">Nested depth</param>
+        public static void ShowDictionary(Dictionary<string, object> dict, int level)
+        {
+            foreach (KeyValuePair<string, object> kvp in dict)
+            {
+                Console.Write(new string(' ', level * 4));
+
+                if (QpidTypeCheck.ObjectIsMap(kvp.Value))
+                {
+                    Console.WriteLine("Key: {0}, Value: Dictionary", kvp.Key);
+                    ShowDictionary((Dictionary<string, object>)kvp.Value, level + 1);
+                }
+                else if (QpidTypeCheck.ObjectIsList(kvp.Value))
+                {
+                    Console.WriteLine("Key: {0}, Value: List", kvp.Key);
+                    ShowList((List<object>)kvp.Value, level + 1);
+                }
+                else
+                    Console.WriteLine("Key: {0}, Value: {1}, Type: {2}",
+                        kvp.Key, kvp.Value, kvp.Value.GetType().ToString());
+            }
+        }
+
+        /// <summary>
+        /// A function to display a ampq/list message packaged as a List.
+        /// </summary>
+        /// <param name="list">The AMQP list</param>
+        /// <param name="level">Nested depth</param>
+        public static void ShowList(List<object> list, int level)
+        {
+            foreach (object obj in list)
+            {
+                Console.Write(new string(' ', level * 4));
+
+                if (QpidTypeCheck.ObjectIsMap(obj))
+                {
+                    Console.WriteLine("Dictionary");
+                    ShowDictionary((Dictionary<string, object>)obj, level + 1);
+                }
+                else if (QpidTypeCheck.ObjectIsList(obj))
+                {
+                    Console.WriteLine("List");
+                    ShowList((List<object>)obj, level + 1);
+                }
+                else
+                    Console.WriteLine("Value: {0}, Type: {1}",
+                        obj.ToString(), obj.GetType().ToString());
+            }
+        }
+
+        /// <summary>
+        /// A function to diplay a Message. The native Object type is
+        /// decomposed into AMQP types.
+        /// </summary>
+        /// <param name="message">The Message</param>
+        public static void ShowMessage(Message message)
+        {
+            if ("amqp/map" == message.getContentType())
+            {
+                Console.WriteLine("Received a Dictionary");
+                Dictionary<string, object> content = new Dictionary<string, object>();
+                message.getContent(content);
+                ShowDictionary(content, 0);
+            }
+            else if ("amqp/list" == message.getContentType())
+            {
+                Console.WriteLine("Received a List");
+                List<object> content = new List<object>();
+                message.getContent(content);
+                ShowList(content, 0);
+            }
+            else
+            {
+                Console.WriteLine("Received a String");
+                Console.WriteLine(message.getContent());
+            }
+        }
+    }
+
+
+
+    /// <summary>
+    /// A model class to demonstrate how a user may use the Qpid Messaging
+    /// interface to receive Session messages using a callback.
+    /// </summary>
+    class ReceiverProcess : ISessionReceiver
+    {
+        UInt32 messagesReceived = 0;
+
+        /// <summary>
+        /// SessionReceiver implements the ISessionReceiver interface.
+        /// It is the callback function that receives all messages for a Session.
+        /// It may be called any time server is running.
+        /// It is always called on server's private thread.
+        /// </summary>
+        /// <param name="receiver">The Receiver associated with the message.</param>
+        /// <param name="message">The Message</param>
+        public void SessionReceiver(Receiver receiver, Message message)
+        {
+            //
+            // Indicate message reception
+            //
+            Console.WriteLine("--- Message {0}", ++messagesReceived);
+
+            //
+            // Display the received message
+            //
+            MessageViewer.ShowMessage(message);
+
+            //
+            // Acknowledge the receipt of all received messages.
+            //
+            receiver.getSession().acknowledge();
+        }
+
+
+        /// <summary>
+        /// Usage
+        /// </summary>
+        /// <param name="url">Connection target</param>
+        /// <param name="addr">Address: broker exchange + routing key</param>
+        /// <param name="nSec">n seconds to keep callback open</param>
+        static void usage(string url, string addr, int nSec)
+        {
+
+            Console.WriteLine("usage: {0} [url  [addr [nSec]]]",
+                System.Diagnostics.Process.GetCurrentProcess().ProcessName);
+            Console.WriteLine();
+            Console.WriteLine("A program to connect to a broker and receive");
+            Console.WriteLine("messages from a named exchange with a routing key.");
+            Console.WriteLine("The receiver uses a session callback and keeps the callback");
+            Console.WriteLine("server open for so many seconds.");
+            Console.WriteLine("The details of the message body's types and values are shown.");
+            Console.WriteLine();
+            Console.WriteLine(" url  = target address for 'new Connection(url)'");
+            Console.WriteLine(" addr = address for 'session.createReceiver(addr)'");
+            Console.WriteLine(" nSec = time in seconds to keep the receiver callback open");
+            Console.WriteLine();
+            Console.WriteLine("Default values:");
+            Console.WriteLine("  {0} {1} {2} {3}",
+                System.Diagnostics.Process.GetCurrentProcess().ProcessName,
+                url, addr, nSec);
+        }
+
+
+        /// <summary>
+        /// A function to illustrate how to open a Session callback and
+        /// receive messages.
+        /// </summary>
+        /// <param name="args">Main program arguments</param>
+        public void TestProgram(string[] args)
+        {
+            string url = "amqp:tcp:localhost:5672";
+            string addr = "amq.direct/map_example";
+            int nSec = 30;
+
+            if (1 == args.Length)
+            {
+                if (args[0].Equals("-h") || args[0].Equals("-H") || args[0].Equals("/?"))
+                {
+                    usage(url, addr, nSec);
+                    return;
+                }
+            }
+
+            if (args.Length > 0)
+                url = args[0];
+            if (args.Length > 1)
+                addr = args[1];
+            if (args.Length > 2)
+                nSec = System.Convert.ToInt32(args[2]);
+
+            //
+            // Create and open an AMQP connection to the broker URL
+            //
+            Connection connection = new Connection(url);
+            connection.open();
+
+            //
+            // Create a session.
+            //
+            Session session = connection.createSession();
+
+            //
+            // Receive through callback
+            //
+            // Create callback server and implicitly start it
+            //
+            sessionreceiver.server cbServer =
+                new sessionreceiver.server(session, this);
+
+            //
+            // The callback server is running and executing callbacks on a
+            // separate thread.
+            //
+
+            //
+            // Create a receiver for the direct exchange using the
+            // routing key "map_example".
+            //
+            Receiver receiver = session.createReceiver(addr);
+
+            //
+            // Establish a capacity
+            //
+            receiver.setCapacity(100);
+
+            //
+            // Wait so many seconds for messages to arrive.
+            //
+            System.Threading.Thread.Sleep(nSec * 1000);   // in mS
+
+            //
+            // Stop the callback server.
+            //
+            cbServer.close();
+
+            //
+            // Close the receiver and the connection.
+            //
+            receiver.close();
+            connection.close();
+        }
+    }
+
+
+    class MapCallbackReceiverMain
+    {
+        /// <summary>
+        /// Main program
+        /// </summary>
+        /// <param name="args">Main prgram args</param>
+        static void Main(string[] args)
+        {
+            // Invoke 'TestProgram' as non-static class.
+            ReceiverProcess mainProc = new ReceiverProcess();
+
+            mainProc.TestProgram(args);
+
+        }
+    }
+}
+
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
new file mode 100644
index 0000000..e8aae4b
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
@@ -0,0 +1,69 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{68A43817-2358-4A31-8FDF-FE21722BFBCF}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.map.callback.receiver</RootNamespace>
+    <AssemblyName>csharp.map.callback.receiver</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.map.callback.receiver.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\..\src\sessionreceiver\org.apache.qpid.messaging.sessionreceiver.csproj">
+      <Project>{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}</Project>
+      <Name>org.apache.qpid.messaging.sessionreceiver</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..1f84944
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/Properties/AssemblyInfo.cs
@@ -0,0 +1,54 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.map.sender")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.map.sender")]
+[assembly: AssemblyCopyright("Copyright   2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("1eec2eca-adbd-4394-8b01-f4c4645bb122")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
new file mode 100644
index 0000000..a097267
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
@@ -0,0 +1,146 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using org.apache.qpid.messaging;
+
+namespace org.apache.qpid.messaging.examples
+{
+    class MapSender
+    {
+        //
+        // usage
+        //
+        static void usage(string url, string addr, UInt32 count)
+        {
+
+            Console.WriteLine("usage: {0} [url  [addr [count]]]",
+                System.Diagnostics.Process.GetCurrentProcess().ProcessName);
+            Console.WriteLine();
+            Console.WriteLine("A program to connect to a broker and send N");
+            Console.WriteLine("messages to a named exchange with a routing key.");
+            Console.WriteLine();
+            Console.WriteLine(" url = target address for 'new Connection(url)'");
+            Console.WriteLine(" addr = address for 'session.createReceiver(addr)'");
+            Console.WriteLine(" count = number of messages to send");
+            Console.WriteLine();
+            Console.WriteLine("Default values:");
+            Console.WriteLine("  {0} {1} {2} {3}",
+                System.Diagnostics.Process.GetCurrentProcess().ProcessName,
+                url, addr, count);
+        }
+
+        
+        //
+        // TestProgram
+        //
+        public void TestProgram(string[] args)
+        {
+            string url = "amqp:tcp:localhost:5672";
+            string addr = "amq.direct/map_example";
+            UInt32 count = 1;
+
+            if (1 == args.Length)
+            {
+                if (args[0].Equals("-h") || args[0].Equals("-H") || args[0].Equals("/?"))
+                {
+                    usage(url, addr, count);
+                    return;
+                }
+            }
+
+            if (args.Length > 0)
+                url = args[0];
+            if (args.Length > 1)
+                addr = args[1];
+            if (args.Length > 2)
+                count = System.Convert.ToUInt32(args[2]);
+
+            
+            //
+            // Create and open an AMQP connection to the broker URL
+            //
+            Connection connection = new Connection(url);
+            connection.open();
+
+            //
+            // Create a session and a sender to the direct exchange using the
+            // routing key "map_example".
+            //
+            Session session = connection.createSession();
+            Sender sender = session.createSender(addr);
+
+            //
+            // Create structured content for the message.  This example builds a
+            // map of items including a nested map and a list of values.
+            //
+            Dictionary<string, object> content = new Dictionary<string, object>();
+            Dictionary<string, object> subMap = new Dictionary<string, object>();
+            List<object> colors = new List<object>();
+
+            content["id"] = 987654321;
+            content["name"] = "Widget";
+            content["percent"] = 0.99;
+
+            subMap["name"] = "Smith";
+            subMap["number"] = 354;
+
+            content["nested"] = subMap;
+
+            colors.Add("red");
+            colors.Add("green");
+            colors.Add("white");
+
+            content["colors"] = colors;
+
+            //
+            // Construct a message with the map content and send it synchronously
+            // via the sender.
+            //
+            Message message = new Message(content);
+            for (UInt32 i = 0; i<count; i++)
+                sender.send(message, true);
+
+            //
+            // Close the connection.
+            //
+            connection.close();
+        }
+    }
+
+    class MapSenderMain
+    {
+        //
+        // Main
+        //
+        static void Main(string[] args)
+        {
+            // Invoke 'TestProgram' as non-static class.
+            MapSender mainProc = new MapSender();
+
+            mainProc.TestProgram(args);
+
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
new file mode 100644
index 0000000..5089737
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
@@ -0,0 +1,66 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{12F1C14F-5C7D-4075-9BAE-C091394FF99A}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.map.callback.sender</RootNamespace>
+    <AssemblyName>csharp.map.callback.sender</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.map.callback.sender.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
index a491274..380e33b 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
@@ -17,7 +17,7 @@
     <DebugSymbols>true</DebugSymbols>
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
@@ -31,10 +31,6 @@
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
   <ItemGroup>
-    <Reference Include="org.apache.qpid.messagingd, Version=1.0.3786.14109, Culture=neutral, PublicKeyToken=7e57166074abee8c, processorArchitecture=x86">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\bin\Debug\org.apache.qpid.messagingd.dll</HintPath>
-    </Reference>
     <Reference Include="System" />
     <Reference Include="System.Core">
       <RequiredTargetFramework>3.5</RequiredTargetFramework>
@@ -52,6 +48,16 @@
     <Compile Include="csharp.map.recevier.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
   </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\..\src\sessionreceiver\org.apache.qpid.messaging.sessionreceiver.csproj">
+      <Project>{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}</Project>
+      <Name>org.apache.qpid.messaging.sessionreceiver</Name>
+    </ProjectReference>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
index 461708e..9a425c0 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
@@ -29,8 +29,8 @@ namespace org.apache.qpid.messaging.examples
     {
         static void Main(string[] args)
         {
-//            string url = "amqp:tcp:localhost:5672";
-            string url = "10.16.18.254:5672";
+            string url = "amqp:tcp:localhost:5672";
+//            string url = "10.16.18.254:5672";
             if (args.Length > 0)
                 url = args[0];
 
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
index d647509..4482e6a 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
@@ -17,7 +17,7 @@
     <DebugSymbols>true</DebugSymbols>
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
@@ -31,10 +31,6 @@
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
   <ItemGroup>
-    <Reference Include="org.apache.qpid.messagingd, Version=1.0.3786.14109, Culture=neutral, PublicKeyToken=7e57166074abee8c, processorArchitecture=x86">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\bin\Debug\org.apache.qpid.messagingd.dll</HintPath>
-    </Reference>
     <Reference Include="System" />
     <Reference Include="System.Core">
       <RequiredTargetFramework>3.5</RequiredTargetFramework>
@@ -52,6 +48,12 @@
     <Compile Include="csharp.map.sender.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
   </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
index 0619727..8b0b3fd 100644
--- a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
+++ b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
@@ -28,8 +28,20 @@ EndProject
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "StructuredMessage", "StructuredMessage", "{E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}"
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.map.sender", "examples\csharp.map.sender\csharp.map.sender.csproj", "{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}"
+	ProjectSection(ProjectDependencies) = postProject
+		{AA5A3B83-5F98-406D-A01C-5A921467A57D} = {AA5A3B83-5F98-406D-A01C-5A921467A57D}
+	EndProjectSection
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.map.receiver", "examples\csharp.map.receiver\csharp.map.receiver.csproj", "{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}"
+	ProjectSection(ProjectDependencies) = postProject
+		{AA5A3B83-5F98-406D-A01C-5A921467A57D} = {AA5A3B83-5F98-406D-A01C-5A921467A57D}
+	EndProjectSection
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "org.apache.qpid.messaging.sessionreceiver", "src\sessionreceiver\org.apache.qpid.messaging.sessionreceiver.csproj", "{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.map.callback.receiver", "examples\csharp.map.callback.receiver\csharp.map.callback.receiver.csproj", "{68A43817-2358-4A31-8FDF-FE21722BFBCF}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.map.callback.sender", "examples\csharp.map.callback.sender\csharp.map.callback.sender.csproj", "{12F1C14F-5C7D-4075-9BAE-C091394FF99A}"
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -101,6 +113,36 @@ Global
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Win32.ActiveCfg = Release|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Any CPU.Build.0 = Release|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Mixed Platforms.Build.0 = Release|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Win32.ActiveCfg = Release|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Any CPU.Build.0 = Release|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Mixed Platforms.Build.0 = Release|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Win32.ActiveCfg = Release|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Any CPU.Build.0 = Release|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Mixed Platforms.Build.0 = Release|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Win32.ActiveCfg = Release|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
@@ -114,5 +156,7 @@ Global
 		{AF2FBC78-266C-430C-BC29-9477AB596A36} = {39E9D1BF-3A0B-4D86-BF6B-F463E1A2245A}
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
 	EndGlobalSection
 EndGlobal
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
new file mode 100644
index 0000000..8b48a20
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
@@ -0,0 +1,186 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+#include <windows.h>
+#include <msclr\lock.h>
+#include <oletx2xa.h>
+#include <string>
+#include <limits>
+
+#include "qpid/messaging/Address.h"
+
+#include "Address.h"
+#include "QpidMarshal.h"
+#include "QpidTypeCheck.h"
+#include "TypeTranslator.h"
+
+namespace org {
+namespace apache {
+namespace qpid {
+namespace messaging {
+
+    /// <summary>
+    /// Address is a managed wrapper for a qpid::messaging::Address
+    /// </summary>
+
+    // Create empty
+    Address::Address() :
+        addressp(new ::qpid::messaging::Address(QpidMarshal::ToNative("")))
+    {
+    }
+
+    // Create string address
+    Address::Address(System::String ^ address) :
+        addressp(new ::qpid::messaging::Address(QpidMarshal::ToNative(address)))
+    {
+    }
+
+    // Create with options
+    Address::Address(System::String ^ name, 
+                     System::String ^ subject,
+                     System::Collections::Generic::Dictionary<
+                         System::String ^, System::Object ^> ^ options) :
+        addressp(new ::qpid::messaging::Address())
+    {
+        setName(name);
+        setSubject(subject);
+        setOptions(options);
+        setType("");
+    }
+
+
+    Address::Address(System::String ^ name, 
+                     System::String ^ subject,
+                     System::Collections::Generic::Dictionary<
+                         System::String ^, System::Object ^> ^ options,
+                     System::String ^ type) :
+        addressp(new ::qpid::messaging::Address())
+    {
+        setName(name);
+        setSubject(subject);
+        setOptions(options);
+        setType(type);
+    }
+
+
+    // Create from received address
+    Address::Address(::qpid::messaging::Address * addrp) :
+        addressp(addrp)
+    {
+    }
+
+    // Destructor
+    Address::~Address()
+    {
+        Cleanup();
+    }
+
+
+    // Finalizer
+    Address::!Address()
+    {
+        Cleanup();
+    }
+
+
+    // Destroys kept object
+    // TODO: add lock
+    void Address::Cleanup()
+    {
+        if (NULL != addressp)
+        {
+            delete addressp;
+            addressp = NULL;
+        }
+    }
+
+
+    //
+    // name
+    //
+    System::String ^ Address::getName()
+    {
+        return gcnew System::String(addressp->getName().c_str());
+    }
+
+    void Address::setName(System::String ^ name)
+    {
+        addressp->::qpid::messaging::Address::setName(QpidMarshal::ToNative(name));
+    }
+
+    //
+    // subject
+    //
+    System::String ^ Address::getSubject()
+    {
+        return gcnew System::String(addressp->getSubject().c_str());
+    }
+
+    void Address::setSubject(System::String ^ subject)
+    {
+        addressp->setName(QpidMarshal::ToNative(subject));
+    }
+
+    //
+    // options
+    //
+    System::Collections::Generic::Dictionary<
+        System::String ^, System::Object ^> ^ Address::getOptions()
+    {
+        ::qpid::types::Variant::Map map;
+        System::Collections::Generic::Dictionary<
+            System::String ^, System::Object ^> ^ newMap = 
+            gcnew System::Collections::Generic::Dictionary<
+                  System::String ^, System::Object ^>;
+        map = addressp->getOptions();
+        TypeTranslator::NativeToManaged(newMap, map);
+        return newMap;
+    }
+
+
+    void Address::setOptions(System::Collections::Generic::Dictionary<
+                        System::String ^, System::Object ^> ^ options)
+    {
+        ::qpid::types::Variant::Map map;
+        TypeTranslator::ManagedToNative(map, options);
+        addressp->setOptions(map);
+    }
+
+    //
+    // type
+    //
+    System::String ^ Address::getType()
+    {
+        return gcnew System::String(addressp->getType().c_str());
+    }
+
+
+    void Address::setType(System::String ^ type)
+    {
+        addressp->setName(QpidMarshal::ToNative(type));
+    }
+
+    //
+    // str
+    //
+    System::String ^ Address::str()
+    {
+        return gcnew System::String(addressp->str().c_str());
+    }
+}}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Address.h b/qpid/cpp/bindings/qpid/dotnet/src/Address.h
new file mode 100644
index 0000000..72eed76
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Address.h
@@ -0,0 +1,89 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+#pragma once
+
+#include <windows.h>
+#include <msclr\lock.h>
+#include <oletx2xa.h>
+#include <string>
+#include <limits>
+
+#include "qpid/messaging/Address.h"
+
+
+namespace org {
+namespace apache {
+namespace qpid {
+namespace messaging {
+
+    /// <summary>
+    /// Address is a managed wrapper for a qpid::messaging::Address
+    /// </summary>
+
+    public ref class Address
+    {
+    private:
+        // Kept object deletion code
+        void Cleanup();
+
+    public:
+        // The kept object in the Messaging C++ DLL
+        ::qpid::messaging::Address * addressp;
+
+        Address();
+        
+        Address(System::String ^ address);
+
+        Address(System::String ^ name,
+                System::String ^ subject,
+                System::Collections::Generic::Dictionary<
+                    System::String ^, System::Object ^> ^ options);
+                
+        Address(System::String ^ name,
+                System::String ^ subject,
+                System::Collections::Generic::Dictionary<
+                    System::String ^, System::Object ^> ^ options,
+                System::String ^ type);
+
+        // Create from received address
+        Address(::qpid::messaging::Address * addrp);
+
+        ~Address();
+        !Address();
+//        Address(const Address % rhs);
+
+        System::String ^ getName();
+        void setName(System::String ^ name);
+
+        System::String ^ getSubject();
+        void setSubject(System::String ^ subject);
+
+        System::Collections::Generic::Dictionary<
+            System::String ^, System::Object ^> ^ getOptions();
+
+        void setOptions(System::Collections::Generic::Dictionary<
+                            System::String ^, System::Object ^> ^ options);
+
+        System::String ^ getType();
+        void setType(System::String ^ type);
+
+        System::String ^ str();
+    };
+}}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
index 58b93f6..4936e18 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
@@ -25,10 +25,13 @@
 
 #include "qpid/messaging/Connection.h"
 #include "qpid/messaging/Session.h"
+#include "qpid/messaging/exceptions.h"
 
 #include "QpidMarshal.h"
 #include "Connection.h"
 #include "Session.h"
+#include "QpidException.h"
+#include "TypeTranslator.h"
 
 namespace org {
 namespace apache {
@@ -39,12 +42,25 @@ namespace messaging {
     /// Connection is a managed wrapper for a qpid::messaging::Connection
     /// </summary>
 
-    // Public constructor
+    // constructors
     Connection::Connection(System::String ^ url) :
         connectionp(new ::qpid::messaging::Connection(QpidMarshal::ToNative(url)))
     {
     }
 
+
+    Connection::Connection(System::String ^ url,
+                           System::Collections::Generic::Dictionary<
+                               System::String ^, System::Object ^> ^ options) :
+        connectionp(new ::qpid::messaging::Connection(QpidMarshal::ToNative(url)))
+    {
+        for each (System::Collections::Generic::KeyValuePair<System::String^, System::Object^> kvp in options)
+        {
+            setOption(kvp.Key, kvp.Value);
+        }
+    }
+
+
     Connection::Connection(System::String ^ url, System::String ^ options) :
         connectionp(new ::qpid::messaging::Connection(QpidMarshal::ToNative(url),
                     QpidMarshal::ToNative(options)))
@@ -77,39 +93,185 @@ namespace messaging {
         }
     }
 
-    Session ^ Connection::createSession()
+
+    void Connection::setOption(System::String ^ name, System::Object ^ value)
     {
-        return createSession("");
+        ::qpid::types::Variant entryValue;
+        TypeTranslator::ManagedToNativeObject(value, entryValue);
+        std::string entryName = QpidMarshal::ToNative(name);
+        connectionp->::qpid::messaging::Connection::setOption(entryName, entryValue);
     }
 
+    void Connection::open()
+    {
+        connectionp->open();
+    }
 
-    Session ^ Connection::createSession(System::String ^ name)
+    System::Boolean Connection::isOpen()
     {
-        // allocate native session
-        ::qpid::messaging::Session * sessionp = new ::qpid::messaging::Session;
+        return connectionp->isOpen();
+    }
 
-        // create native session
-        *sessionp = connectionp->createSession(QpidMarshal::ToNative(name));
+    void Connection::close()
+    {
+        connectionp->close();
+    }
+
+    //
+    // createTransactionalSession()
+    //
+    Session ^ Connection::createTransactionalSession()
+    {
+        return createTransactionalSession("");
+    }
+
+
+    Session ^ Connection::createTransactionalSession(System::String ^ name)
+    {
+        System::Exception          ^ newException = nullptr;
+        ::qpid::messaging::Session * sessionp     = NULL;
+        Session                    ^ newSession   = nullptr;
 
-        // create managed session
-        Session ^ newSession = gcnew Session(sessionp, this);
+        try
+        {
+            // allocate native session
+            sessionp = new ::qpid::messaging::Session ;
+
+            // create native session
+            *sessionp = connectionp->createTransactionalSession(QpidMarshal::ToNative(name));
+
+            // create managed session
+            newSession = gcnew Session(sessionp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Connection::createTransactionalSession unknown error");
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (sessionp != NULL)
+                {
+                    delete sessionp;
+                }
+                throw newException;
+            }
+        }
 
         return newSession;
     }
 
 
-    void Connection::open()
+    //
+    // createSession()
+    //
+    Session ^ Connection::createSession()
     {
-        connectionp->open();
+        return createSession("");
     }
 
-    bool Connection::isOpen()
+
+    Session ^ Connection::createSession(System::String ^ name)
     {
-        return connectionp->isOpen();
+        System::Exception          ^ newException = nullptr;
+        ::qpid::messaging::Session * sessionp     = NULL;
+        Session                    ^ newSession   = nullptr;
+
+        try
+        {
+            // allocate native session
+            sessionp = new ::qpid::messaging::Session ;
+
+            // create native session
+            *sessionp = connectionp->createSession(QpidMarshal::ToNative(name));
+
+            // create managed session
+            newSession = gcnew Session(sessionp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Connection::createSession unknown error");
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (sessionp != NULL)
+                {
+                    delete sessionp;
+                }
+                throw newException;
+            }
+        }
+
+        return newSession;
     }
 
-    void Connection::close()
+
+    Session ^ Connection::getSession(System::String ^ name)
     {
-        connectionp->close();
+        System::Exception          ^ newException = nullptr;
+        ::qpid::messaging::Session * sess         = NULL;
+        Session                    ^ newSession   = nullptr;
+      
+        try
+        {
+            const std::string n = QpidMarshal::ToNative(name);
+
+            *sess = connectionp->::qpid::messaging::Connection::getSession(n);
+            
+            newSession = gcnew Session(sess, this);
+        }
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Connection::getSession unknown error");
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (sess != NULL)
+                {
+                    delete sess;
+                }
+                throw newException;
+            }
+        }
+
+        return newSession;
     }
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Connection.h b/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
index e16cb1e..894a96d 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
@@ -50,14 +50,29 @@ namespace messaging {
 
     public:
         Connection(System::String ^ url);
+
+        Connection(System::String ^ url, 
+                   System::Collections::Generic::Dictionary<
+                       System::String ^, System::Object ^> ^ options);
+
         Connection(System::String ^ url, System::String ^ options);
         ~Connection();
         !Connection();
 
-        Session ^ createSession();
-        Session ^ createSession(System::String ^ name);
+        void setOption(System::String ^ name, System::Object ^ value);
+
         void open();
-        bool isOpen();
+        System::Boolean isOpen();
         void close();
+
+        // createTransactionalSession()
+        Session ^ createTransactionalSession();
+        Session ^ createTransactionalSession(System::String ^ name);
+
+        // createSession()
+        Session ^ createSession();
+        Session ^ createSession(System::String ^ name);
+
+        Session ^ getSession(System::String ^ name);
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Duration.h b/qpid/cpp/bindings/qpid/dotnet/src/Duration.h
index 9b763a7..b7d2bf1 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Duration.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Duration.h
@@ -25,8 +25,6 @@
 #include <string>
 #include <limits>
 
-#include "qpid/messaging/Duration.h"
-
 namespace org {
 namespace apache {
 namespace qpid {
@@ -34,34 +32,59 @@ namespace messaging {
 
     /// <summary>
     /// Duration is a time interval in milliseconds.
-    /// It is a managed wrapper for a ::qpid::messaging::Duration
+    /// It is a managed equivalent of ::qpid::messaging::Duration
     /// </summary>
 
     public ref class Duration
     {
     private:
-        // Experimental constructor
-        Duration(const ::qpid::messaging::Duration *);
-
-        // Kept object deletion code
-        void Cleanup();
+        System::UInt64 milliseconds;
 
     public:
-        Duration(System::UInt64 milliseconds);
-        ~Duration();
-        !Duration();
 
-        // The kept object in the Messaging C++ DLL
-        const ::qpid::messaging::Duration * durationp;
+        Duration(const Duration % rhs) :
+            milliseconds(rhs.milliseconds)
+        {
+        };
+
+        explicit Duration(System::UInt64 mS) : 
+            milliseconds(mS) {};
+        
+        Duration()                           : 
+            milliseconds(System::UInt64::MaxValue) {};
+
+        property System::UInt64 Milliseconds
+        {
+            System::UInt64 get () { return milliseconds; }
+        }
+
+        static Duration ^ operator * (Duration ^ dur, const System::UInt64 multiplier)
+        {
+            Duration ^ result = gcnew Duration(dur->Milliseconds * multiplier);
+            return result;
+        }
 
-        System::UInt64 getMilliseconds();
+        static Duration ^ operator * (const System::UInt64 multiplier, Duration ^ dur)
+        {
+            Duration ^ result = gcnew Duration(multiplier * dur->Milliseconds);
+            return result;
+        }
+    };
+
+    public ref class DurationConstants
+    {
+    public:
+        static Duration ^ FORVER;
+        static Duration ^ IMMEDIATE;
+        static Duration ^ SECOND;
+        static Duration ^ MINUTE;
 
-        // Return value(s) for constant durations
-        // NOTE: These return the duration mS and not a Duration 
-        //       object like the C++ code gets.
-        System::UInt64 FOREVER();
-        System::UInt64 IMMEDIATE();
-        System::UInt64 SECOND();
-        System::UInt64 MINUTE();
+        static DurationConstants()
+        {
+            FORVER    = gcnew Duration();
+            IMMEDIATE = gcnew Duration(0);
+            SECOND    = gcnew Duration(1000);
+            MINUTE    = gcnew Duration(60000);
+        }
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
index 9c28e72..193a2eb 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
@@ -29,7 +29,12 @@
 #include "qpid/types/Variant.h"
 
 #include "QpidMarshal.h"
+#include "Address.h"
+#include "Duration.h"
 #include "Message.h"
+#include "QpidTypeCheck.h"
+#include "QpidException.h"
+#include "TypeTranslator.h"
 
 namespace org {
 namespace apache {
@@ -40,38 +45,26 @@ namespace messaging {
     /// Message is a managed wrapper for a ::qpid::messaging::Message
     /// </summary>
 
-    // This constructor is used to create a message from bytes to put into the message
-    Message::Message(System::String ^ bytes) :
-        aVMap(gcnew VMap()),
-        aVList(gcnew VList()),
-        pVMapType(aVMap.GetType()),
-        pVListType(aVList.GetType()),
-        messagep(new ::qpid::messaging::Message(QpidMarshal::ToNative(bytes)))
+    // Create empty message
+    Message::Message() :
+        messagep(new ::qpid::messaging::Message(QpidMarshal::ToNative("")))
     {
     }
 
-    // This constructor creates a message from a native received message
-    Message::Message(::qpid::messaging::Message * msgp) :
-        aVMap(gcnew VMap()),
-        aVList(gcnew VList()),
-        pVMapType(aVMap.GetType()),
-        pVListType(aVList.GetType()),
-        messagep(msgp)
+    // Create from string
+    Message::Message(System::String ^ string) :
+        messagep(new ::qpid::messaging::Message(QpidMarshal::ToNative(string)))
     {
     }
 
-
+    // Create from object
     Message::Message(System::Object ^ objp) :
-        aVMap(gcnew VMap()),
-        aVList(gcnew VList()),
-        pVMapType(aVMap.GetType()),
-        pVListType(aVList.GetType()),
         messagep(new ::qpid::messaging::Message(QpidMarshal::ToNative("")))
     {
         ::qpid::types::Variant * variantp  = 0;
         std::string            * variantsp = 0;
 
-        if (objIsMap(objp))
+        if (QpidTypeCheck::ObjectIsMap(objp))
         {
             // Create a mapped message using given dictionary
 
@@ -79,7 +72,7 @@ namespace messaging {
             ::qpid::types::Variant::Map newMap;
 
             // Add the map variables to the map
-            Encode(newMap, (VMap ^)objp);
+            TypeTranslator::ManagedToNative(newMap, (QpidMap ^)objp);
 
             // Set message content type
             messagep->setContentType("ampq/map");
@@ -87,7 +80,7 @@ namespace messaging {
             // Insert the map into the message
             ::qpid::messaging::encode(newMap, *messagep, QpidMarshal::ToNative("amqp/map"));
         }
-        else if (objIsList(objp))
+        else if (QpidTypeCheck::ObjectIsList(objp))
         {
             // Create a list message using given list
 
@@ -95,7 +88,7 @@ namespace messaging {
             ::qpid::types::Variant::List newList;
 
             // Add the list variables to the list
-            Encode(newList, (VList ^)objp);
+            TypeTranslator::ManagedToNative(newList, (QpidList ^)objp);
 
             // Set message content type
             messagep->setContentType("ampq/list");
@@ -110,6 +103,12 @@ namespace messaging {
         }
     }
 
+    // Create from received message
+    Message::Message(::qpid::messaging::Message * msgp) :
+        messagep(msgp)
+    {
+    }
+
 
     // Destructor
     Message::~Message()
@@ -125,6 +124,7 @@ namespace messaging {
     }
 
     // Copy constructor
+    // TODO: prevent copy
     Message::Message(const Message % rhs)
     {
         messagep      = rhs.messagep;
@@ -143,209 +143,25 @@ namespace messaging {
 
 
     //
-    // The given object is a Dictionary.
-    // Add its elements to the qpid map.
+    // ReplyTo
     //
-    void Message::Encode(::qpid::types::Variant::Map & theMapp,
-                         VMap ^ theObjp)
+    void Message::setReplyTo(Address ^ address)
     {
-        // iterate the items, converting each to a variant and adding to the map
-        for each (System::Collections::Generic::KeyValuePair<System::String^, System::Object^> kvp in theObjp)
-        {
-            if (objIsMap(kvp.Value))
-            {
-                // Recurse on inner map
-                // Allocate a map
-                ::qpid::types::Variant::Map newMap;
-
-                // Add the map variables to the map
-                Encode(newMap, (VMap ^)kvp.Value);
-
-                // Create a variant entry for the inner map
-                std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newMap));
-
-                // Get map's name
-                std::string entryName = QpidMarshal::ToNative(kvp.Key);
-
-                // Add inner map to outer map
-                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, *newVariantp));
-            }
-            else if (objIsList(kvp.Value))
-            {
-                // Recurse on inner list
-                // Allocate a list
-                ::qpid::types::Variant::List newList;
-
-                // Add the List variables to the list
-                Encode(newList, (VList ^)kvp.Value);
-
-                // Create a variant entry for the inner map
-                ::qpid::types::Variant::List newVariant(newList);
-
-                //std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newList));
-
-                // Get list's name
-                std::string entryName = QpidMarshal::ToNative(kvp.Key);
-
-                // Add inner list to outer map
-                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, newVariant));
-            }
-            else
-            {
-                // Add a simple native type to map
-                ::qpid::types::Variant entryValue;
-                EncodeObject(kvp.Value, entryValue);
-                std::string entryName = QpidMarshal::ToNative(kvp.Key);
-                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, entryValue));
-            }
-        }
+        messagep->setReplyTo(*(address->addressp));
     }
 
-
-
-    //
-    // The given object is a List.
-    // Add its elements to the qpid list.
-    //
-    void Message::Encode(::qpid::types::Variant::List & theListp,
-                         VList ^ theObjp)
+    Address ^ Message::getReplyTo()
     {
-        // iterate the items, converting each to a variant and adding to the map
-        for each (System::Object ^ listObj in theObjp)
-        {
-            if (objIsMap(listObj))
-            {
-                // Recurse on inner map
-                // Allocate a map
-                ::qpid::types::Variant::Map newMap;
-
-                // Add the map variables to the map
-                Encode(newMap, (VMap ^)listObj);
-
-                // Create a variant entry for the inner map
-                std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newMap));
-
-                // Add inner map to outer list
-                theListp.push_back(*newVariantp);
-            }
-            else if (objIsList(listObj))
-            {
-                // Recurse on inner list
-                // Allocate a list
-                ::qpid::types::Variant::List newList;
-
-                // Add the List variables to the list
-                Encode(newList, (VList ^)listObj);
-
-                // Create a variant entry for the inner list
-                std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newList));
-
-                // Add inner list to outer list
-                theListp.push_back(*newVariantp);
-            }
-            else
-            {
-                // Add a simple native type to list
-                ::qpid::types::Variant entryValue;
-                EncodeObject(listObj, entryValue);
-                theListp.push_back(entryValue);
-            }
-        }
-    }
+        const ::qpid::messaging::Address & addrp =
+            messagep->::qpid::messaging::Message::getReplyTo();
 
+        return gcnew Address(const_cast<::qpid::messaging::Address *>(&addrp));
+    }
 
 
     //
-    // Returns a variant representing simple native type object.
-    // Not to be called for Map/List objects.
+    // Subject
     //
-    void Message::EncodeObject(System::Object ^ theObjp, 
-                               ::qpid::types::Variant & targetp)
-    {
-        System::Type     ^ typeP    = (*theObjp).GetType();
-        System::TypeCode   typeCode = System::Type::GetTypeCode( typeP );
-
-        switch (typeCode)
-        {
-        case System::TypeCode::Boolean :
-            targetp = System::Convert::ToBoolean(theObjp);
-            break;
-
-        case System::TypeCode::Byte :
-            targetp = System::Convert::ToByte(theObjp);
-            break;
-
-        case System::TypeCode::UInt16 :
-            targetp = System::Convert::ToUInt16(theObjp);
-            break;
-
-        case System::TypeCode::UInt32 :
-            targetp = System::Convert::ToUInt32(theObjp);
-            break;
-
-        case System::TypeCode::UInt64 :
-            targetp = System::Convert::ToUInt64(theObjp);
-            break;
-
-        case System::TypeCode::Char :
-        case System::TypeCode::SByte :
-            targetp = System::Convert::ToSByte(theObjp);
-            break;
-
-        case System::TypeCode::Int16 :
-            targetp = System::Convert::ToInt16(theObjp);
-            break;
-
-        case System::TypeCode::Int32 :
-            targetp = System::Convert::ToInt32(theObjp);
-            break;
-
-        case System::TypeCode::Int64 :
-            targetp = System::Convert::ToInt64(theObjp);
-            break;
-
-        case System::TypeCode::Single :
-            targetp = System::Convert::ToSingle(theObjp);
-            break;
-
-        case System::TypeCode::Double :
-            targetp = System::Convert::ToDouble(theObjp);
-            break;
-
-        case System::TypeCode::String :
-            {
-                std::string      rString;
-                System::String ^ rpString;
-
-                rpString = System::Convert::ToString(theObjp);
-                rString = QpidMarshal::ToNative(rpString);
-                targetp = rString;
-				targetp.setEncoding(QpidMarshal::ToNative("utf8"));
-            }
-            break;
-
-            
-        default:
-
-            throw gcnew System::NotImplementedException();
-
-        }
-    }
-
-
-    // Properties...
-
-    //void Message::setReplyTo(System::String ^ address)
-    //{
-    //    messagep->setReplyTo(QpidMarshal::ToNative(address));
-    //}
-
-    //System::String ^ Message::getReplyTo()
-    //{
-    //    return gcnew String(messagep->getReplyTo().c_str());
-    //}
-
-
     void Message::setSubject(System::String ^ subject)
     {
         messagep->setSubject(QpidMarshal::ToNative(subject));
@@ -357,6 +173,9 @@ namespace messaging {
     }
     
 
+    //
+    // ContentType
+    //
     void Message::setContentType(System::String ^ ct)
     {
         messagep->setContentType(QpidMarshal::ToNative(ct));
@@ -368,6 +187,9 @@ namespace messaging {
     }
     
     
+    //
+    // MessageId
+    //
     void Message::setMessageId(System::String ^ mId)
     {
         messagep->setMessageId(QpidMarshal::ToNative(mId));
@@ -379,6 +201,9 @@ namespace messaging {
     }
     
     
+    //
+    // UserId
+    //
     void Message::setUserId(System::String ^ uId)
     {
         messagep->setUserId(QpidMarshal::ToNative(uId));
@@ -390,6 +215,9 @@ namespace messaging {
     }
     
     
+    //
+    // CorrelationId
+    //
     void Message::setCorrelationId(System::String ^ cId)
     {
         messagep->setCorrelationId(QpidMarshal::ToNative(cId));
@@ -401,6 +229,9 @@ namespace messaging {
     }
     
 
+    //
+    // Priority
+    //
     void Message::setPriority(unsigned char priority)
     {
         messagep->setPriority(priority);
@@ -412,8 +243,22 @@ namespace messaging {
     }
     
 
-    //void setTtl(Duration ttl);
-    //Duration getTtl();
+    //
+    // Ttl
+    //
+    void Message::setTtl(Duration ^ ttl)
+    {
+        ::qpid::messaging::Duration dur(ttl->Milliseconds);
+
+        messagep->setTtl(dur);
+    }
+    
+    Duration ^ Message::getTtl()
+    {
+        Duration ^ dur = gcnew Duration(messagep->getTtl().getMilliseconds());
+
+        return dur;
+    }
 
     void Message::setDurable(bool durable)
     {
@@ -437,11 +282,22 @@ namespace messaging {
     }
 
 
-    //System::String ^ Message::getProperties()
-    //{
-    //    pqid::types::Variant::Map * mapp = new
-    //    return gcnew String(messagep->getReplyTo().c_str());
-    //}
+    System::Collections::Generic::Dictionary<
+            System::String^, System::Object^> ^ Message::getProperties()
+    {
+        ::qpid::types::Variant::Map map;
+
+        map = messagep->getProperties();
+
+        System::Collections::Generic::Dictionary<
+            System::String^, System::Object^> ^ dict =
+            gcnew System::Collections::Generic::Dictionary<
+                      System::String^, System::Object^> ;
+
+        TypeTranslator::NativeToManaged(dict, map);
+
+        return dict;
+    }
 
 
     void Message::setContent(System::String ^ content)
@@ -468,100 +324,7 @@ namespace messaging {
         
         ::qpid::messaging::decode(*messagep, map, QpidMarshal::ToNative("amqp/map"));
 
-        Decode(dict, map);
-    }
-
-
-    // Given a user Dictionary and a qpid map,
-    //   extract the qpid elements and put them into the dictionary.
-    //
-    void Message::Decode(VMap ^ dict, ::qpid::types::Variant::Map & map)
-    {
-        // For each object in the message map, 
-        //  create a .NET object and add it to the dictionary.
-        for (::qpid::types::Variant::Map::const_iterator i = map.begin(); i != map.end(); ++i) {
-            // Get the name
-            System::String ^ elementName = gcnew String(i->first.c_str());
-
-            ::qpid::types::Variant     variant = i->second;
-            ::qpid::types::VariantType vType   = variant.getType();
-
-            switch (vType)
-            {
-            case ::qpid::types::VAR_BOOL:
-                dict[elementName] = variant.asBool();
-                break;
-                
-            case ::qpid::types::VAR_UINT8:
-                dict[elementName] = variant.asUint8();
-                break;
-                
-            case ::qpid::types::VAR_UINT16:
-                dict[elementName] = variant.asUint16();
-                break;
-                
-            case ::qpid::types::VAR_UINT32:
-                dict[elementName] = variant.asUint32();
-                break;
-                
-            case ::qpid::types::VAR_UINT64:
-                dict[elementName] = variant.asUint64();
-                break;
-                
-            case ::qpid::types::VAR_INT8:
-                dict[elementName] = variant.asInt8();
-                break;
-                
-            case ::qpid::types::VAR_INT16:
-                dict[elementName] = variant.asInt16();
-                break;
-                
-            case ::qpid::types::VAR_INT32:
-                dict[elementName] = variant.asInt32();
-                break;
-                
-            case ::qpid::types::VAR_INT64:
-                dict[elementName] = variant.asInt64();
-                break;
-                
-            case ::qpid::types::VAR_FLOAT:
-                dict[elementName] = variant.asFloat();
-                break;
-                
-            case ::qpid::types::VAR_DOUBLE:
-                dict[elementName] = variant.asDouble();
-                break;
-                
-            case ::qpid::types::VAR_STRING:
-                {
-                    System::String ^ elementValue = gcnew System::String(variant.asString().c_str());
-                    dict[elementName] = elementValue;
-                    break;
-                }
-            case ::qpid::types::VAR_MAP:
-                {
-                    VMap ^ newDict = gcnew VMap();
-
-                    Decode (newDict, variant.asMap());
-
-                    dict[elementName] = newDict;
-                    break;
-                }
-
-            case ::qpid::types::VAR_LIST:
-                {
-                    VList ^ newList = gcnew VList();
-
-                    Decode (newList, variant.asList());
-
-                    dict[elementName] = newList;
-                    break;
-                }
-                
-            case ::qpid::types::VAR_UUID:
-                break;
-            }
-        }
+        TypeTranslator::NativeToManaged(dict, map);
     }
 
 
@@ -571,99 +334,43 @@ namespace messaging {
     void Message::getContent(System::Collections::Generic::List<
                         System::Object^> ^ list)
     {
-        // Extract the message map from the message
-        ::qpid::types::Variant::List vList;
+        // allocate a native messaging::List
+        ::qpid::types::Variant::List nativeList;
         
-        ::qpid::messaging::decode(*messagep, vList, QpidMarshal::ToNative("amqp/list"));
+        // Extract the list from the message in native format
+        ::qpid::messaging::decode(*messagep, nativeList, QpidMarshal::ToNative("amqp/list"));
 
-        Decode(list, vList);
+        // translate native list into user's managed list
+        TypeTranslator::NativeToManaged(list, nativeList);
     }
 
-
-    void Message::Decode(VList ^ vList, ::qpid::types::Variant::List & qpidList)
+    //
+    // User wants content as bytes.
+    // result array must be correct size already
+    //
+    void Message::getRaw(array<System::Byte> ^ arr)
     {
-        // For each object in the message map, 
-        //  create a .NET object and add it to the dictionary.
-        for (::qpid::types::Variant::List::const_iterator i = qpidList.begin(); i != qpidList.end(); ++i) 
+        System::UInt32 size = messagep->getContentSize();
+     
+        if (0 == size)
+            throw gcnew QpidException("Message::getRaw - message size is zero");
+
+        if (arr->Length != size)
+            throw gcnew QpidException("Message::getRaw - receive buffer is too small");
+
+        const char * ptr = messagep->getContentPtr();
+
+        // TODO: System::Runtime::InteropServices::Marshal::Copy(ptr, arr, 0, size);
+
+        for (UInt32 i = 0; i < size; i++)
         {
-            ::qpid::types::Variant     variant = *i;
-            ::qpid::types::VariantType vType   = variant.getType();
-
-            switch (vType)
-            {
-            case ::qpid::types::VAR_BOOL:
-                (*vList).Add(variant.asBool());
-                break;
-                
-            case ::qpid::types::VAR_UINT8:
-                (*vList).Add(variant.asUint8());
-                break;
-                
-            case ::qpid::types::VAR_UINT16:
-                (*vList).Add(variant.asUint16());
-                break;
-                
-            case ::qpid::types::VAR_UINT32:
-                (*vList).Add(variant.asUint32());
-                break;
-                
-            case ::qpid::types::VAR_UINT64:
-                (*vList).Add(variant.asUint64());
-                break;
-                
-            case ::qpid::types::VAR_INT8:
-                (*vList).Add(variant.asInt8());
-                break;
-                
-            case ::qpid::types::VAR_INT16:
-                (*vList).Add(variant.asInt16());
-                break;
-                
-            case ::qpid::types::VAR_INT32:
-                (*vList).Add(variant.asInt32());
-                break;
-                
-            case ::qpid::types::VAR_INT64:
-                (*vList).Add(variant.asInt64());
-                break;
-                
-            case ::qpid::types::VAR_FLOAT:
-                (*vList).Add(variant.asFloat());
-                break;
-                
-            case ::qpid::types::VAR_DOUBLE:
-                (*vList).Add(variant.asDouble());
-                break;
-                
-            case ::qpid::types::VAR_STRING:
-                {
-                    System::String ^ elementValue = gcnew System::String(variant.asString().c_str());
-                    (*vList).Add(elementValue);
-                    break;
-                }
-            case ::qpid::types::VAR_MAP:
-                {
-                    VMap ^ newDict = gcnew VMap();
-
-                    Decode (newDict, variant.asMap());
-
-                    (*vList).Add(newDict);
-                    break;
-                }
-
-            case ::qpid::types::VAR_LIST:
-                {
-                    VList ^ newList = gcnew VList();
-
-                    Decode (newList, variant.asList());
-
-                    (*vList).Add(newList);
-                    break;
-                }
-                
-            case ::qpid::types::VAR_UUID:
-                break;
-            }
+            arr[i] = ptr[i];
         }
     }
+
+
+    System::UInt64 Message::getContentSize()
+    {
+        return messagep->getContentSize();
+    }
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.h b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
index c308fdf..ab06588 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
@@ -31,14 +31,8 @@ namespace apache {
 namespace qpid {
 namespace messaging {
 
-typedef System::Collections::Generic::Dictionary<
-            System::String^, 
-            System::Object^> 
-                VMap;
-
-typedef System::Collections::Generic::List<
-            System::Object^> 
-                VList;
+    ref class Address;
+    ref class Duration;
 
     /// <summary>
     /// Message is a managed wrapper for a ::qpid::messaging::Message
@@ -51,51 +45,20 @@ typedef System::Collections::Generic::List<
         // Kept object deletion code
         void Cleanup();
 
-        bool objIsMap (System::Object ^ op)
-        { 
-            return (*op).GetType() == pVMapType;
-        }
-
-        bool objIsList(System::Object ^ op)
-        { 
-            return (*op).GetType() == pVListType;
-        }
-
-        // The given object is a Dictionary.
-        // Add its elements to the qpid map.
-        void Encode(::qpid::types::Variant::Map & theMapp,
-                    VMap ^ theObjp);
-
-        // The given object is a List.
-        // Add its elements to the qpid list.
-        void Encode(::qpid::types::Variant::List & theListp,
-                    VList ^ theObjp);
-
-        // Returns a variant representing simple native type object.
-        // Not to be called for Map/List objects.
-        void EncodeObject(System::Object ^ theObjp,
-                          ::qpid::types::Variant & targetp);
-
-
-        void Decode(VMap ^ dict, ::qpid::types::Variant::Map & map);
-
-        void Decode(VList ^ vList, ::qpid::types::Variant::List & qpidList);
-
-
-        // map and list for type comparison
-        VMap  aVMap;
-        VList aVList;
-        System::Type ^ pVMapType;
-        System::Type ^ pVListType;
-
     public:
+        // Create empty message
+        Message();
+
         // Create from String
-        Message(System::String ^ bytes);
+        Message(System::String ^ string);
 
         // Create from object
         Message(System::Object ^ obj);
 
-        // Create reference copy
+        // TODO: Create from bytes
+        // Message(System::Byte [] ^ bytes);
+
+        // Create from received message
         Message(::qpid::messaging::Message * msgp);
 
         ~Message();
@@ -107,8 +70,8 @@ typedef System::Collections::Generic::List<
         // The kept object in the Messaging C++ DLL
         ::qpid::messaging::Message * messagep;
 
-        //void setReplyTo(System::String ^ address);
-        //System::String ^ getReplyTo();
+        void setReplyTo(Address ^ address);
+        Address ^ getReplyTo();
 
         void setSubject(System::String ^ subject);
         System::String ^ getSubject();
@@ -128,8 +91,8 @@ typedef System::Collections::Generic::List<
         void setPriority(unsigned char priority);
         unsigned char getPriority();
 
-        //void setTtl(Duration ttl);
-        //Duration getTtl();
+        void setTtl(Duration ^ ttl);
+        Duration ^ getTtl();
 
         void setDurable(bool durable);
         bool getDurable();
@@ -137,17 +100,32 @@ typedef System::Collections::Generic::List<
         bool getRedelivered();
         void setRedelivered(bool redelivered);
 
-        //System::String ^ getProperties();
+        System::Collections::Generic::Dictionary<
+            System::String^, System::Object^> ^ getProperties();
 
         void setContent(System::String ^ content);
 
+        //TODO:: void setContent(Bytes{} bytes, offset, length);
+
+        // get content as string
         System::String ^ getContent();
 
+        // get content as dictionary
         void getContent(System::Collections::Generic::Dictionary<
                             System::String^, 
                             System::Object^> ^ dict);
 
+        // get content as map
         void getContent(System::Collections::Generic::List<
                             System::Object^> ^);
+
+        // get content as bytes
+        void getRaw(cli::array<System::Byte> ^ arr);
+
+        System::UInt64 getContentSize();
+
+        //TODO: EncodingException
+
+        // Note: encode/decode functions are in TypeTranslator
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/QpidException.h b/qpid/cpp/bindings/qpid/dotnet/src/QpidException.h
new file mode 100644
index 0000000..eecc545
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/QpidException.h
@@ -0,0 +1,38 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+#pragma once
+
+namespace org {
+namespace apache {
+namespace qpid {
+namespace messaging {
+
+using namespace System;
+
+public ref class QpidException : System::Exception
+{
+ public:
+
+ QpidException() : System::Exception() {}
+ QpidException(String^ estring) : System::Exception(estring) {}
+
+};
+
+}}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h b/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h
index 7667db8..7b52346 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h
@@ -37,6 +37,7 @@ public:
 
     /// <summary>
     /// Convert managed String into native UTF8-encoded string
+    /// TODO: figure out some encoding other that UTF-8
     /// </summary>
 
     static std::string ToNative (System::String^ managed) 
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h b/qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h
new file mode 100644
index 0000000..2e87c3e
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h
@@ -0,0 +1,75 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+#pragma once
+
+#include <windows.h>
+#include <msclr\lock.h>
+#include <oletx2xa.h>
+#include <string>
+#include <limits>
+
+namespace org {
+namespace apache {
+namespace qpid {
+namespace messaging {
+
+    /// <summary>
+    /// QpidTypeCheck determines if a given managed object represents
+    /// a qpid type per the scheme presented by the messaging DLL.
+    ///
+    // The supported mapping is:
+    /// * a managed Dictionary and a Qpid Messaging Map
+    /// * a managed List       and a Qpid Messaging List
+    /// </summary>
+
+    typedef System::Collections::Generic::Dictionary<
+                System::String^, 
+                System::Object^> 
+                    QpidMap;
+
+    typedef System::Collections::Generic::List<
+                System::Object^> 
+                    QpidList;
+
+    private ref class QpidTypeCheckConstants
+    {
+    public:
+        static System::Type const ^ const mapTypeP = System::Type::GetType(
+            "System.Collections.Generic.Dictionary`2[System.String,System.Object]");
+        static System::Type const ^ const listTypeP = System::Type::GetType(
+            "System.Collections.Generic.List`1[System.Object]");
+    };
+
+
+    public ref class QpidTypeCheck
+    {
+
+    public:
+
+        static bool ObjectIsMap (System::Object ^ object)
+        { 
+            return (*object).GetType() == QpidTypeCheckConstants::mapTypeP;
+        }
+
+        static bool ObjectIsList(System::Object ^ object)
+        { 
+            return (*object).GetType() == QpidTypeCheckConstants::listTypeP;
+        }
+    };
+}}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
index 3902ea7..d647315 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
@@ -26,11 +26,13 @@
 #include "qpid/messaging/Receiver.h"
 #include "qpid/messaging/Session.h"
 #include "qpid/messaging/Message.h"
+#include "qpid/messaging/exceptions.h"
 
 #include "Receiver.h"
 #include "Session.h"
 #include "Message.h"
 #include "Duration.h"
+#include "QpidException.h"
 
 namespace org {
 namespace apache {
@@ -82,56 +84,163 @@ namespace messaging {
         }
     }
 
+    //
+    // get(message)
+    //
     bool Receiver::get(Message ^ mmsgp)
     {
-        return receiverp->Receiver::get(*((*mmsgp).messagep));
+        return get(mmsgp, DurationConstants::FORVER);
     }
 
     bool Receiver::get(Message ^ mmsgp, Duration ^ durationp)
     {
-        return receiverp->Receiver::get(*((*mmsgp).messagep),
-                                        *((*durationp).durationp));
+        ::qpid::messaging::Duration dur((*durationp).Milliseconds);
+
+        return receiverp->Receiver::get(*(mmsgp->messagep), dur);
     }
 
+    //
+    // message = get()
+    //
+    Message ^ Receiver::get()
+    {
+        return get(DurationConstants::FORVER);
+    }
+
+
     Message ^ Receiver::get(Duration ^ durationp)
     {
-        // allocate a message
-        ::qpid::messaging::Message * msgp = new ::qpid::messaging::Message;
+        System::Exception          ^ newException = nullptr;
+        ::qpid::messaging::Message * msgp         = NULL;
+        Message                    ^ newMessage   = nullptr;
 
-        // get the message
-        *msgp = receiverp->::qpid::messaging::Receiver::get(*((*durationp).durationp));
+        try
+        {
+            // allocate a message
+            msgp = new ::qpid::messaging::Message;
+
+            // translate the duration
+            ::qpid::messaging::Duration dur((*durationp).Milliseconds);
 
-        // create new managed message with received message embedded in it
-        Message ^ newMessage = gcnew Message(msgp);
+            // get the message
+            *msgp = receiverp->::qpid::messaging::Receiver::get(dur);
+
+            // create new managed message with received message embedded in it
+            newMessage = gcnew Message(msgp);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Receiver:get unknown error");
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (msgp != NULL)
+                {
+                    delete msgp;
+                }
+
+                throw newException;
+            }
+        }
 
         return newMessage;
     }
 
+    //
+    // fetch(message)
+    //
     bool Receiver::fetch(Message ^ mmsgp)
     {
-        return receiverp->::qpid::messaging::Receiver::fetch(*((*mmsgp).messagep));
+        return fetch(mmsgp, DurationConstants::FORVER);
     }
 
     bool Receiver::fetch(Message ^ mmsgp, Duration ^ durationp)
     {
-        return receiverp->::qpid::messaging::Receiver::fetch(*((*mmsgp).messagep),
-                                          *((*durationp).durationp));
+        ::qpid::messaging::Duration dur((*durationp).Milliseconds);
+
+        return receiverp->::qpid::messaging::Receiver::fetch(*((*mmsgp).messagep), dur);
     }
     
+
+    //
+    // message = fetch()
+    //
+
+    Message ^ Receiver::fetch()
+    {
+        return fetch(DurationConstants::FORVER);
+    }
+
     Message ^ Receiver::fetch(Duration ^ durationp)
     {
-        // allocate a message
-        ::qpid::messaging::Message * msgp = new ::qpid::messaging::Message;
+        System::Exception          ^ newException = nullptr;
+        ::qpid::messaging::Message * msgp         = NULL;
+         Message                   ^ newMessage   = nullptr;
+
+        try
+        {
+            // allocate a message
+            ::qpid::messaging::Message * msgp = new ::qpid::messaging::Message;
+
+            // translate the duration
+            ::qpid::messaging::Duration dur((*durationp).Milliseconds);
+
+            // get the message
+            *msgp = receiverp->::qpid::messaging::Receiver::fetch(dur);
+
+            // create new managed message with received message embedded in it
+            newMessage = gcnew Message(msgp);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Receiver:fetch unknown error");
 
-        // get the message
-        *msgp = receiverp->::qpid::messaging::Receiver::fetch(*((*durationp).durationp));
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (msgp != NULL)
+                {
+                    delete msgp;
+                }
 
-        // create new managed message with received message embedded in it
-        Message ^ newMessage = gcnew Message(msgp);
+                throw newException;
+            }
+        }
 
         return newMessage;
     }
 
+    void Receiver::setCapacity(System::UInt32 capacity)
+    {
+        receiverp->setCapacity(capacity);
+    }
+
     System::UInt32 Receiver::getCapacity()
     {
         return receiverp->getCapacity();
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
index ef2cf1a..26d0402 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
@@ -51,33 +51,39 @@ namespace messaging {
     public ref class Receiver
     {
     private:
-        // The kept object in the Messaging C++ DLL
-        ::qpid::messaging::Receiver * receiverp;
-
         // The session that created this Receiver
         Session ^ parentSession;
 
-        // Kept object lifetime flag
-        bool disposed;
-
         // Kept object deletion code
         void Cleanup();
 
     public:
+        // The kept object in the Messaging C++ DLL
+        ::qpid::messaging::Receiver * receiverp;
+
         Receiver(::qpid::messaging::Receiver * r,
             Session ^ sessRef);
         ~Receiver();
         !Receiver();
         Receiver(const Receiver ^ rhs);
 
+        // get(message)
         bool get(Message ^ mmsgp);
         bool get(Message ^ mmsgp, Duration ^ durationp);
+
+        // message = get()
+        Message ^ get();
         Message ^ get(Duration ^ durationp);
 
+        // fetch(message)
         bool fetch(Message ^ mmsgp);
-        bool fetch(Message ^ mmsgp, Duration ^ durationp);
+        bool fetch(Message ^ mmsgp, Duration ^ duration);
+
+        // message = fetch()
+        Message ^ fetch();
         Message ^ fetch(Duration ^ durationp);
 
+        void setCapacity(System::UInt32 capacity);
         System::UInt32 getCapacity();
         System::UInt32 getAvailable();
         System::UInt32 getUnsettled();
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
index 0550995..1708359 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
@@ -28,7 +28,6 @@
 #include "qpid/messaging/Message.h"
 
 #include "Sender.h"
-#include "Session.h"
 #include "Message.h"
 
 namespace org {
@@ -79,9 +78,12 @@ namespace messaging {
         }
     }
 
+    //
+    // send(msg)
+    //
     void Sender::send(Message ^ mmsgp)
     {
-        senderp->::qpid::messaging::Sender::send(*((*mmsgp).messagep));
+        send(mmsgp, false);
     }
 
     void Sender::send(Message ^ mmsgp, bool sync)
@@ -89,29 +91,10 @@ namespace messaging {
         senderp->::qpid::messaging::Sender::send(*((*mmsgp).messagep), sync);
     }
 
-    void Sender::setCapacity(System::UInt32 capacity)
-    {
-        senderp->setCapacity(capacity);
-    }
-
-    System::UInt32 Sender::getCapacity()
-    {
-        return senderp->getCapacity();
-    }
-
-    System::UInt32 Sender::getUnsettled()
-    {
-        return senderp->getUnsettled();
-    }
-
-    System::UInt32 Sender::getAvailable()
-    {
-        return senderp->getAvailable();
-    }
 
-    System::String ^ Sender::getName()
+    void Sender::close()
     {
-        return gcnew System::String(senderp->getName().c_str());
+        senderp->close();
     }
 
     Session ^ Sender::getSession()
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Sender.h b/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
index 482d434..17f7e82 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
@@ -65,13 +65,36 @@ namespace messaging {
         !Sender();
         Sender(const Sender % rhs);
 
+        // send(message)
         void send(Message ^ mmsgp);
         void send(Message ^ mmsgp, bool sync);
-        void setCapacity(System::UInt32 capacity);
-        System::UInt32 getCapacity();
-        System::UInt32 getUnsettled();
-        System::UInt32 getAvailable();
-        System::String ^ getName();
+
+        void close();
+
+        property System::UInt32 Capacity
+        {
+            System::UInt32 get () { return senderp->getCapacity(); }
+            void set (System::UInt32 capacity) { senderp->setCapacity(capacity); }
+        }
+
+        property System::UInt32 Unsettled
+        {
+            System::UInt32 get () { return senderp->getUnsettled(); }
+        }
+
+        property System::UInt32 Available
+        {
+            System::UInt32 get () { return senderp->getAvailable(); }
+        }
+
+        property System::String ^ Name
+        {
+            System::String ^ get ()
+            {
+                return gcnew System::String(senderp->getName().c_str());
+            }
+        }
+
         Session ^ getSession();
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
index 04db529..c070f10 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
@@ -24,6 +24,7 @@
 #include <limits>
 
 #include "qpid/messaging/Session.h"
+#include "qpid/messaging/exceptions.h"
 
 #include "QpidMarshal.h"
 #include "Session.h"
@@ -31,6 +32,8 @@
 #include "Duration.h"
 #include "Receiver.h"
 #include "Sender.h"
+#include "Message.h"
+#include "QpidException.h"
 
 namespace org {
 namespace apache {
@@ -65,7 +68,7 @@ namespace messaging {
     // copy constructor
     Session::Session(const Session % rhs)
     {
-        sessionp          = rhs.sessionp;
+        sessionp = rhs.sessionp;
         parentConnectionp = rhs.parentConnectionp;
     }
 
@@ -98,7 +101,7 @@ namespace messaging {
 
     void Session::acknowledge()
     {
-        sessionp->acknowledge();
+        acknowledge(false);
     }
 
     void Session::acknowledge(bool sync)
@@ -106,9 +109,19 @@ namespace messaging {
         sessionp->acknowledge(sync);
     }
 
+    void Session::reject(Message ^ message)
+    {
+        sessionp->::qpid::messaging::Session::reject(*(message->messagep));
+    }
+
+    void Session::release(Message ^ message)
+    {
+        sessionp->::qpid::messaging::Session::release(*(message->messagep));
+    }
+
     void Session::sync()
     {
-        sessionp->sync();
+        sync(true);
     }
 
     void Session::sync(bool block)
@@ -116,67 +129,291 @@ namespace messaging {
         sessionp->sync(block);
     }
 
-    System::UInt32 Session::getReceivable()
+    // next(receiver)
+    bool Session::nextReceiver(Receiver ^ rcvr)
     {
-        return sessionp->getReceivable();
+        return nextReceiver(rcvr, DurationConstants::FORVER);
     }
 
-    System::UInt32 Session::getUnsettledAcks()
+    bool Session::nextReceiver(Receiver ^ rcvr, Duration ^ timeout)
     {
-        return sessionp->getUnsettledAcks();
+        System::Exception           ^ newException = nullptr;
+
+        try
+        {
+            ::qpid::messaging::Duration dur(timeout->Milliseconds);
+
+            return sessionp->nextReceiver(*(rcvr->receiverp), dur);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            if (errmsg = "No message to fetch")
+            {
+                // on timeout return null
+                return false;
+            }
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Session::nextReceiver unknown error");
+
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (sessionp != NULL)
+                {
+                    delete sessionp;
+                }
+
+                throw newException;
+            }
+        }
+        return true;
     }
 
-    //bool Session::nextReceiver(Receiver)
-    //{
-    //    sessionp->nextReceiver(Receiver)
-    //}
+    // receiver = next()
+    Receiver ^ Session::nextReceiver()
+    {
+        return nextReceiver(DurationConstants::FORVER);
+    }
 
-    //bool Session::nextReceiver(Receiver, Duration timeout)
-    //{
-    //    sessionp->nextReceiver();
-    //}
+    Receiver ^ Session::nextReceiver(Duration ^ timeout)
+    {
+        System::Exception           ^ newException = nullptr;
 
-    //Receiver Session::nextReceiver(Duration timeout)
-    //{
-    //}
+        try
+        {
+            ::qpid::messaging::Duration dur(timeout->Milliseconds);
+            ::qpid::messaging::Receiver * rcvr = new ::qpid::messaging::Receiver;
+
+            *rcvr = sessionp->::qpid::messaging::Session::nextReceiver(dur);
+
+            Receiver ^ newRcvr = gcnew Receiver(rcvr, this);
+
+            return newRcvr;
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            if (errmsg = "No message to fetch")
+            {
+                // on timeout return null
+                return nullptr;
+            }
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Session::nextReceiver unknown error");
+
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (sessionp != NULL)
+                {
+                    delete sessionp;
+                }
+
+                throw newException;
+            }
+        }
+        return nullptr;
+    }
 
 
     Sender ^ Session::createSender  (System::String ^ address)
     {
-        // allocate a native sender
-        ::qpid::messaging::Sender * senderp = new ::qpid::messaging::Sender;
+        System::Exception          ^ newException = nullptr;
+        ::qpid::messaging::Sender  * senderp         = NULL;
+        Sender                     ^ newSender       = nullptr;
+
+        try
+        {
+            // allocate a native sender
+            ::qpid::messaging::Sender * senderp = new ::qpid::messaging::Sender ;
 
-        // create the sender
-        *senderp = sessionp->::qpid::messaging::Session::createSender(QpidMarshal::ToNative(address));
+            // create the sender
+            *senderp = sessionp->::qpid::messaging::Session::createSender(QpidMarshal::ToNative(address));
 
-        // create a managed sender
-        Sender ^ newSender = gcnew Sender(senderp, this);
+            // create a managed sender
+            newSender = gcnew Sender(senderp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Session::createSender unknown error");
+
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (senderp != NULL)
+                {
+                    delete senderp;
+                }
+
+                throw newException;
+            }
+        }
 
         return newSender;
     }
 
     Receiver ^ Session::createReceiver(System::String ^ address)
     {
-        // allocate a native receiver
-        ::qpid::messaging::Receiver * receiverp = new ::qpid::messaging::Receiver;
+        System::Exception           ^ newException = nullptr;
+        ::qpid::messaging::Receiver * receiverp    = NULL;
+        Receiver                    ^ newReceiver  = nullptr;
+
+        try
+        {
+            // allocate a native receiver
+            receiverp = new ::qpid::messaging::Receiver;
+
+            // create the receiver
+            *receiverp = sessionp->createReceiver(QpidMarshal::ToNative(address));
+
+            // create a managed receiver
+            newReceiver = gcnew Receiver(receiverp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Session::createReceiver unknown error");
+
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (sessionp != NULL)
+                {
+                    delete sessionp;
+                }
+
+                throw newException;
+            }
+        }
+
+        return newReceiver;
+    }
+
+
+    Receiver ^ Session::createReceiver()
+    {
+        System::Exception           ^ newException = nullptr;
+        ::qpid::messaging::Receiver * receiverp    = NULL;
+        Receiver                    ^ newReceiver  = nullptr;
 
-        // create the receiver
-        *receiverp = sessionp->createReceiver(QpidMarshal::ToNative(address));
+        try
+        {
+            // allocate a native receiver
+            receiverp = new ::qpid::messaging::Receiver;
 
-        // create a managed receiver
-        Receiver ^ newReceiver = gcnew Receiver(receiverp, this);
+            // create a managed receiver
+            newReceiver = gcnew Receiver(receiverp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Session::createReceiver unknown error");
+
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (sessionp != NULL)
+                {
+                    delete sessionp;
+                }
+
+                throw newException;
+            }
+        }
 
         return newReceiver;
     }
 
-    Connection ^ Session::getConnection()
+
+    Sender ^ Session::getSender(System::String ^ name)
     {
-        return parentConnectionp;
+        ::qpid::messaging::Sender * sender = new ::qpid::messaging::Sender;
+
+        *sender = sessionp->::qpid::messaging::Session::getSender(QpidMarshal::ToNative(name));
+
+        Sender ^ newSender = gcnew Sender(sender, this);
+
+        return newSender;
+    }
+
+
+
+    Receiver ^ Session::getReceiver(System::String ^ name)
+    {
+        ::qpid::messaging::Receiver * receiver = new ::qpid::messaging::Receiver;
+
+        *receiver = sessionp->::qpid::messaging::Session::getReceiver(QpidMarshal::ToNative(name));
+
+        Receiver ^ newReceiver = gcnew Receiver(receiver, this);
+
+        return newReceiver;
     }
 
-    bool Session::hasError()
+
+
+    Connection ^ Session::getConnection()
     {
-        return sessionp->hasError();
+        return parentConnectionp;
     }
 
     void Session::checkError()
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.h b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
index 3d1230e..3212f05 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
@@ -49,6 +49,7 @@ namespace messaging {
     ref class Duration;
     ref class Receiver;
     ref class Sender;
+    ref class Message;
 
     public ref class Session
     {
@@ -74,20 +75,44 @@ namespace messaging {
         void rollback();
         void acknowledge();
         void acknowledge(bool sync);
-        //void reject(Message);
-        //void release(Message);
+        void reject(Message ^);
+        void release(Message ^);
         void sync();
         void sync(bool block);
-        System::UInt32 getReceivable();
-        System::UInt32 getUnsettledAcks();
-        //bool nextReceiver(Receiver);
-        //bool nextReceiver(Receiver, Duration timeout);
-        //Receiver nextReceiver(Duration timeout);
-        //bool nextReceiver()
-        Sender     ^ createSender  (System::String ^ address);
-        Receiver   ^ createReceiver(System::String ^ address);
+
+        property System::UInt32 Receivable
+        {
+            System::UInt32 get () { return sessionp->getReceivable(); }
+        }
+
+        property System::UInt32 UnsetledAcks
+        {
+            System::UInt32 get () { return sessionp->getUnsettledAcks(); }
+        }
+
+        // next(receiver)
+        bool nextReceiver(Receiver ^);
+        bool nextReceiver(Receiver ^, Duration ^ timeout);
+
+        // receiver = next()
+        Receiver ^ nextReceiver();
+        Receiver ^ nextReceiver(Duration ^ timeout);
+
+
+        Sender   ^ createSender  (System::String ^ address);
+        Receiver ^ createReceiver(System::String ^ address);
+        Receiver ^ createReceiver();
+
+        Sender   ^ getSender(System::String ^ name);
+        Receiver ^ getReceiver(System::String ^ name);
+
         Connection ^ getConnection();
-        bool hasError();
+
+        property System::Boolean HasError
+        {
+            System::Boolean get () { return sessionp->hasError(); }
+        }
+
         void checkError();
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
new file mode 100644
index 0000000..3fbe1e2
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
@@ -0,0 +1,411 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+#include <windows.h>
+#include <msclr\lock.h>
+#include <oletx2xa.h>
+#include <typeinfo.h>
+#include <string>
+#include <limits>
+#include <iostream>
+
+#include "TypeTranslator.h"
+#include "QpidTypeCheck.h"
+#include "QpidMarshal.h"
+
+namespace org {
+namespace apache {
+namespace qpid {
+namespace messaging {
+
+    /// <summary>
+    /// Translate between managed and native types.
+    /// </summary>
+
+    //
+    // The given object is a Dictionary.
+    // Add its elements to the qpid map.
+    //
+    void TypeTranslator::ManagedToNative(::qpid::types::Variant::Map & theMapp,
+                         QpidMap ^ theObjp)
+    {
+        // iterate the items, converting each to a variant and adding to the map
+        for each (System::Collections::Generic::KeyValuePair<System::String^, System::Object^> kvp in theObjp)
+        {
+            if (QpidTypeCheck::ObjectIsMap(kvp.Value))
+            {
+                // Recurse on inner map
+                // Allocate a map
+                ::qpid::types::Variant::Map newMap;
+
+                // Add the map variables to the map
+                ManagedToNative(newMap, (QpidMap ^)kvp.Value);
+
+                // Create a variant entry for the inner map
+                std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newMap));
+
+                // Get map's name
+                std::string entryName = QpidMarshal::ToNative(kvp.Key);
+
+                // Add inner map to outer map
+                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, *newVariantp));
+            }
+            else if (QpidTypeCheck::ObjectIsList(kvp.Value))
+            {
+                // Recurse on inner list
+                // Allocate a list
+                ::qpid::types::Variant::List newList;
+
+                // Add the List variables to the list
+                ManagedToNative(newList, (QpidList ^)kvp.Value);
+
+                // Create a variant entry for the inner map
+                ::qpid::types::Variant::List newVariant(newList);
+
+                //std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newList));
+
+                // Get list's name
+                std::string entryName = QpidMarshal::ToNative(kvp.Key);
+
+                // Add inner list to outer map
+                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, newVariant));
+            }
+            else
+            {
+                // Add a simple native type to map
+                ::qpid::types::Variant entryValue;
+                ManagedToNativeObject(kvp.Value, entryValue);
+                std::string entryName = QpidMarshal::ToNative(kvp.Key);
+                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, entryValue));
+            }
+        }
+    }
+
+
+
+    //
+    // The given object is a List.
+    // Add its elements to the qpid list.
+    //
+    void TypeTranslator::ManagedToNative(::qpid::types::Variant::List & theListp,
+                         QpidList ^ theObjp)
+    {
+        // iterate the items, converting each to a variant and adding to the map
+        for each (System::Object ^ listObj in theObjp)
+        {
+            if (QpidTypeCheck::ObjectIsMap(listObj))
+            {
+                // Recurse on inner map
+                // Allocate a map
+                ::qpid::types::Variant::Map newMap;
+
+                // Add the map variables to the map
+                ManagedToNative(newMap, (QpidMap ^)listObj);
+
+                // Create a variant entry for the inner map
+                std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newMap));
+
+                // Add inner map to outer list
+                theListp.push_back(*newVariantp);
+            }
+            else if (QpidTypeCheck::ObjectIsList(listObj))
+            {
+                // Recurse on inner list
+                // Allocate a list
+                ::qpid::types::Variant::List newList;
+
+                // Add the List variables to the list
+                ManagedToNative(newList, (QpidList ^)listObj);
+
+                // Create a variant entry for the inner list
+                std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newList));
+
+                // Add inner list to outer list
+                theListp.push_back(*newVariantp);
+            }
+            else
+            {
+                // Add a simple native type to list
+                ::qpid::types::Variant entryValue;
+                ManagedToNativeObject(listObj, entryValue);
+                theListp.push_back(entryValue);
+            }
+        }
+    }
+
+
+
+    //
+    // Returns a variant representing simple native type object.
+    // Not to be called for Map/List objects.
+    //
+    void TypeTranslator::ManagedToNativeObject(System::Object ^ theObjp, 
+                               ::qpid::types::Variant & targetp)
+    {
+        System::Type     ^ typeP    = (*theObjp).GetType();
+        System::TypeCode   typeCode = System::Type::GetTypeCode( typeP );
+
+        switch (typeCode)
+        {
+        case System::TypeCode::Boolean :
+            targetp = System::Convert::ToBoolean(theObjp);
+            break;
+
+        case System::TypeCode::Byte :
+            targetp = System::Convert::ToByte(theObjp);
+            break;
+
+        case System::TypeCode::UInt16 :
+            targetp = System::Convert::ToUInt16(theObjp);
+            break;
+
+        case System::TypeCode::UInt32 :
+            targetp = System::Convert::ToUInt32(theObjp);
+            break;
+
+        case System::TypeCode::UInt64 :
+            targetp = System::Convert::ToUInt64(theObjp);
+            break;
+
+        case System::TypeCode::Char :
+        case System::TypeCode::SByte :
+            targetp = System::Convert::ToSByte(theObjp);
+            break;
+
+        case System::TypeCode::Int16 :
+            targetp = System::Convert::ToInt16(theObjp);
+            break;
+
+        case System::TypeCode::Int32 :
+            targetp = System::Convert::ToInt32(theObjp);
+            break;
+
+        case System::TypeCode::Int64 :
+            targetp = System::Convert::ToInt64(theObjp);
+            break;
+
+        case System::TypeCode::Single :
+            targetp = System::Convert::ToSingle(theObjp);
+            break;
+
+        case System::TypeCode::Double :
+            targetp = System::Convert::ToDouble(theObjp);
+            break;
+
+        case System::TypeCode::String :
+            {
+                std::string      rString;
+                System::String ^ rpString;
+
+                rpString = System::Convert::ToString(theObjp);
+                rString = QpidMarshal::ToNative(rpString);
+                targetp = rString;
+                targetp.setEncoding(QpidMarshal::ToNative("utf8"));
+            }
+            break;
+
+            
+        default:
+
+            throw gcnew System::NotImplementedException();
+
+        }
+    }
+
+
+    // Given a user Dictionary and a qpid map,
+    //   extract the qpid elements and put them into the dictionary.
+    //
+    void TypeTranslator::NativeToManaged(QpidMap ^ dict, ::qpid::types::Variant::Map & map)
+    {
+        // For each object in the message map, 
+        //  create a .NET object and add it to the dictionary.
+        for (::qpid::types::Variant::Map::const_iterator i = map.begin(); i != map.end(); ++i) {
+            // Get the name
+            System::String ^ elementName = gcnew String(i->first.c_str());
+
+            ::qpid::types::Variant     variant = i->second;
+            ::qpid::types::VariantType vType   = variant.getType();
+
+            switch (vType)
+            {
+            case ::qpid::types::VAR_BOOL:
+                dict[elementName] = variant.asBool();
+                break;
+                
+            case ::qpid::types::VAR_UINT8:
+                dict[elementName] = variant.asUint8();
+                break;
+                
+            case ::qpid::types::VAR_UINT16:
+                dict[elementName] = variant.asUint16();
+                break;
+                
+            case ::qpid::types::VAR_UINT32:
+                dict[elementName] = variant.asUint32();
+                break;
+                
+            case ::qpid::types::VAR_UINT64:
+                dict[elementName] = variant.asUint64();
+                break;
+                
+            case ::qpid::types::VAR_INT8:
+                dict[elementName] = variant.asInt8();
+                break;
+                
+            case ::qpid::types::VAR_INT16:
+                dict[elementName] = variant.asInt16();
+                break;
+                
+            case ::qpid::types::VAR_INT32:
+                dict[elementName] = variant.asInt32();
+                break;
+                
+            case ::qpid::types::VAR_INT64:
+                dict[elementName] = variant.asInt64();
+                break;
+                
+            case ::qpid::types::VAR_FLOAT:
+                dict[elementName] = variant.asFloat();
+                break;
+                
+            case ::qpid::types::VAR_DOUBLE:
+                dict[elementName] = variant.asDouble();
+                break;
+                
+            case ::qpid::types::VAR_STRING:
+                {
+                    System::String ^ elementValue = gcnew System::String(variant.asString().c_str());
+                    dict[elementName] = elementValue;
+                    break;
+                }
+            case ::qpid::types::VAR_MAP:
+                {
+                    QpidMap ^ newDict = gcnew QpidMap();
+
+                    NativeToManaged(newDict, variant.asMap());
+
+                    dict[elementName] = newDict;
+                    break;
+                }
+
+            case ::qpid::types::VAR_LIST:
+                {
+                    QpidList ^ newList = gcnew QpidList();
+
+                    NativeToManaged(newList, variant.asList());
+
+                    dict[elementName] = newList;
+                    break;
+                }
+                
+            case ::qpid::types::VAR_UUID:
+                break;
+            }
+        }
+    }
+
+
+    void TypeTranslator::NativeToManaged(QpidList ^ vList, ::qpid::types::Variant::List & qpidList)
+    {
+        // For each object in the message map, 
+        //  create a .NET object and add it to the dictionary.
+        for (::qpid::types::Variant::List::const_iterator i = qpidList.begin(); i != qpidList.end(); ++i) 
+        {
+            ::qpid::types::Variant     variant = *i;
+            ::qpid::types::VariantType vType   = variant.getType();
+
+            switch (vType)
+            {
+            case ::qpid::types::VAR_BOOL:
+                (*vList).Add(variant.asBool());
+                break;
+                
+            case ::qpid::types::VAR_UINT8:
+                (*vList).Add(variant.asUint8());
+                break;
+                
+            case ::qpid::types::VAR_UINT16:
+                (*vList).Add(variant.asUint16());
+                break;
+                
+            case ::qpid::types::VAR_UINT32:
+                (*vList).Add(variant.asUint32());
+                break;
+                
+            case ::qpid::types::VAR_UINT64:
+                (*vList).Add(variant.asUint64());
+                break;
+                
+            case ::qpid::types::VAR_INT8:
+                (*vList).Add(variant.asInt8());
+                break;
+                
+            case ::qpid::types::VAR_INT16:
+                (*vList).Add(variant.asInt16());
+                break;
+                
+            case ::qpid::types::VAR_INT32:
+                (*vList).Add(variant.asInt32());
+                break;
+                
+            case ::qpid::types::VAR_INT64:
+                (*vList).Add(variant.asInt64());
+                break;
+                
+            case ::qpid::types::VAR_FLOAT:
+                (*vList).Add(variant.asFloat());
+                break;
+                
+            case ::qpid::types::VAR_DOUBLE:
+                (*vList).Add(variant.asDouble());
+                break;
+                
+            case ::qpid::types::VAR_STRING:
+                {
+                    System::String ^ elementValue = gcnew System::String(variant.asString().c_str());
+                    (*vList).Add(elementValue);
+                    break;
+                }
+            case ::qpid::types::VAR_MAP:
+                {
+                    QpidMap ^ newDict = gcnew QpidMap();
+
+                    NativeToManaged(newDict, variant.asMap());
+
+                    (*vList).Add(newDict);
+                    break;
+                }
+
+            case ::qpid::types::VAR_LIST:
+                {
+                    QpidList ^ newList = gcnew QpidList();
+
+                    NativeToManaged(newList, variant.asList());
+
+                    (*vList).Add(newList);
+                    break;
+                }
+                
+            case ::qpid::types::VAR_UUID:
+                break;
+            }
+        }
+    }
+}}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h
new file mode 100644
index 0000000..7ffba69
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h
@@ -0,0 +1,70 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+#pragma once
+
+#include <windows.h>
+#include <msclr\lock.h>
+#include <oletx2xa.h>
+#include <string>
+#include <limits>
+
+#include "qpid/types/Variant.h"
+
+#include "QpidTypeCheck.h"
+
+namespace org {
+namespace apache {
+namespace qpid {
+namespace messaging {
+
+    /// <summary>
+    /// TypeTranslator provides codec between .NET Dictionary/List and
+    /// qpid messaging Map/List.
+    /// </summary>
+
+    public ref class TypeTranslator
+    {
+
+    public:
+        // The given object is a Dictionary.
+        // Add its elements to the qpid map.
+        static void ManagedToNative(::qpid::types::Variant::Map & theMapp,
+                                    QpidMap ^ theObjp);
+
+        // The given object is a List.
+        // Add its elements to the qpid list.
+        static void ManagedToNative(::qpid::types::Variant::List & theListp,
+                                    QpidList ^ theObjp);
+
+        // The given object is a simple native type (not a Dictionary or List)
+        // Returns a variant representing simple native type object.
+        static void ManagedToNativeObject(System::Object ^ theObjp,
+                                          ::qpid::types::Variant & targetp);
+
+        // Given a Dictionary,
+        // Return its values in a Qpid map
+        static void NativeToManaged(QpidMap ^ dict, 
+                                    ::qpid::types::Variant::Map & map);
+
+        // Given a List,
+        // Return its values in a Qpid list
+        static void NativeToManaged(QpidList ^ vList, 
+                                    ::qpid::types::Variant::List & qpidList);
+    };
+}}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/app.rc b/qpid/cpp/bindings/qpid/dotnet/src/app.rc
index b3f0d67..8c1d640 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/app.rc
+++ b/qpid/cpp/bindings/qpid/dotnet/src/app.rc
@@ -20,6 +20,7 @@
 
 LANGUAGE 9, 1
 #pragma code_page(1252)
+1           ICON         "app.ico"
 
 #ifdef APSTUDIO_INVOKED
 /////////////////////////////////////////////////////////////////////////////
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc
new file mode 100644
index 0000000..0e47bae
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc
@@ -0,0 +1,101 @@
+// Microsoft Visual C++ generated resource script.
+//
+#include "resource1.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "afxres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// English (U.S.) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
+#ifdef _WIN32
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE 
+BEGIN
+    "resource1.h\0"
+END
+
+2 TEXTINCLUDE 
+BEGIN
+    "#include ""afxres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE 
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION 1,3,0,1
+ PRODUCTVERSION 1,3,0,1
+ FILEFLAGSMASK 0x17L
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x4L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904b0"
+        BEGIN
+            VALUE "FileDescription", "org"
+            VALUE "FileVersion", "1, 3, 0, 1"
+            VALUE "InternalName", "org"
+            VALUE "LegalCopyright", "Copyright (C) 2010"
+            VALUE "OriginalFilename", "org.apache.qpid.messaging"
+            VALUE "ProductName", "org"
+            VALUE "ProductVersion", "1, 3, 0, 1"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1200
+    END
+END
+
+#endif    // English (U.S.) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
index e8e4bc6..3f5861b 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
+++ b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
@@ -44,7 +44,7 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions=" /Zm1000 /wd4244 /wd4800 /wd4355"
 				Optimization="0"
-				AdditionalIncludeDirectories="&quot;$(QPID_BUILD_ROOT)\include&quot;;&quot;$(QPID_BUILD_ROOT)\src&quot;"
+				AdditionalIncludeDirectories="&quot;$(ProjectDir)..\..\..\..\include&quot;;&quot;$(ProjectDir)..\..\..\..\src&quot;"
 				PreprocessorDefinitions="WIN32;_WINDOWS;_DEBUG;WIN32_LEAN_AND_MEAN"
 				RuntimeLibrary="3"
 				UsePrecompiledHeader="0"
@@ -63,12 +63,13 @@
 			<Tool
 				Name="VCLinkerTool"
 				AdditionalOptions=" /STACK:10000000 /machine:I386"
-				AdditionalDependencies="$(QPID_BUILD_ROOT)\src\Debug\qpidclientd.lib $(QPID_BUILD_ROOT)\src\Debug\qpidcommond.lib"
-				OutputFile="$(OutDir)\org.apache.qpid.messagingd.dll"
+				AdditionalDependencies="$(ProjectDir)..\..\..\..\src\Debug\qpidclientd.lib $(ProjectDir)..\..\..\..\src\Debug\qpidcommond.lib $(ProjectDir)..\..\..\..\src\Debug\qpidmessagingd.lib"
+				OutputFile="$(ProjectDir)..\..\..\..\src\$(ConfigurationName)\org.apache.qpid.messagingd.dll"
 				LinkIncremental="1"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
 				TargetMachine="1"
+				KeyFile="qpid.snk"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -90,6 +91,7 @@
 			/>
 			<Tool
 				Name="VCPostBuildEventTool"
+				CommandLine=""
 			/>
 		</Configuration>
 		<Configuration
@@ -188,15 +190,15 @@
 			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
 			>
 			<File
-				RelativePath=".\AssemblyInfo.cpp"
+				RelativePath=".\Address.cpp"
 				>
 			</File>
 			<File
-				RelativePath=".\Connection.cpp"
+				RelativePath=".\AssemblyInfo.cpp"
 				>
 			</File>
 			<File
-				RelativePath=".\Duration.cpp"
+				RelativePath=".\Connection.cpp"
 				>
 			</File>
 			<File
@@ -215,6 +217,10 @@
 				RelativePath=".\Session.cpp"
 				>
 			</File>
+			<File
+				RelativePath=".\TypeTranslator.cpp"
+				>
+			</File>
 		</Filter>
 		<Filter
 			Name="Header Files"
@@ -222,6 +228,10 @@
 			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
 			>
 			<File
+				RelativePath=".\Address.h"
+				>
+			</File>
+			<File
 				RelativePath=".\Connection.h"
 				>
 			</File>
@@ -238,6 +248,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\QpidTypeCheck.h"
+				>
+			</File>
+			<File
 				RelativePath=".\Receiver.h"
 				>
 			</File>
@@ -249,6 +263,10 @@
 				RelativePath=".\Session.h"
 				>
 			</File>
+			<File
+				RelativePath=".\TypeTranslator.h"
+				>
+			</File>
 		</Filter>
 		<Filter
 			Name="Resource Files"
@@ -260,11 +278,11 @@
 				>
 			</File>
 			<File
-				RelativePath=".\app.rc"
+				RelativePath=".\org.apache.qpid.messaging.rc"
 				>
 			</File>
 			<File
-				RelativePath=".\resource.h"
+				RelativePath=".\resource1.h"
 				>
 			</File>
 		</Filter>
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/qpid.snk b/qpid/cpp/bindings/qpid/dotnet/src/qpid.snk
new file mode 100644
index 0000000000000000000000000000000000000000..9faafd8f8bcde4666d3d04ada613d558b88a4d63
GIT binary patch
literal 596
zcmV-a0;~N80ssI2Bme+XQ$aES1ONa50096^^`MWdGN!jS0N0v=XF>)TkGMUKij(GS
zk^5v;aslfD5l|?AJY4W_&86)|iNjW?e}{VsyCg^+b#k@Mwd=v-|Ca#XRFnr%Cl9Zy
zi3=ARq^&{Mg!9!5XdbG}M2u-Z23fP!`H$eTl!XPh#l4`$jb=l+(RbibtMlpR99_9L
z6D}ZJ$!xE=BfqaoLw!Fb778;Wjz4Mrea^SXeONi}?eD?S9)$uYJ9h4=^vQb8EY~!+
z)NmrOXNYSyY~$OT#h%sdR@`i~oa$L%3(Pe7L{IBzMB4BRoe&78;s1oWzPXW8z?~>c
z9*#(+Omu#Pg!^x?3y_m+qdBTRGtSpNLg*Wlrp971+~IB_Q$S?kQs-jwrx5FV3=?fG
z#)Bkh?(sIlmM$7G5~Khu`>f~f5g-Q7YhfdUuanG2;V*{2wRGk|A9$V4PvA$%e`8z*
zM1P~@E2kG~!2w3eDaZ(hXr(atQd1gJeT&IYE{EucH|djR%cyV^nl++tuS$^(b$*pn
zicc-|z;+x~kkVOAogm*z>#GzS^-X8-Z518e=&J`=omRPfYNZilEz%dnAJB?^BEVhg
z?_!Z`TB<BPg16X-?AB|Qf!VsyvdOth`nnN#{5#`xV)X6dv;)wpkcX_Hgmx_?QEqY3
z=HuEnU@sT#mx8R($}5PzaA-n?iFS<9wHpGcv5qlSU-u%ibYB}1Hb1HA=a~V1a87oz
iqGF&hjKv=gHC_6=_UsQpKT_VY&^zh>YDMdbw`8bdEF>2I

literal 0
HcmV?d00001

diff --git a/qpid/cpp/bindings/qpid/dotnet/src/resource.h b/qpid/cpp/bindings/qpid/dotnet/src/resource.h
deleted file mode 100644
index e2f4735..0000000
--- a/qpid/cpp/bindings/qpid/dotnet/src/resource.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
-* Licensed to the Apache Software Foundation (ASF) under one
-* or more contributor license agreements.  See the NOTICE file
-* distributed with this work for additional information
-* regarding copyright ownership.  The ASF licenses this file
-* to you under the Apache License, Version 2.0 (the
-* "License"); you may not use this file except in compliance
-* with the License.  You may obtain a copy of the License at
-*
-*   http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing,
-* software distributed under the License is distributed on an
-* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-* KIND, either express or implied.  See the License for the
-* specific language governing permissions and limitations
-* under the License.
-*/
-
-//{{NO_DEPENDENCIES}}
-// Microsoft Visual C++ generated include file.
-// Used by app.rc
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/resource1.h b/qpid/cpp/bindings/qpid/dotnet/src/resource1.h
new file mode 100644
index 0000000..96a2cb7
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/resource1.h
@@ -0,0 +1,14 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+// Used by org.apache.qpid.messaging.rc
+
+// Next default values for new objects
+// 
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        101
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1001
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..57f83ad
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs
@@ -0,0 +1,55 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("org.apache.qpid.messaging.sessionreceiver")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("org.apache.qpid.messaging.sessionreceiver")]
+[assembly: AssemblyCopyright("Copyright   2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("e18f363a-a9b0-4251-8f3c-de0e9d9d6827")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
new file mode 100644
index 0000000..0021a15
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
@@ -0,0 +1,65 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>org.apache.qpid.messaging.sessionreceiver</RootNamespace>
+    <AssemblyName>org.apache.qpid.messaging.sessionreceiver</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="sessionreceiver.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs
new file mode 100644
index 0000000..73956ec
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs
@@ -0,0 +1,133 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using org.apache.qpid.messaging;
+
+namespace org.apache.qpid.messaging.sessionreceiver
+{
+    /// <summary>
+    /// ISessionReceiver interface defines the callback for users to supply.
+    /// Once established this callback will receive all messages for all 
+    /// receivers defined by the current session.
+    /// Users are expected not to 'fetch' or 'get' messages by any other means.
+    /// Users must acknowledge() the Session's messages either in the callback
+    /// function or by some other scheme.
+    /// </summary>
+
+    public interface ISessionReceiver
+    {
+        void SessionReceiver(Receiver receiver, Message message);
+    }
+
+    
+    /// <summary>
+    /// eventEngine - wait for messages from the underlying C++ code.
+    /// When available get them and deliver them via callback to our 
+    /// client through the ISessionReceiver interface.
+    /// This class consumes the thread that calls the Run() function.
+    /// </summary>
+
+    internal class eventEngine
+    {
+        private Session          session;
+        private ISessionReceiver callback;
+        private bool             keepRunning;
+
+        public eventEngine(Session theSession, ISessionReceiver thecallback)
+        {
+            this.session  = theSession;
+            this.callback = thecallback;
+        }
+
+        /// <summary>
+        /// Function to call Session's nextReceiver, discover messages,
+        /// and to deliver messages through the callback.
+        /// </summary>
+        public void open()
+        {
+            Receiver rcvr = session.createReceiver();
+            Message  msg;
+
+            keepRunning = true;
+            while (keepRunning)
+            {
+                if (session.nextReceiver(rcvr, DurationConstants.SECOND))
+                {
+                    if (keepRunning)
+                    {
+                        msg = rcvr.fetch(DurationConstants.SECOND);
+                        this.callback.SessionReceiver(rcvr, msg);
+                    }
+                }
+                //else
+                //    receive timed out
+                //    eventEngine exits the nextReceiver() function periodically
+                //    in order to test the keepRunning flag
+            }
+            // Private thread is now exiting.
+        }
+
+        /// <summary>
+        /// Function to stop the eventEngine. Private thread will exit within
+        /// one second.
+        /// </summary>
+        public void close()
+        {
+            keepRunning = false;
+        }
+    }
+
+
+    /// <summary>
+    /// server is the class that users instantiate to connect a SessionReceiver
+    /// callback to the stream of received messages received on a Session.
+    /// </summary>
+    public class server
+    {
+        private eventEngine ee;
+
+        /// <summary>
+        /// Constructor for the server.
+        /// </summary>
+        /// <param name="session">The Session whose messages are collected.</param>
+        /// <param name="callback">The user function call with each message.</param>
+        /// 
+        public server(Session session, ISessionReceiver callback)
+        {
+            ee = new eventEngine(session, callback);
+
+            new System.Threading.Thread(
+                new System.Threading.ThreadStart(ee.open)).Start();
+        }
+
+        /// <summary>
+        /// Function to stop the server.
+        /// </summary>
+        public void close()
+        {
+            ee.close();
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
index 63a8548..5d16172 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
@@ -12,27 +12,77 @@ namespace org.apache.qpid.messaging
         {
             //
             // Duration test - stub until proper nunit tests are ready...
-            //
+
             Duration myDuration = new Duration(1234);
 
             Console.WriteLine("Duration should be : 1234, is : {0}",
-                            myDuration.getMilliseconds());
+                            myDuration.Milliseconds);
 
             Console.WriteLine("Duration FOREVER should be : 1.8x10^19 (realbig), is : {0}",
-                            myDuration.FOREVER());
+                            DurationConstants.FORVER.Milliseconds);
 
             Console.WriteLine("Duration IMMEDIATE should be : 0, is : {0}",
-                            myDuration.IMMEDIATE());
+                            DurationConstants.IMMEDIATE.Milliseconds);
 
             Console.WriteLine("Duration SECOND should be : 1,000, is : {0}",
-                            myDuration.SECOND());
+                            DurationConstants.SECOND.Milliseconds);
 
             Console.WriteLine("Duration MINUTE should be : 60,000, is : {0}",
-                            myDuration.MINUTE());
+                            DurationConstants.MINUTE.Milliseconds);
+
+            Duration isInfinite = new Duration();
 
+            Console.WriteLine("Duration() should be : realbig, is : {0}",
+                            isInfinite.Milliseconds);
+
+            Duration fiveMinutes = new Duration(DurationConstants.MINUTE.Milliseconds * 5);
+            Console.WriteLine("Duration 5MINUTE should be : 300,000, is : {0}",
+                            fiveMinutes.Milliseconds);
+
+            Duration fiveSec = DurationConstants.SECOND * 5;
+            Console.WriteLine("Duration 5SECOND should be : 5,000 is : {0}",
+                            fiveSec.Milliseconds);
             //
             // and so on
             //
+
+            Dictionary<string, object> dx = new Dictionary<string, object>();
+
+            Console.WriteLine("Dictionary.GetType() {0}", dx.GetType());
+
+            //
+            // Address test
+            //
+            Address aEmpty = new Address();
+            Address aStr   = new Address("rare");
+
+            Dictionary<string, object> options = new Dictionary<string,object>();
+            options["one"] = 1;
+            options["two"] = "two";
+
+            Address aSubj = new Address("rare2", "subj", options);
+
+            Address aType = new Address ("check3", "subj", options, "hot");
+
+            Console.WriteLine("aEmpty : {0}", aEmpty.str());
+            Console.WriteLine("aStr   : {0}", aStr.str());
+            Console.WriteLine("aSubj  : {0}", aSubj.str());
+            Console.WriteLine("aType  : {0}", aType.str());
+
+            //
+            // Raw message data retrieval
+            //
+
+            Message m2 = new Message("rarey");
+            UInt64 m2Size = m2.getContentSize();
+
+
+            byte[] myRaw = new byte [m2Size];
+
+            m2.getRaw(myRaw);
+            Console.WriteLine("Got raw array size {0}", m2Size);
+            for (UInt64 i = 0; i < m2Size; i++)
+                Console.Write("{0} ", myRaw[i].ToString());
         }
     }
 }
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
index 0c9d6af..08c0147 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
@@ -17,7 +17,7 @@
     <DebugSymbols>true</DebugSymbols>
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
@@ -31,10 +31,6 @@
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
   <ItemGroup>
-    <Reference Include="org.apache.qpid.messagingd, Version=1.0.3779.23054, Culture=neutral, PublicKeyToken=679e1f50b62dbace, processorArchitecture=x86">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\bin\Debug\org.apache.qpid.messagingd.dll</HintPath>
-    </Reference>
     <Reference Include="System" />
     <Reference Include="System.Core">
       <RequiredTargetFramework>3.5</RequiredTargetFramework>
@@ -52,6 +48,12 @@
     <Compile Include="messaging.test.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
   </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
@@ -60,4 +62,10 @@
   <Target Name="AfterBuild">
   </Target>
   -->
+  <PropertyGroup>
+    <PostBuildEvent>
+    </PostBuildEvent>
+    <PreBuildEvent>
+    </PreBuildEvent>
+  </PropertyGroup>
 </Project>
-- 
1.5.5.6

From 9a0ba6962caad7e88d67d14b7464a95b24267b7b Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Thu, 3 Jun 2010 14:14:50 +0000
Subject: [PATCH] Bug 603805 - .NET bindings for the C++ Messaging API

QPID-2589 - Build DLLs and EXEs usable on both 32 and 64-bit architectures.
Patch from Chuck Rolke.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@951003 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 48ba23e0718fd809ef7a6b5b686c484a56c9d003)
---
 .../csharp.direct.receiver.csproj                  |   18 +++++++++-
 .../csharp.direct.sender.csproj                    |   18 +++++++++-
 .../csharp.map.callback.receiver.csproj            |   18 +++++++++-
 .../csharp.map.callback.sender.csproj              |   19 +++++++++-
 .../csharp.map.receiver/csharp.map.receiver.csproj |   18 +++++++++-
 .../csharp.map.sender/csharp.map.sender.csproj     |   18 +++++++++-
 .../qpid/dotnet/org.apache.qpid.messaging.sln      |   37 ++++++++++++++++++++
 .../dotnet/src/org.apache.qpid.messaging.vcproj    |   14 ++++----
 ...rg.apache.qpid.messaging.sessionreceiver.csproj |   18 +++++++++-
 .../test/messaging.test/messaging.test.csproj      |   18 +++++++++-
 10 files changed, 181 insertions(+), 15 deletions(-)

diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
index 7bfcfb8..96b4540 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
@@ -25,11 +25,27 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
index 7ff92e1..4543222 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
@@ -25,11 +25,27 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
index e8aae4b..24b5cd4 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
@@ -25,11 +25,27 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
index 5089737..26f2c5b 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
@@ -26,11 +26,28 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
index 380e33b..06017fb 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
@@ -25,11 +25,27 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
index 4482e6a..a3a2ac2 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
@@ -25,11 +25,27 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
diff --git a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
index 8b0b3fd..5cd4b1a 100644
--- a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
+++ b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
@@ -48,9 +48,11 @@ Global
 		Debug|Any CPU = Debug|Any CPU
 		Debug|Mixed Platforms = Debug|Mixed Platforms
 		Debug|Win32 = Debug|Win32
+		Debug|x86 = Debug|x86
 		Release|Any CPU = Release|Any CPU
 		Release|Mixed Platforms = Release|Mixed Platforms
 		Release|Win32 = Release|Win32
+		Release|x86 = Release|x86
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Debug|Any CPU.ActiveCfg = Debug|Win32
@@ -58,91 +60,126 @@ Global
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Debug|Mixed Platforms.Build.0 = Debug|Win32
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Debug|Win32.ActiveCfg = Debug|Win32
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Debug|Win32.Build.0 = Debug|Win32
+		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Debug|x86.ActiveCfg = Debug|Win32
+		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Debug|x86.Build.0 = Debug|Win32
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Release|Any CPU.ActiveCfg = Release|Win32
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Release|Mixed Platforms.ActiveCfg = Release|Win32
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Release|Mixed Platforms.Build.0 = Release|Win32
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Release|Win32.ActiveCfg = Release|Win32
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Release|Win32.Build.0 = Release|Win32
+		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Release|x86.ActiveCfg = Release|Win32
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Debug|x86.ActiveCfg = Debug|x86
+		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Debug|x86.Build.0 = Debug|x86
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Release|Any CPU.Build.0 = Release|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Release|Win32.ActiveCfg = Release|Any CPU
+		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Release|x86.ActiveCfg = Release|x86
+		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Release|x86.Build.0 = Release|x86
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Debug|x86.ActiveCfg = Debug|x86
+		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Debug|x86.Build.0 = Debug|x86
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Release|Any CPU.Build.0 = Release|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Release|Win32.ActiveCfg = Release|Any CPU
+		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Release|x86.ActiveCfg = Release|x86
+		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Release|x86.Build.0 = Release|x86
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Debug|x86.ActiveCfg = Debug|x86
+		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Debug|x86.Build.0 = Debug|x86
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Release|Any CPU.Build.0 = Release|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Release|Win32.ActiveCfg = Release|Any CPU
+		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Release|x86.ActiveCfg = Release|x86
+		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Release|x86.Build.0 = Release|x86
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Debug|x86.ActiveCfg = Debug|x86
+		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Debug|x86.Build.0 = Debug|x86
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Release|Any CPU.Build.0 = Release|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Release|Win32.ActiveCfg = Release|Any CPU
+		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Release|x86.ActiveCfg = Release|x86
+		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Release|x86.Build.0 = Release|x86
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Debug|x86.ActiveCfg = Debug|x86
+		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Debug|x86.Build.0 = Debug|x86
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Any CPU.Build.0 = Release|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Win32.ActiveCfg = Release|Any CPU
+		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|x86.ActiveCfg = Release|x86
+		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|x86.Build.0 = Release|x86
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|x86.ActiveCfg = Debug|x86
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|x86.Build.0 = Debug|x86
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Any CPU.Build.0 = Release|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Win32.ActiveCfg = Release|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|x86.ActiveCfg = Release|x86
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|x86.Build.0 = Release|x86
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|x86.ActiveCfg = Debug|x86
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|x86.Build.0 = Debug|x86
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Any CPU.Build.0 = Release|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Win32.ActiveCfg = Release|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|x86.ActiveCfg = Release|x86
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|x86.Build.0 = Release|x86
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|x86.ActiveCfg = Debug|x86
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|x86.Build.0 = Debug|x86
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Any CPU.Build.0 = Release|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Win32.ActiveCfg = Release|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|x86.ActiveCfg = Release|x86
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|x86.Build.0 = Release|x86
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
index 3f5861b..7c31781 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
+++ b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
@@ -18,8 +18,8 @@
 	<Configurations>
 		<Configuration
 			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)\bin\$(ConfigurationName)"
-			IntermediateDirectory="$(SolutionDir)\obj\$(ConfigurationName)"
+			OutputDirectory="$(ProjectDir)\bin\$(ConfigurationName)"
+			IntermediateDirectory="$(ProjectDir)\obj\$(ConfigurationName)"
 			ConfigurationType="2"
 			CharacterSet="1"
 			ManagedExtensions="1"
@@ -96,8 +96,8 @@
 		</Configuration>
 		<Configuration
 			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)\bin\$(ConfigurationName)"
-			IntermediateDirectory="$(SolutionDir)\obj\$(ConfigurationName)"
+			OutputDirectory="$(ProjectDir)\bin\$(ConfigurationName)"
+			IntermediateDirectory="$(ProjectDir)\obj\$(ConfigurationName)"
 			ConfigurationType="2"
 			CharacterSet="1"
 			ManagedExtensions="1"
@@ -122,7 +122,7 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions=" /Zm1000 /wd4244 /wd4800 /wd4355"
 				Optimization="0"
-				AdditionalIncludeDirectories="&quot;$(QPID_BUILD_ROOT)\include&quot;;&quot;$(QPID_BUILD_ROOT)\src&quot;"
+				AdditionalIncludeDirectories="&quot;$(ProjectDir)..\..\..\..\include&quot;;&quot;$(ProjectDir)..\..\..\..\src&quot;"
 				PreprocessorDefinitions="WIN32;_WINDOWS;NDEBUG;WIN32_LEAN_AND_MEAN"
 				RuntimeLibrary="3"
 				UsePrecompiledHeader="0"
@@ -141,8 +141,8 @@
 			<Tool
 				Name="VCLinkerTool"
 				AdditionalOptions=" /STACK:10000000 /machine:I386"
-				AdditionalDependencies="$(QPID_BUILD_ROOT)\src\Release\qpidclient.lib $(QPID_BUILD_ROOT)\src\Release\qpidcommon.lib"
-				OutputFile="$(OutDir)\org.apache.qpid.messaging.dll"
+				AdditionalDependencies="$(ProjectDir)..\..\..\..\src\$(ConfigurationName)\qpidclient.lib $(ProjectDir)..\..\..\..\src\$(ConfigurationName)\qpidcommon.lib $(ProjectDir)..\..\..\..\src\$(ConfigurationName)\qpidmessaging.lib"
+				OutputFile="$(ProjectDir)..\..\..\..\src\$(ConfigurationName)\org.apache.qpid.messaging.dll"
 				LinkIncremental="1"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
index 0021a15..04ddc17 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
@@ -25,11 +25,27 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
index 08c0147..5dddc59 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
@@ -25,11 +25,27 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
-- 
1.5.5.6

From 49e8840023c526ed951f8bf7e97570e883399375 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Wed, 9 Jun 2010 11:59:38 +0000
Subject: [PATCH] Bug 603805 - .NET bindings for the C++ Messaging API

QPID-2589 Cleanup pass to address function naming, capitalization rules, change Qpid messaging 'list' representation from List<> to Collection<>,
some exception cleanup.
Patch from Chuck Rolke

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@952968 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit fdd9fd62edc6b304ce36090d38fdfc07ca0205fa)
---
 .../csharp.direct.receiver.cs                      |   16 +-
 .../csharp.direct.sender/csharp.direct.sender.cs   |   14 +-
 .../csharp.map.callback.receiver.cs                |   47 ++--
 .../csharp.map.callback.sender.cs                  |   19 +-
 .../csharp.map.receiver/csharp.map.recevier.cs     |   21 +-
 .../csharp.map.sender/csharp.map.sender.cs         |   17 +-
 qpid/cpp/bindings/qpid/dotnet/src/Address.cpp      |   50 ++--
 qpid/cpp/bindings/qpid/dotnet/src/Address.h        |   34 ++--
 qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp   |  128 ++++++-----
 qpid/cpp/bindings/qpid/dotnet/src/Connection.h     |   30 ++--
 qpid/cpp/bindings/qpid/dotnet/src/Duration.h       |   29 ++-
 qpid/cpp/bindings/qpid/dotnet/src/Message.cpp      |   99 ++++----
 qpid/cpp/bindings/qpid/dotnet/src/Message.h        |   75 ++++---
 qpid/cpp/bindings/qpid/dotnet/src/QpidException.h  |   16 +-
 qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h    |   11 +-
 qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h  |   31 ++-
 qpid/cpp/bindings/qpid/dotnet/src/ReadMe.txt       |    8 +-
 qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp     |   99 ++++-----
 qpid/cpp/bindings/qpid/dotnet/src/Receiver.h       |   61 +++---
 qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp       |   22 +-
 qpid/cpp/bindings/qpid/dotnet/src/Sender.h         |   18 +-
 qpid/cpp/bindings/qpid/dotnet/src/Session.cpp      |  243 ++++++++------------
 qpid/cpp/bindings/qpid/dotnet/src/Session.h        |   48 ++--
 .../bindings/qpid/dotnet/src/TypeTranslator.cpp    |  122 +++++-----
 qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h |   47 ++--
 .../qpid/dotnet/src/org.apache.qpid.messaging.rc   |    6 +-
 .../dotnet/src/org.apache.qpid.messaging.vcproj    |    6 +-
 .../src/sessionreceiver/Properties/AssemblyInfo.cs |    4 +-
 .../dotnet/src/sessionreceiver/sessionreceiver.cs  |   38 ++--
 .../dotnet/test/messaging.test/messaging.test.cs   |   16 +-
 30 files changed, 689 insertions(+), 686 deletions(-)

diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
index 4888023..98531eb 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
@@ -23,7 +23,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
-using org.apache.qpid.messaging;
+using Org.Apache.Qpid.Messaging;
 
 namespace CSharpDirect
 {
@@ -54,20 +54,20 @@ namespace CSharpDirect
 
             Connection conn = new Connection(host);
 
-            conn.open();
+            conn.Open();
 
-            if (!conn.isOpen())
+            if (!conn.IsOpen())
             {
                 Console.WriteLine("Failed to open connection to host : {0}", host);
             }
             else
             {
 
-                Session sess = conn.createSession();
+                Session sess = conn.CreateSession();
 
                 Duration dura = new Duration(3600000); // wait forever
 
-                Receiver rcv = sess.createReceiver(addr);
+                Receiver rcv = sess.CreateReceiver(addr);
 
                 Message msg = new Message("");
 
@@ -75,8 +75,8 @@ namespace CSharpDirect
                 {
                     try
                     {
-                        Message msg2 = rcv.fetch(dura);
-                        Console.WriteLine("Rcvd msg {0} : {1}", i, msg2.getContent());
+                        Message msg2 = rcv.Fetch(dura);
+                        Console.WriteLine("Rcvd msg {0} : {1}", i, msg2.GetContent());
                     }
                     catch (Exception e)
                     {
@@ -84,7 +84,7 @@ namespace CSharpDirect
                     }
                 }
 
-                conn.close();
+                conn.Close();
             }
         }
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
index 1fe56aa..71ab75c 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
@@ -23,7 +23,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
-using org.apache.qpid.messaging;
+using Org.Apache.Qpid.Messaging;
 
 namespace csharp.direct.sender
 {
@@ -50,26 +50,26 @@ namespace csharp.direct.sender
 
             Connection conn = new Connection(host);
 
-            conn.open();
+            conn.Open();
 
-            if (!conn.isOpen())
+            if (!conn.IsOpen())
             {
                 Console.WriteLine("Failed to open connection to host : {0}", host);
             }
             else
             {
-                Session sess = conn.createSession();
+                Session sess = conn.CreateSession();
 
-                Sender snd = sess.createSender(addr);
+                Sender snd = sess.CreateSender(addr);
 
                 for (int i = 0; i < nMsg; i++)
                 {
                     Message msg = new Message(String.Format("Test Message {0}", i));
 
-                    snd.send(msg);
+                    snd.Send(msg);
                 }
 
-                conn.close();
+                conn.Close();
             }
         }
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
index e7294c6..2ef7854 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
@@ -21,10 +21,11 @@
 
 using System;
 using System.Collections.Generic;
-using org.apache.qpid.messaging;
-using org.apache.qpid.messaging.sessionreceiver;
+using System.Collections.ObjectModel;
+using Org.Apache.Qpid.Messaging;
+using Org.Apache.Qpid.Messaging.SessionReceiver;
 
-namespace org.apache.qpid.messaging.examples
+namespace Org.Apache.Qpid.Messaging.Examples
 {
     /// <summary>
     /// A class with functions to display structured messages.
@@ -50,7 +51,7 @@ namespace org.apache.qpid.messaging.examples
                 else if (QpidTypeCheck.ObjectIsList(kvp.Value))
                 {
                     Console.WriteLine("Key: {0}, Value: List", kvp.Key);
-                    ShowList((List<object>)kvp.Value, level + 1);
+                    ShowList((Collection<object>)kvp.Value, level + 1);
                 }
                 else
                     Console.WriteLine("Key: {0}, Value: {1}, Type: {2}",
@@ -63,7 +64,7 @@ namespace org.apache.qpid.messaging.examples
         /// </summary>
         /// <param name="list">The AMQP list</param>
         /// <param name="level">Nested depth</param>
-        public static void ShowList(List<object> list, int level)
+        public static void ShowList(Collection<object> list, int level)
         {
             foreach (object obj in list)
             {
@@ -77,7 +78,7 @@ namespace org.apache.qpid.messaging.examples
                 else if (QpidTypeCheck.ObjectIsList(obj))
                 {
                     Console.WriteLine("List");
-                    ShowList((List<object>)obj, level + 1);
+                    ShowList((Collection<object>)obj, level + 1);
                 }
                 else
                     Console.WriteLine("Value: {0}, Type: {1}",
@@ -92,24 +93,24 @@ namespace org.apache.qpid.messaging.examples
         /// <param name="message">The Message</param>
         public static void ShowMessage(Message message)
         {
-            if ("amqp/map" == message.getContentType())
+            if ("amqp/map" == message.GetContentType())
             {
                 Console.WriteLine("Received a Dictionary");
                 Dictionary<string, object> content = new Dictionary<string, object>();
-                message.getContent(content);
+                message.GetContent(content);
                 ShowDictionary(content, 0);
             }
-            else if ("amqp/list" == message.getContentType())
+            else if ("amqp/list" == message.GetContentType())
             {
                 Console.WriteLine("Received a List");
-                List<object> content = new List<object>();
-                message.getContent(content);
+                Collection<object> content = new Collection<object>();
+                message.GetContent(content);
                 ShowList(content, 0);
             }
             else
             {
                 Console.WriteLine("Received a String");
-                Console.WriteLine(message.getContent());
+                Console.WriteLine(message.GetContent());
             }
         }
     }
@@ -147,7 +148,7 @@ namespace org.apache.qpid.messaging.examples
             //
             // Acknowledge the receipt of all received messages.
             //
-            receiver.getSession().acknowledge();
+            receiver.GetSession().Acknowledge();
         }
 
 
@@ -170,7 +171,7 @@ namespace org.apache.qpid.messaging.examples
             Console.WriteLine("The details of the message body's types and values are shown.");
             Console.WriteLine();
             Console.WriteLine(" url  = target address for 'new Connection(url)'");
-            Console.WriteLine(" addr = address for 'session.createReceiver(addr)'");
+            Console.WriteLine(" addr = address for 'session.CreateReceiver(addr)'");
             Console.WriteLine(" nSec = time in seconds to keep the receiver callback open");
             Console.WriteLine();
             Console.WriteLine("Default values:");
@@ -211,20 +212,20 @@ namespace org.apache.qpid.messaging.examples
             // Create and open an AMQP connection to the broker URL
             //
             Connection connection = new Connection(url);
-            connection.open();
+            connection.Open();
 
             //
             // Create a session.
             //
-            Session session = connection.createSession();
+            Session session = connection.CreateSession();
 
             //
             // Receive through callback
             //
             // Create callback server and implicitly start it
             //
-            sessionreceiver.server cbServer =
-                new sessionreceiver.server(session, this);
+            SessionReceiver.CallbackServer cbServer =
+                new SessionReceiver.CallbackServer(session, this);
 
             //
             // The callback server is running and executing callbacks on a
@@ -235,12 +236,12 @@ namespace org.apache.qpid.messaging.examples
             // Create a receiver for the direct exchange using the
             // routing key "map_example".
             //
-            Receiver receiver = session.createReceiver(addr);
+            Receiver receiver = session.CreateReceiver(addr);
 
             //
             // Establish a capacity
             //
-            receiver.setCapacity(100);
+            receiver.SetCapacity(100);
 
             //
             // Wait so many seconds for messages to arrive.
@@ -250,13 +251,13 @@ namespace org.apache.qpid.messaging.examples
             //
             // Stop the callback server.
             //
-            cbServer.close();
+            cbServer.Close();
 
             //
             // Close the receiver and the connection.
             //
-            receiver.close();
-            connection.close();
+            receiver.Close();
+            connection.Close();
         }
     }
 
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
index a097267..761ac0a 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
@@ -21,11 +21,12 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.ObjectModel;
 using System.Linq;
 using System.Text;
-using org.apache.qpid.messaging;
+using Org.Apache.Qpid.Messaging;
 
-namespace org.apache.qpid.messaging.examples
+namespace Org.Apache.Qpid.Messaging.Examples
 {
     class MapSender
     {
@@ -42,7 +43,7 @@ namespace org.apache.qpid.messaging.examples
             Console.WriteLine("messages to a named exchange with a routing key.");
             Console.WriteLine();
             Console.WriteLine(" url = target address for 'new Connection(url)'");
-            Console.WriteLine(" addr = address for 'session.createReceiver(addr)'");
+            Console.WriteLine(" addr = address for 'session.CreateReceiver(addr)'");
             Console.WriteLine(" count = number of messages to send");
             Console.WriteLine();
             Console.WriteLine("Default values:");
@@ -82,14 +83,14 @@ namespace org.apache.qpid.messaging.examples
             // Create and open an AMQP connection to the broker URL
             //
             Connection connection = new Connection(url);
-            connection.open();
+            connection.Open();
 
             //
             // Create a session and a sender to the direct exchange using the
             // routing key "map_example".
             //
-            Session session = connection.createSession();
-            Sender sender = session.createSender(addr);
+            Session session = connection.CreateSession();
+            Sender sender = session.CreateSender(addr);
 
             //
             // Create structured content for the message.  This example builds a
@@ -97,7 +98,7 @@ namespace org.apache.qpid.messaging.examples
             //
             Dictionary<string, object> content = new Dictionary<string, object>();
             Dictionary<string, object> subMap = new Dictionary<string, object>();
-            List<object> colors = new List<object>();
+            Collection<object> colors = new Collection<object>();
 
             content["id"] = 987654321;
             content["name"] = "Widget";
@@ -120,12 +121,12 @@ namespace org.apache.qpid.messaging.examples
             //
             Message message = new Message(content);
             for (UInt32 i = 0; i<count; i++)
-                sender.send(message, true);
+                sender.Send(message, true);
 
             //
             // Close the connection.
             //
-            connection.close();
+            connection.Close();
         }
     }
 
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
index 9a425c0..41ed9f3 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
@@ -21,16 +21,15 @@
 
 using System;
 using System.Collections.Generic;
-using org.apache.qpid.messaging;
+using Org.Apache.Qpid.Messaging;
 
-namespace org.apache.qpid.messaging.examples
+namespace Org.Apache.Qpid.Messaging.examples
 {
     class MapReceiver
     {
         static void Main(string[] args)
         {
             string url = "amqp:tcp:localhost:5672";
-//            string url = "10.16.18.254:5672";
             if (args.Length > 0)
                 url = args[0];
 
@@ -38,37 +37,37 @@ namespace org.apache.qpid.messaging.examples
             // Create and open an AMQP connection to the broker URL
             //
             Connection connection = new Connection(url);
-            connection.open();
+            connection.Open();
 
             //
             // Create a session and a receiver fir the direct exchange using the
             // routing key "map_example".
             //
-            Session session = connection.createSession();
-            Receiver receiver = session.createReceiver("amq.direct/map_example");
+            Session session = connection.CreateSession();
+            Receiver receiver = session.CreateReceiver("amq.direct/map_example");
 
             //
             // Fetch the message from the broker (wait indefinitely by default)
             //
-            Message message = receiver.fetch(new Duration(60000));
+            Message message = receiver.Fetch(new Duration(60000));
 
             //
             // Extract the structured content from the message.
             //
             Dictionary<string, object> content = new Dictionary<string, object>();
-            message.getContent(content);
+            message.GetContent(content);
             Console.WriteLine("Received: {0}", content);
 
             //
             // Acknowledge the receipt of all received messages.
             //
-            session.acknowledge();
+            session.Acknowledge();
 
             //
             // Close the receiver and the connection.
             //
-            receiver.close();
-            connection.close();
+            receiver.Close();
+            connection.Close();
         }
     }
 }
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
index 2890367..d1ccc65 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
@@ -21,11 +21,12 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.ObjectModel;
 using System.Linq;
 using System.Text;
-using org.apache.qpid.messaging;
+using Org.Apache.Qpid.Messaging;
 
-namespace org.apache.qpid.messaging.examples
+namespace Org.Apache.Qpid.Messaging.examples
 {
     class MapSender
     {
@@ -39,14 +40,14 @@ namespace org.apache.qpid.messaging.examples
             // Create and open an AMQP connection to the broker URL
             //
             Connection connection = new Connection(url);
-            connection.open();
+            connection.Open();
 
             //
             // Create a session and a sender to the direct exchange using the
             // routing key "map_example".
             //
-            Session session = connection.createSession();
-            Sender sender = session.createSender("amq.direct/map_example");
+            Session session = connection.CreateSession();
+            Sender sender = session.CreateSender("amq.direct/map_example");
 
             //
             // Create structured content for the message.  This example builds a
@@ -54,7 +55,7 @@ namespace org.apache.qpid.messaging.examples
             //
             Dictionary<string, object> content = new Dictionary<string, object>();
             Dictionary<string, object> subMap = new Dictionary<string, object>();
-            List<object> colors = new List<object>();
+            Collection<object> colors = new Collection<object>();
 
             content["id"] = 987654321;
             content["name"] = "Widget";
@@ -76,12 +77,12 @@ namespace org.apache.qpid.messaging.examples
             // via the sender.
             //
             Message message = new Message(content);
-            sender.send(message, true);
+            sender.Send(message, true);
 
             //
             // Close the connection.
             //
-            connection.close();
+            connection.Close();
         }
     }
 }
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
index 8b48a20..f0bbe13 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
@@ -30,10 +30,10 @@
 #include "QpidTypeCheck.h"
 #include "TypeTranslator.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Address is a managed wrapper for a qpid::messaging::Address
@@ -58,10 +58,10 @@ namespace messaging {
                          System::String ^, System::Object ^> ^ options) :
         addressp(new ::qpid::messaging::Address())
     {
-        setName(name);
-        setSubject(subject);
-        setOptions(options);
-        setType("");
+        SetName(name);
+        SetSubject(subject);
+        SetOptions(options);
+        SetType("");
     }
 
 
@@ -72,10 +72,10 @@ namespace messaging {
                      System::String ^ type) :
         addressp(new ::qpid::messaging::Address())
     {
-        setName(name);
-        setSubject(subject);
-        setOptions(options);
-        setType(type);
+        SetName(name);
+        SetSubject(subject);
+        SetOptions(options);
+        SetType(type);
     }
 
 
@@ -114,12 +114,12 @@ namespace messaging {
     //
     // name
     //
-    System::String ^ Address::getName()
+    System::String ^ Address::GetName()
     {
         return gcnew System::String(addressp->getName().c_str());
     }
 
-    void Address::setName(System::String ^ name)
+    void Address::SetName(System::String ^ name)
     {
         addressp->::qpid::messaging::Address::setName(QpidMarshal::ToNative(name));
     }
@@ -127,21 +127,21 @@ namespace messaging {
     //
     // subject
     //
-    System::String ^ Address::getSubject()
+    System::String ^ Address::GetSubject()
     {
         return gcnew System::String(addressp->getSubject().c_str());
     }
 
-    void Address::setSubject(System::String ^ subject)
+    void Address::SetSubject(System::String ^ subject)
     {
-        addressp->setName(QpidMarshal::ToNative(subject));
+        addressp->setSubject(QpidMarshal::ToNative(subject));
     }
 
     //
     // options
     //
     System::Collections::Generic::Dictionary<
-        System::String ^, System::Object ^> ^ Address::getOptions()
+        System::String ^, System::Object ^> ^ Address::GetOptions()
     {
         ::qpid::types::Variant::Map map;
         System::Collections::Generic::Dictionary<
@@ -149,37 +149,37 @@ namespace messaging {
             gcnew System::Collections::Generic::Dictionary<
                   System::String ^, System::Object ^>;
         map = addressp->getOptions();
-        TypeTranslator::NativeToManaged(newMap, map);
+        TypeTranslator::NativeToManaged(map, newMap);
         return newMap;
     }
 
 
-    void Address::setOptions(System::Collections::Generic::Dictionary<
+    void Address::SetOptions(System::Collections::Generic::Dictionary<
                         System::String ^, System::Object ^> ^ options)
     {
         ::qpid::types::Variant::Map map;
-        TypeTranslator::ManagedToNative(map, options);
+        TypeTranslator::ManagedToNative(options, map);
         addressp->setOptions(map);
     }
 
     //
     // type
     //
-    System::String ^ Address::getType()
+    System::String ^ Address::GetType()
     {
         return gcnew System::String(addressp->getType().c_str());
     }
 
 
-    void Address::setType(System::String ^ type)
+    void Address::SetType(System::String ^ type)
     {
         addressp->setName(QpidMarshal::ToNative(type));
     }
 
     //
-    // str
+    // ToString
     //
-    System::String ^ Address::str()
+    System::String ^ Address::ToStr()
     {
         return gcnew System::String(addressp->str().c_str());
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Address.h b/qpid/cpp/bindings/qpid/dotnet/src/Address.h
index 72eed76..60e24da 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Address.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Address.h
@@ -27,11 +27,10 @@
 
 #include "qpid/messaging/Address.h"
 
-
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Address is a managed wrapper for a qpid::messaging::Address
@@ -43,10 +42,10 @@ namespace messaging {
         // Kept object deletion code
         void Cleanup();
 
-    public:
         // The kept object in the Messaging C++ DLL
         ::qpid::messaging::Address * addressp;
 
+    public:
         Address();
         
         Address(System::String ^ address);
@@ -69,21 +68,26 @@ namespace messaging {
         !Address();
 //        Address(const Address % rhs);
 
-        System::String ^ getName();
-        void setName(System::String ^ name);
+        property ::qpid::messaging::Address * NativeAddress
+        {
+            ::qpid::messaging::Address * get () { return addressp; }
+        }
+
+        System::String ^ GetName();
+        void SetName(System::String ^ name);
 
-        System::String ^ getSubject();
-        void setSubject(System::String ^ subject);
+        System::String ^ GetSubject();
+        void SetSubject(System::String ^ subject);
 
         System::Collections::Generic::Dictionary<
-            System::String ^, System::Object ^> ^ getOptions();
+            System::String ^, System::Object ^> ^ GetOptions();
 
-        void setOptions(System::Collections::Generic::Dictionary<
+        void SetOptions(System::Collections::Generic::Dictionary<
                             System::String ^, System::Object ^> ^ options);
 
-        System::String ^ getType();
-        void setType(System::String ^ type);
+        System::String ^ GetType();
+        void SetType(System::String ^ type);
 
-        System::String ^ str();
+        System::String ^ ToStr();
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
index 4936e18..590cc5e 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
@@ -33,10 +33,10 @@
 #include "QpidException.h"
 #include "TypeTranslator.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Connection is a managed wrapper for a qpid::messaging::Connection
@@ -56,7 +56,7 @@ namespace messaging {
     {
         for each (System::Collections::Generic::KeyValuePair<System::String^, System::Object^> kvp in options)
         {
-            setOption(kvp.Key, kvp.Value);
+            SetOption(kvp.Key, kvp.Value);
         }
     }
 
@@ -94,7 +94,7 @@ namespace messaging {
     }
 
 
-    void Connection::setOption(System::String ^ name, System::Object ^ value)
+    void Connection::SetOption(System::String ^ name, System::Object ^ value)
     {
         ::qpid::types::Variant entryValue;
         TypeTranslator::ManagedToNativeObject(value, entryValue);
@@ -102,31 +102,31 @@ namespace messaging {
         connectionp->::qpid::messaging::Connection::setOption(entryName, entryValue);
     }
 
-    void Connection::open()
+    void Connection::Open()
     {
         connectionp->open();
     }
 
-    System::Boolean Connection::isOpen()
+    System::Boolean Connection::IsOpen()
     {
         return connectionp->isOpen();
     }
 
-    void Connection::close()
+    void Connection::Close()
     {
         connectionp->close();
     }
 
     //
-    // createTransactionalSession()
+    // CreateTransactionalSession()
     //
-    Session ^ Connection::createTransactionalSession()
+    Session ^ Connection::CreateTransactionalSession()
     {
-        return createTransactionalSession("");
+        return CreateTransactionalSession("");
     }
 
 
-    Session ^ Connection::createTransactionalSession(System::String ^ name)
+    Session ^ Connection::CreateTransactionalSession(System::String ^ name)
     {
         System::Exception          ^ newException = nullptr;
         ::qpid::messaging::Session * sessionp     = NULL;
@@ -148,42 +148,44 @@ namespace messaging {
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Connection::createTransactionalSession unknown error");
-        }
         finally
         {
             // Clean up and throw on caught exceptions
             if (newException != nullptr)
             {
-                if (sessionp != NULL)
-                {
-                    delete sessionp;
-                }
-                throw newException;
+                if (newSession != nullptr)
+				{
+					delete newSession;
+				}
+				else
+				{
+	                if (sessionp != NULL)
+		            {
+			            delete sessionp;
+				    }
+				}
             }
         }
 
-        return newSession;
+        if (newException != nullptr)
+        {
+            throw newException;
+        }
+
+		return newSession;
     }
 
 
     //
-    // createSession()
+    // CreateSession()
     //
-    Session ^ Connection::createSession()
+    Session ^ Connection::CreateSession()
     {
-        return createSession("");
+        return CreateSession("");
     }
 
 
-    Session ^ Connection::createSession(System::String ^ name)
+    Session ^ Connection::CreateSession(System::String ^ name)
     {
         System::Exception          ^ newException = nullptr;
         ::qpid::messaging::Session * sessionp     = NULL;
@@ -205,33 +207,35 @@ namespace messaging {
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Connection::createSession unknown error");
-        }
         finally
         {
             // Clean up and throw on caught exceptions
             if (newException != nullptr)
             {
-                if (sessionp != NULL)
-                {
-                    delete sessionp;
-                }
-                throw newException;
+				if (newSession != nullptr)
+				{
+					delete newSession;
+				}
+				else
+				{
+					if (sessionp != NULL)
+					{
+						delete sessionp;
+					}
+				}
             }
         }
 
+		if (nullptr != newException) 
+		{
+			throw newException;
+		}
+
         return newSession;
     }
 
 
-    Session ^ Connection::getSession(System::String ^ name)
+    Session ^ Connection::GetSession(System::String ^ name)
     {
         System::Exception          ^ newException = nullptr;
         ::qpid::messaging::Session * sess         = NULL;
@@ -250,28 +254,30 @@ namespace messaging {
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Connection::getSession unknown error");
-        }
         finally
         {
             // Clean up and throw on caught exceptions
             if (newException != nullptr)
             {
-                if (sess != NULL)
-                {
-                    delete sess;
-                }
-                throw newException;
+				if (newSession != nullptr)
+				{
+					delete newSession;
+				}
+				else
+				{
+					if (sess != NULL)
+					{
+						delete sess;
+					}
+				}
             }
         }
 
+		if (nullptr != newException) 
+		{
+			throw newException;
+		}
+
         return newSession;
     }
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Connection.h b/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
index 894a96d..e93e078 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
@@ -28,10 +28,10 @@
 #include "qpid/messaging/Connection.h"
 #include "qpid/messaging/Session.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Connection is a managed wrapper for a qpid::messaging::Connection
@@ -59,20 +59,20 @@ namespace messaging {
         ~Connection();
         !Connection();
 
-        void setOption(System::String ^ name, System::Object ^ value);
+        void SetOption(System::String ^ name, System::Object ^ value);
 
-        void open();
-        System::Boolean isOpen();
-        void close();
+        void Open();
+        System::Boolean IsOpen();
+        void Close();
 
-        // createTransactionalSession()
-        Session ^ createTransactionalSession();
-        Session ^ createTransactionalSession(System::String ^ name);
+        // CreateTransactionalSession()
+        Session ^ CreateTransactionalSession();
+        Session ^ CreateTransactionalSession(System::String ^ name);
 
-        // createSession()
-        Session ^ createSession();
-        Session ^ createSession(System::String ^ name);
+        // CreateSession()
+        Session ^ CreateSession();
+        Session ^ CreateSession(System::String ^ name);
 
-        Session ^ getSession(System::String ^ name);
+        Session ^ GetSession(System::String ^ name);
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Duration.h b/qpid/cpp/bindings/qpid/dotnet/src/Duration.h
index b7d2bf1..8bbfa56 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Duration.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Duration.h
@@ -25,17 +25,17 @@
 #include <string>
 #include <limits>
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Duration is a time interval in milliseconds.
     /// It is a managed equivalent of ::qpid::messaging::Duration
     /// </summary>
 
-    public ref class Duration
+    public ref class Duration sealed
     {
     private:
         System::UInt64 milliseconds;
@@ -69,10 +69,25 @@ namespace messaging {
             Duration ^ result = gcnew Duration(multiplier * dur->Milliseconds);
             return result;
         }
-    };
 
-    public ref class DurationConstants
+        static Duration ^ Multiply (Duration ^ dur, const System::UInt64 multiplier)
+        {
+            Duration ^ result = gcnew Duration(dur->Milliseconds * multiplier);
+            return result;
+        }
+
+        static Duration ^ Multiply (const System::UInt64 multiplier, Duration ^ dur)
+        {
+            Duration ^ result = gcnew Duration(multiplier * dur->Milliseconds);
+            return result;
+        }
+	};
+
+    public ref class DurationConstants sealed
     {
+	private:
+		DurationConstants::DurationConstants() {}
+
     public:
         static Duration ^ FORVER;
         static Duration ^ IMMEDIATE;
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
index 193a2eb..3f748f1 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
@@ -36,10 +36,10 @@
 #include "QpidException.h"
 #include "TypeTranslator.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Message is a managed wrapper for a ::qpid::messaging::Message
@@ -52,19 +52,16 @@ namespace messaging {
     }
 
     // Create from string
-    Message::Message(System::String ^ string) :
-        messagep(new ::qpid::messaging::Message(QpidMarshal::ToNative(string)))
+    Message::Message(System::String ^ theStr) :
+        messagep(new ::qpid::messaging::Message(QpidMarshal::ToNative(theStr)))
     {
     }
 
     // Create from object
-    Message::Message(System::Object ^ objp) :
+    Message::Message(System::Object ^ theValue) :
         messagep(new ::qpid::messaging::Message(QpidMarshal::ToNative("")))
     {
-        ::qpid::types::Variant * variantp  = 0;
-        std::string            * variantsp = 0;
-
-        if (QpidTypeCheck::ObjectIsMap(objp))
+        if (QpidTypeCheck::ObjectIsMap(theValue))
         {
             // Create a mapped message using given dictionary
 
@@ -72,7 +69,7 @@ namespace messaging {
             ::qpid::types::Variant::Map newMap;
 
             // Add the map variables to the map
-            TypeTranslator::ManagedToNative(newMap, (QpidMap ^)objp);
+            TypeTranslator::ManagedToNative((QpidMap ^)theValue, newMap);
 
             // Set message content type
             messagep->setContentType("ampq/map");
@@ -80,7 +77,7 @@ namespace messaging {
             // Insert the map into the message
             ::qpid::messaging::encode(newMap, *messagep, QpidMarshal::ToNative("amqp/map"));
         }
-        else if (QpidTypeCheck::ObjectIsList(objp))
+        else if (QpidTypeCheck::ObjectIsList(theValue))
         {
             // Create a list message using given list
 
@@ -88,7 +85,7 @@ namespace messaging {
             ::qpid::types::Variant::List newList;
 
             // Add the list variables to the list
-            TypeTranslator::ManagedToNative(newList, (QpidList ^)objp);
+            TypeTranslator::ManagedToNative((QpidList ^)theValue, newList);
 
             // Set message content type
             messagep->setContentType("ampq/list");
@@ -99,7 +96,7 @@ namespace messaging {
         else
         {
             // Create a binary string message
-            messagep->setContent(QpidMarshal::ToNative(objp->ToString()));
+            messagep->setContent(QpidMarshal::ToNative(theValue->ToString()));
         }
     }
 
@@ -145,12 +142,12 @@ namespace messaging {
     //
     // ReplyTo
     //
-    void Message::setReplyTo(Address ^ address)
+    void Message::SetReplyTo(Address ^ address)
     {
-        messagep->setReplyTo(*(address->addressp));
+        messagep->setReplyTo(*(address->NativeAddress));
     }
 
-    Address ^ Message::getReplyTo()
+    Address ^ Message::GetReplyTo()
     {
         const ::qpid::messaging::Address & addrp =
             messagep->::qpid::messaging::Message::getReplyTo();
@@ -162,12 +159,12 @@ namespace messaging {
     //
     // Subject
     //
-    void Message::setSubject(System::String ^ subject)
+    void Message::SetSubject(System::String ^ subject)
     {
         messagep->setSubject(QpidMarshal::ToNative(subject));
     }
     
-    System::String ^ Message::getSubject()
+    System::String ^ Message::GetSubject()
     {
         return gcnew String(messagep->getSubject().c_str());
     }
@@ -176,26 +173,26 @@ namespace messaging {
     //
     // ContentType
     //
-    void Message::setContentType(System::String ^ ct)
+    void Message::SetContentType(System::String ^ ct)
     {
         messagep->setContentType(QpidMarshal::ToNative(ct));
     }
     
-    System::String ^ Message::getContentType()
+	System::String ^ Message::GetContentType()
     {
-        return gcnew String(messagep->getContentType().c_str());
+		return gcnew String(messagep->::qpid::messaging::Message::getContentType().c_str());
     }
     
     
     //
     // MessageId
     //
-    void Message::setMessageId(System::String ^ mId)
+    void Message::SetMessageId(System::String ^ messageId)
     {
-        messagep->setMessageId(QpidMarshal::ToNative(mId));
+        messagep->setMessageId(QpidMarshal::ToNative(messageId));
     }
     
-    System::String ^ Message::getMessageId()
+    System::String ^ Message::GetMessageId()
     {
         return gcnew String(messagep->getMessageId().c_str());
     }
@@ -204,12 +201,12 @@ namespace messaging {
     //
     // UserId
     //
-    void Message::setUserId(System::String ^ uId)
+    void Message::SetUserId(System::String ^ uId)
     {
         messagep->setUserId(QpidMarshal::ToNative(uId));
     }
     
-    System::String ^ Message::getUserId()
+    System::String ^ Message::GetUserId()
     {
         return gcnew String(messagep->getUserId().c_str());
     }
@@ -218,12 +215,12 @@ namespace messaging {
     //
     // CorrelationId
     //
-    void Message::setCorrelationId(System::String ^ cId)
+    void Message::SetCorrelationId(System::String ^ correlationId)
     {
-        messagep->setCorrelationId(QpidMarshal::ToNative(cId));
+        messagep->setCorrelationId(QpidMarshal::ToNative(correlationId));
     }
     
-    System::String ^ Message::getCorrelationId()
+    System::String ^ Message::GetCorrelationId()
     {
         return gcnew String(messagep->getCorrelationId().c_str());
     }
@@ -232,12 +229,12 @@ namespace messaging {
     //
     // Priority
     //
-    void Message::setPriority(unsigned char priority)
+    void Message::SetPriority(unsigned char priority)
     {
         messagep->setPriority(priority);
     }
     
-    unsigned char Message::getPriority()
+    unsigned char Message::GetPriority()
     {
         return messagep->getPriority();
     }
@@ -246,44 +243,44 @@ namespace messaging {
     //
     // Ttl
     //
-    void Message::setTtl(Duration ^ ttl)
+    void Message::SetTtl(Duration ^ ttl)
     {
         ::qpid::messaging::Duration dur(ttl->Milliseconds);
 
         messagep->setTtl(dur);
     }
     
-    Duration ^ Message::getTtl()
+    Duration ^ Message::GetTtl()
     {
         Duration ^ dur = gcnew Duration(messagep->getTtl().getMilliseconds());
 
         return dur;
     }
 
-    void Message::setDurable(bool durable)
+    void Message::SetDurable(bool durable)
     {
         messagep->setDurable(durable);
     }
     
-    bool Message::getDurable()
+    bool Message::GetDurable()
     {
         return messagep->getDurable();
     }
 
 
-    bool Message::getRedelivered()
+    bool Message::GetRedelivered()
     {
         return messagep->getRedelivered();
     }
 
-    void Message::setRedelivered(bool redelivered)
+    void Message::SetRedelivered(bool redelivered)
     {
         messagep->setRedelivered(redelivered);
     }
 
 
     System::Collections::Generic::Dictionary<
-            System::String^, System::Object^> ^ Message::getProperties()
+            System::String^, System::Object^> ^ Message::GetProperties()
     {
         ::qpid::types::Variant::Map map;
 
@@ -294,19 +291,19 @@ namespace messaging {
             gcnew System::Collections::Generic::Dictionary<
                       System::String^, System::Object^> ;
 
-        TypeTranslator::NativeToManaged(dict, map);
+        TypeTranslator::NativeToManaged(map, dict);
 
         return dict;
     }
 
 
-    void Message::setContent(System::String ^ content)
+    void Message::SetContent(System::String ^ content)
     {
         messagep->setContent(QpidMarshal::ToNative(content));
     }
 
 
-    System::String ^ Message::getContent()
+    System::String ^ Message::GetContent()
     {
         return gcnew String(messagep->getContent().c_str());
     }
@@ -315,7 +312,7 @@ namespace messaging {
     //
     // User wants to extract a Dictionary from the message
     //
-    void Message::getContent(System::Collections::Generic::Dictionary<
+    void Message::GetContent(System::Collections::Generic::Dictionary<
                                 System::String^, 
                                 System::Object^> ^ dict)
     {
@@ -324,14 +321,14 @@ namespace messaging {
         
         ::qpid::messaging::decode(*messagep, map, QpidMarshal::ToNative("amqp/map"));
 
-        TypeTranslator::NativeToManaged(dict, map);
+        TypeTranslator::NativeToManaged(map, dict);
     }
 
 
     //
     // User wants to extract a list from the message
     //
-    void Message::getContent(System::Collections::Generic::List<
+    void Message::GetContent(System::Collections::ObjectModel::Collection<
                         System::Object^> ^ list)
     {
         // allocate a native messaging::List
@@ -341,22 +338,22 @@ namespace messaging {
         ::qpid::messaging::decode(*messagep, nativeList, QpidMarshal::ToNative("amqp/list"));
 
         // translate native list into user's managed list
-        TypeTranslator::NativeToManaged(list, nativeList);
+        TypeTranslator::NativeToManaged(nativeList, list);
     }
 
     //
     // User wants content as bytes.
     // result array must be correct size already
     //
-    void Message::getRaw(array<System::Byte> ^ arr)
+    void Message::GetRaw(array<System::Byte> ^ arr)
     {
         System::UInt32 size = messagep->getContentSize();
      
         if (0 == size)
-            throw gcnew QpidException("Message::getRaw - message size is zero");
+            throw gcnew QpidException("Message::GetRaw - message size is zero");
 
         if (arr->Length != size)
-            throw gcnew QpidException("Message::getRaw - receive buffer is too small");
+            throw gcnew QpidException("Message::GetRaw - receive buffer is too small");
 
         const char * ptr = messagep->getContentPtr();
 
@@ -369,7 +366,7 @@ namespace messaging {
     }
 
 
-    System::UInt64 Message::getContentSize()
+    System::UInt64 Message::GetContentSize()
     {
         return messagep->getContentSize();
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.h b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
index ab06588..0a932a9 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
@@ -26,10 +26,10 @@
 
 #include "qpid/messaging/Message.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     ref class Address;
     ref class Duration;
@@ -45,15 +45,18 @@ namespace messaging {
         // Kept object deletion code
         void Cleanup();
 
+        // The kept object in the Messaging C++ DLL
+        ::qpid::messaging::Message * messagep;
+
     public:
         // Create empty message
         Message();
 
         // Create from String
-        Message(System::String ^ string);
+        Message(System::String ^ theStr);
 
         // Create from object
-        Message(System::Object ^ obj);
+        Message(System::Object ^ theValue);
 
         // TODO: Create from bytes
         // Message(System::Byte [] ^ bytes);
@@ -67,62 +70,64 @@ namespace messaging {
         // Copy constructor
         Message(const Message % rhs);
 
-        // The kept object in the Messaging C++ DLL
-        ::qpid::messaging::Message * messagep;
+        property ::qpid::messaging::Message * NativeMessage
+        {
+            ::qpid::messaging::Message * get () { return messagep; }
+        }
 
-        void setReplyTo(Address ^ address);
-        Address ^ getReplyTo();
+        void SetReplyTo(Address ^ address);
+        Address ^ GetReplyTo();
 
-        void setSubject(System::String ^ subject);
-        System::String ^ getSubject();
+        void SetSubject(System::String ^ subject);
+        System::String ^ GetSubject();
 
-        void setContentType(System::String ^ ct);
-        System::String ^ getContentType();
+        void SetContentType(System::String ^ ct);
+        System::String ^ GetContentType();
         
-        void setMessageId(System::String ^ mId);
-        System::String ^ getMessageId();
+        void SetMessageId(System::String ^ messageId);
+        System::String ^ GetMessageId();
         
-        void setUserId(System::String ^ uId);
-        System::String ^ getUserId();
+        void SetUserId(System::String ^ uId);
+        System::String ^ GetUserId();
         
-        void setCorrelationId(System::String ^ cId);
-        System::String ^ getCorrelationId();
+        void SetCorrelationId(System::String ^ correlationId);
+        System::String ^ GetCorrelationId();
 
-        void setPriority(unsigned char priority);
-        unsigned char getPriority();
+        void SetPriority(unsigned char priority);
+        unsigned char GetPriority();
 
-        void setTtl(Duration ^ ttl);
-        Duration ^ getTtl();
+        void SetTtl(Duration ^ ttl);
+        Duration ^ GetTtl();
 
-        void setDurable(bool durable);
-        bool getDurable();
+        void SetDurable(bool durable);
+        bool GetDurable();
 
-        bool getRedelivered();
-        void setRedelivered(bool redelivered);
+        bool GetRedelivered();
+        void SetRedelivered(bool redelivered);
 
         System::Collections::Generic::Dictionary<
-            System::String^, System::Object^> ^ getProperties();
+            System::String^, System::Object^> ^ GetProperties();
 
-        void setContent(System::String ^ content);
+        void SetContent(System::String ^ content);
 
         //TODO:: void setContent(Bytes{} bytes, offset, length);
 
         // get content as string
-        System::String ^ getContent();
+        System::String ^ GetContent();
 
         // get content as dictionary
-        void getContent(System::Collections::Generic::Dictionary<
+        void GetContent(System::Collections::Generic::Dictionary<
                             System::String^, 
                             System::Object^> ^ dict);
 
         // get content as map
-        void getContent(System::Collections::Generic::List<
+        void GetContent(System::Collections::ObjectModel::Collection<
                             System::Object^> ^);
 
         // get content as bytes
-        void getRaw(cli::array<System::Byte> ^ arr);
+        void GetRaw(cli::array<System::Byte> ^ arr);
 
-        System::UInt64 getContentSize();
+        System::UInt64 GetContentSize();
 
         //TODO: EncodingException
 
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/QpidException.h b/qpid/cpp/bindings/qpid/dotnet/src/QpidException.h
index eecc545..c63f245 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/QpidException.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/QpidException.h
@@ -19,19 +19,23 @@
 
 #pragma once
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
 using namespace System;
 
+[Serializable]
 public ref class QpidException : System::Exception
 {
  public:
 
- QpidException() : System::Exception() {}
- QpidException(String^ estring) : System::Exception(estring) {}
+ QpidException() 
+	 : System::Exception() {}
+
+ QpidException(String^ estring) 
+	 : System::Exception(estring) {}
 
 };
 
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h b/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h
index 7b52346..a8266ba 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h
@@ -22,10 +22,10 @@
 using namespace System;
 using namespace System::Text;
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
 
 
@@ -33,6 +33,9 @@ namespace messaging {
 
 private ref class QpidMarshal
 {
+private:
+	QpidMarshal::QpidMarshal() {}
+
 public:
 
     /// <summary>
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h b/qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h
index 2e87c3e..47f391f 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h
@@ -24,10 +24,10 @@
 #include <string>
 #include <limits>
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// QpidTypeCheck determines if a given managed object represents
@@ -35,7 +35,7 @@ namespace messaging {
     ///
     // The supported mapping is:
     /// * a managed Dictionary and a Qpid Messaging Map
-    /// * a managed List       and a Qpid Messaging List
+    /// * a managed Collection and a Qpid Messaging List
     /// </summary>
 
     typedef System::Collections::Generic::Dictionary<
@@ -43,33 +43,38 @@ namespace messaging {
                 System::Object^> 
                     QpidMap;
 
-    typedef System::Collections::Generic::List<
+    typedef System::Collections::ObjectModel::Collection<
                 System::Object^> 
                     QpidList;
 
-    private ref class QpidTypeCheckConstants
+    private ref class QpidTypeCheckConstants sealed
     {
+	private:
+		QpidTypeCheckConstants::QpidTypeCheckConstants() {}
+
     public:
         static System::Type const ^ const mapTypeP = System::Type::GetType(
             "System.Collections.Generic.Dictionary`2[System.String,System.Object]");
         static System::Type const ^ const listTypeP = System::Type::GetType(
-            "System.Collections.Generic.List`1[System.Object]");
+            "System.Collections.ObjectModel.Collection`1[System.Object]");
     };
 
 
-    public ref class QpidTypeCheck
+    public ref class QpidTypeCheck sealed
     {
+	private:
+		QpidTypeCheck::QpidTypeCheck() {}
 
     public:
 
-        static bool ObjectIsMap (System::Object ^ object)
+        static bool ObjectIsMap (System::Object ^ theValue)
         { 
-            return (*object).GetType() == QpidTypeCheckConstants::mapTypeP;
+            return (*theValue).GetType() == QpidTypeCheckConstants::mapTypeP;
         }
 
-        static bool ObjectIsList(System::Object ^ object)
+        static bool ObjectIsList(System::Object ^ theValue)
         { 
-            return (*object).GetType() == QpidTypeCheckConstants::listTypeP;
+            return (*theValue).GetType() == QpidTypeCheckConstants::listTypeP;
         }
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/ReadMe.txt b/qpid/cpp/bindings/qpid/dotnet/src/ReadMe.txt
index a75e35b..a17f043 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/ReadMe.txt
+++ b/qpid/cpp/bindings/qpid/dotnet/src/ReadMe.txt
@@ -1,13 +1,13 @@
 ========================================================================
-    DYNAMIC LINK LIBRARY : org.apache.qpid.messaging Project Overview
+    DYNAMIC LINK LIBRARY : Org.Apache.Qpid.Messaging Project Overview
 ========================================================================
 
-AppWizard has created this org.apache.qpid.messaging DLL for you.  
+AppWizard has created this Org.Apache.Qpid.Messaging DLL for you.  
 
 This file contains a summary of what you will find in each of the files that
-make up your org.apache.qpid.messaging application.
+make up your Org.Apache.Qpid.Messaging application.
 
-org.apache.qpid.messaging.vcproj
+Org.Apache.Qpid.Messaging.vcproj
     This is the main project file for VC++ projects generated using an Application Wizard. 
     It contains information about the version of Visual C++ that generated the file, and 
     information about the platforms, configurations, and project features selected with the
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
index d647315..15f8572 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
@@ -34,10 +34,10 @@
 #include "Duration.h"
 #include "QpidException.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Receiver is a managed wrapper for a ::qpid::messaging::Receiver
@@ -85,30 +85,30 @@ namespace messaging {
     }
 
     //
-    // get(message)
+    // Get(message)
     //
-    bool Receiver::get(Message ^ mmsgp)
+    bool Receiver::Get(Message ^ mmsgp)
     {
-        return get(mmsgp, DurationConstants::FORVER);
+        return Get(mmsgp, DurationConstants::FORVER);
     }
 
-    bool Receiver::get(Message ^ mmsgp, Duration ^ durationp)
+    bool Receiver::Get(Message ^ mmsgp, Duration ^ durationp)
     {
         ::qpid::messaging::Duration dur((*durationp).Milliseconds);
 
-        return receiverp->Receiver::get(*(mmsgp->messagep), dur);
+        return receiverp->Receiver::get(*(mmsgp->NativeMessage), dur);
     }
 
     //
-    // message = get()
+    // message = Get()
     //
-    Message ^ Receiver::get()
+    Message ^ Receiver::Get()
     {
-        return get(DurationConstants::FORVER);
+        return Get(DurationConstants::FORVER);
     }
 
 
-    Message ^ Receiver::get(Duration ^ durationp)
+    Message ^ Receiver::Get(Duration ^ durationp)
     {
         System::Exception          ^ newException = nullptr;
         ::qpid::messaging::Message * msgp         = NULL;
@@ -133,58 +133,54 @@ namespace messaging {
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Receiver:get unknown error");
-        }
         finally
         {
-            // Clean up and throw on caught exceptions
             if (newException != nullptr)
             {
                 if (msgp != NULL)
                 {
                     delete msgp;
                 }
-
-                throw newException;
+				if (newMessage != nullptr)
+				{
+					delete newMessage;
+				}
             }
         }
+        if (newException != nullptr)
+        {
+			throw newException;
+		}
 
         return newMessage;
     }
 
     //
-    // fetch(message)
+    // Fetch(message)
     //
-    bool Receiver::fetch(Message ^ mmsgp)
+    bool Receiver::Fetch(Message ^ mmsgp)
     {
-        return fetch(mmsgp, DurationConstants::FORVER);
+        return Fetch(mmsgp, DurationConstants::FORVER);
     }
 
-    bool Receiver::fetch(Message ^ mmsgp, Duration ^ durationp)
+    bool Receiver::Fetch(Message ^ mmsgp, Duration ^ durationp)
     {
         ::qpid::messaging::Duration dur((*durationp).Milliseconds);
 
-        return receiverp->::qpid::messaging::Receiver::fetch(*((*mmsgp).messagep), dur);
+        return receiverp->::qpid::messaging::Receiver::fetch(*((*mmsgp).NativeMessage), dur);
     }
     
 
     //
-    // message = fetch()
+    // message = Fetch()
     //
 
-    Message ^ Receiver::fetch()
+    Message ^ Receiver::Fetch()
     {
-        return fetch(DurationConstants::FORVER);
+        return Fetch(DurationConstants::FORVER);
     }
 
-    Message ^ Receiver::fetch(Duration ^ durationp)
+    Message ^ Receiver::Fetch(Duration ^ durationp)
     {
         System::Exception          ^ newException = nullptr;
         ::qpid::messaging::Message * msgp         = NULL;
@@ -209,64 +205,59 @@ namespace messaging {
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Receiver:fetch unknown error");
-
-        }
         finally
         {
-            // Clean up and throw on caught exceptions
             if (newException != nullptr)
             {
                 if (msgp != NULL)
                 {
                     delete msgp;
                 }
-
-                throw newException;
+				if (newMessage != nullptr)
+				{
+					delete newMessage;
+				}
             }
         }
+        if (newException != nullptr)
+        {
+			throw newException;
+		}
 
         return newMessage;
     }
 
-    void Receiver::setCapacity(System::UInt32 capacity)
+    void Receiver::SetCapacity(System::UInt32 capacity)
     {
         receiverp->setCapacity(capacity);
     }
 
-    System::UInt32 Receiver::getCapacity()
+    System::UInt32 Receiver::GetCapacity()
     {
         return receiverp->getCapacity();
     }
 
-    System::UInt32 Receiver::getAvailable()
+    System::UInt32 Receiver::GetAvailable()
     {
         return receiverp->getAvailable();
     }
 
-    System::UInt32 Receiver::getUnsettled()
+    System::UInt32 Receiver::GetUnsettled()
     {
         return receiverp->getUnsettled();
     }
 
-    void Receiver::close()
+    void Receiver::Close()
     {
         receiverp->close();
     }
 
-    System::String ^ Receiver::getName()
+    System::String ^ Receiver::GetName()
     {
         return gcnew System::String(receiverp->getName().c_str());
     }
 
-    Session ^ Receiver::getSession()
+    Session ^ Receiver::GetSession()
     {
         return parentSession;
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
index 26d0402..0dc2f61 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
@@ -35,10 +35,10 @@ namespace messaging {
     class ReceiverImpl {};
 }}
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Mreceiver is a managed wrapper for a ::qpid::messaging::Receiver
@@ -57,38 +57,43 @@ namespace messaging {
         // Kept object deletion code
         void Cleanup();
 
-    public:
         // The kept object in the Messaging C++ DLL
         ::qpid::messaging::Receiver * receiverp;
 
+    public:
         Receiver(::qpid::messaging::Receiver * r,
             Session ^ sessRef);
         ~Receiver();
         !Receiver();
         Receiver(const Receiver ^ rhs);
 
-        // get(message)
-        bool get(Message ^ mmsgp);
-        bool get(Message ^ mmsgp, Duration ^ durationp);
-
-        // message = get()
-        Message ^ get();
-        Message ^ get(Duration ^ durationp);
-
-        // fetch(message)
-        bool fetch(Message ^ mmsgp);
-        bool fetch(Message ^ mmsgp, Duration ^ duration);
-
-        // message = fetch()
-        Message ^ fetch();
-        Message ^ fetch(Duration ^ durationp);
-
-        void setCapacity(System::UInt32 capacity);
-        System::UInt32 getCapacity();
-        System::UInt32 getAvailable();
-        System::UInt32 getUnsettled();
-        void close();
-        System::String ^ getName();
-        Session ^ getSession();
+        property ::qpid::messaging::Receiver * NativeReceiver
+        {
+            ::qpid::messaging::Receiver * get () { return receiverp; }
+        }
+
+        // Get(message)
+        bool Get(Message ^ mmsgp);
+        bool Get(Message ^ mmsgp, Duration ^ durationp);
+
+        // message = Get()
+        Message ^ Get();
+        Message ^ Get(Duration ^ durationp);
+
+        // Fetch(message)
+        bool Fetch(Message ^ mmsgp);
+        bool Fetch(Message ^ mmsgp, Duration ^ duration);
+
+        // message = Fetch()
+        Message ^ Fetch();
+        Message ^ Fetch(Duration ^ durationp);
+
+        void SetCapacity(System::UInt32 capacity);
+        System::UInt32 GetCapacity();
+        System::UInt32 GetAvailable();
+        System::UInt32 GetUnsettled();
+        void Close();
+        System::String ^ GetName();
+        Session ^ GetSession();
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
index 1708359..e0911b3 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
@@ -30,10 +30,10 @@
 #include "Sender.h"
 #include "Message.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Sender a managed wrapper for a ::qpid::messaging::Sender 
@@ -79,25 +79,25 @@ namespace messaging {
     }
 
     //
-    // send(msg)
+    // Send(msg)
     //
-    void Sender::send(Message ^ mmsgp)
+    void Sender::Send(Message ^ mmsgp)
     {
-        send(mmsgp, false);
+        Send(mmsgp, false);
     }
 
-    void Sender::send(Message ^ mmsgp, bool sync)
+    void Sender::Send(Message ^ mmsgp, bool sync)
     {
-        senderp->::qpid::messaging::Sender::send(*((*mmsgp).messagep), sync);
+        senderp->::qpid::messaging::Sender::send(*((*mmsgp).NativeMessage), sync);
     }
 
 
-    void Sender::close()
+    void Sender::Close()
     {
         senderp->close();
     }
 
-    Session ^ Sender::getSession()
+    Session ^ Sender::GetSession()
     {
         return parentSession;
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Sender.h b/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
index 17f7e82..705c7d5 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
@@ -34,10 +34,10 @@ namespace messaging {
     class SenderImpl {};
 }}
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Sender is a managed wrapper for a ::qpid::messaging::Sender 
@@ -65,11 +65,11 @@ namespace messaging {
         !Sender();
         Sender(const Sender % rhs);
 
-        // send(message)
-        void send(Message ^ mmsgp);
-        void send(Message ^ mmsgp, bool sync);
+        // Send(message)
+        void Send(Message ^ mmsgp);
+        void Send(Message ^ mmsgp, bool sync);
 
-        void close();
+        void Close();
 
         property System::UInt32 Capacity
         {
@@ -95,6 +95,6 @@ namespace messaging {
             }
         }
 
-        Session ^ getSession();
+        Session ^ GetSession();
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
index c070f10..c8d85b0 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
@@ -35,10 +35,10 @@
 #include "Message.h"
 #include "QpidException.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Session is a managed wrapper for a ::qpid::messaging::Session
@@ -84,110 +84,93 @@ namespace messaging {
         }
     }
 
-    void Session::close()
+    void Session::Close()
     {
         sessionp->close();
     }
 
-    void Session::commit()
+    void Session::Commit()
     {
         sessionp->commit();
     }
 
-    void Session::rollback()
+    void Session::Rollback()
     {
         sessionp->rollback();
     }
 
-    void Session::acknowledge()
+    void Session::Acknowledge()
     {
-        acknowledge(false);
+        Acknowledge(false);
     }
 
-    void Session::acknowledge(bool sync)
+    void Session::Acknowledge(bool sync)
     {
         sessionp->acknowledge(sync);
     }
 
-    void Session::reject(Message ^ message)
+    void Session::Reject(Message ^ message)
     {
-        sessionp->::qpid::messaging::Session::reject(*(message->messagep));
+        sessionp->::qpid::messaging::Session::reject(*(message->NativeMessage));
     }
 
-    void Session::release(Message ^ message)
+    void Session::Release(Message ^ message)
     {
-        sessionp->::qpid::messaging::Session::release(*(message->messagep));
+        sessionp->::qpid::messaging::Session::release(*(message->NativeMessage));
     }
 
-    void Session::sync()
+    void Session::Sync()
     {
-        sync(true);
+        Sync(true);
     }
 
-    void Session::sync(bool block)
+    void Session::Sync(bool block)
     {
         sessionp->sync(block);
     }
 
     // next(receiver)
-    bool Session::nextReceiver(Receiver ^ rcvr)
+    bool Session::NextReceiver(Receiver ^ rcvr)
     {
-        return nextReceiver(rcvr, DurationConstants::FORVER);
+        return NextReceiver(rcvr, DurationConstants::FORVER);
     }
 
-    bool Session::nextReceiver(Receiver ^ rcvr, Duration ^ timeout)
+    bool Session::NextReceiver(Receiver ^ rcvr, Duration ^ timeout)
     {
         System::Exception           ^ newException = nullptr;
 
-        try
-        {
+        try 
+		{
+			// create a duration object
             ::qpid::messaging::Duration dur(timeout->Milliseconds);
 
-            return sessionp->nextReceiver(*(rcvr->receiverp), dur);
+			// wait for the next received message
+            return sessionp->nextReceiver(*(rcvr->NativeReceiver), dur);
         } 
         catch (const ::qpid::types::Exception & error) 
-        {
+		{
             String ^ errmsg = gcnew String(error.what());
-            if (errmsg = "No message to fetch")
-            {
-                // on timeout return null
+            if ("No message to fetch" == errmsg){
                 return false;
             }
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Session::nextReceiver unknown error");
 
-        }
-        finally
-        {
-            // Clean up and throw on caught exceptions
-            if (newException != nullptr)
-            {
-                if (sessionp != NULL)
-                {
-                    delete sessionp;
-                }
+		if (newException != nullptr) 
+		{
+	        throw newException;
+		}
 
-                throw newException;
-            }
-        }
         return true;
     }
 
     // receiver = next()
-    Receiver ^ Session::nextReceiver()
+    Receiver ^ Session::NextReceiver()
     {
-        return nextReceiver(DurationConstants::FORVER);
+        return NextReceiver(DurationConstants::FORVER);
     }
 
-    Receiver ^ Session::nextReceiver(Duration ^ timeout)
+    Receiver ^ Session::NextReceiver(Duration ^ timeout)
     {
         System::Exception           ^ newException = nullptr;
 
@@ -205,41 +188,23 @@ namespace messaging {
         catch (const ::qpid::types::Exception & error) 
         {
             String ^ errmsg = gcnew String(error.what());
-            if (errmsg = "No message to fetch")
+            if ("No message to fetch" == errmsg)
             {
-                // on timeout return null
                 return nullptr;
             }
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Session::nextReceiver unknown error");
 
-        }
-        finally
-        {
-            // Clean up and throw on caught exceptions
-            if (newException != nullptr)
-            {
-                if (sessionp != NULL)
-                {
-                    delete sessionp;
-                }
+		if (newException != nullptr) 
+		{
+	        throw newException;
+		}
 
-                throw newException;
-            }
-        }
-        return nullptr;
+		return nullptr;
     }
 
 
-    Sender ^ Session::createSender  (System::String ^ address)
+    Sender ^ Session::CreateSender  (System::String ^ address)
     {
         System::Exception          ^ newException = nullptr;
         ::qpid::messaging::Sender  * senderp         = NULL;
@@ -261,41 +226,39 @@ namespace messaging {
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Session::createSender unknown error");
-
-        }
         finally
         {
-            // Clean up and throw on caught exceptions
             if (newException != nullptr)
             {
-                if (senderp != NULL)
-                {
-                    delete senderp;
-                }
-
-                throw newException;
+				if (newSender != nullptr)
+				{
+					delete newSender;
+				}
+				else
+				{
+					if (senderp != NULL)
+					{
+						delete senderp;
+					}
+				}
             }
         }
+        if (newException != nullptr) 
+		{
+	        throw newException;
+		}
 
         return newSender;
     }
 
-    Receiver ^ Session::createReceiver(System::String ^ address)
+    Receiver ^ Session::CreateReceiver(System::String ^ address)
     {
         System::Exception           ^ newException = nullptr;
         ::qpid::messaging::Receiver * receiverp    = NULL;
         Receiver                    ^ newReceiver  = nullptr;
 
-        try
-        {
+        try 
+		{
             // allocate a native receiver
             receiverp = new ::qpid::messaging::Receiver;
 
@@ -306,39 +269,37 @@ namespace messaging {
             newReceiver = gcnew Receiver(receiverp, this);
         } 
         catch (const ::qpid::types::Exception & error) 
-        {
+		{
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Session::createReceiver unknown error");
-
-        }
-        finally
-        {
-            // Clean up and throw on caught exceptions
+        finally 
+		{
             if (newException != nullptr)
-            {
-                if (sessionp != NULL)
-                {
-                    delete sessionp;
-                }
-
-                throw newException;
+			{
+				if (newReceiver != nullptr)
+				{
+					delete newReceiver;
+				}
+				else
+				{
+					if (receiverp != NULL)
+					{
+						delete receiverp;
+					}
+				}
             }
         }
+        if (newException != nullptr) 
+		{
+	        throw newException;
+		}
 
         return newReceiver;
     }
 
 
-    Receiver ^ Session::createReceiver()
+    Receiver ^ Session::CreateReceiver()
     {
         System::Exception           ^ newException = nullptr;
         ::qpid::messaging::Receiver * receiverp    = NULL;
@@ -357,35 +318,33 @@ namespace messaging {
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Session::createReceiver unknown error");
-
-        }
-        finally
-        {
-            // Clean up and throw on caught exceptions
+        finally 
+		{
             if (newException != nullptr)
-            {
-                if (sessionp != NULL)
-                {
-                    delete sessionp;
-                }
-
-                throw newException;
+			{
+				if (newReceiver != nullptr)
+				{
+					delete newReceiver;
+				}
+				else
+				{
+					if (receiverp != NULL)
+					{
+						delete receiverp;
+					}
+				}
             }
         }
+        if (newException != nullptr) 
+		{
+	        throw newException;
+		}
 
         return newReceiver;
     }
 
 
-    Sender ^ Session::getSender(System::String ^ name)
+    Sender ^ Session::GetSender(System::String ^ name)
     {
         ::qpid::messaging::Sender * sender = new ::qpid::messaging::Sender;
 
@@ -398,7 +357,7 @@ namespace messaging {
 
 
 
-    Receiver ^ Session::getReceiver(System::String ^ name)
+    Receiver ^ Session::GetReceiver(System::String ^ name)
     {
         ::qpid::messaging::Receiver * receiver = new ::qpid::messaging::Receiver;
 
@@ -411,12 +370,12 @@ namespace messaging {
 
 
 
-    Connection ^ Session::getConnection()
+    Connection ^ Session::GetConnection()
     {
         return parentConnectionp;
     }
 
-    void Session::checkError()
+    void Session::CheckError()
     {
         sessionp->checkError();
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.h b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
index 3212f05..babb99d 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
@@ -36,10 +36,10 @@ namespace messaging {
     class SessionImpl {};
 }}
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Session is a managed wrapper for a ::qpid::messaging::Session
@@ -70,15 +70,15 @@ namespace messaging {
         !Session();
         Session(const Session % rhs);
 
-        void close();
-        void commit();
-        void rollback();
-        void acknowledge();
-        void acknowledge(bool sync);
-        void reject(Message ^);
-        void release(Message ^);
-        void sync();
-        void sync(bool block);
+        void Close();
+        void Commit();
+        void Rollback();
+        void Acknowledge();
+        void Acknowledge(bool sync);
+        void Reject(Message ^);
+        void Release(Message ^);
+        void Sync();
+        void Sync(bool block);
 
         property System::UInt32 Receivable
         {
@@ -91,28 +91,28 @@ namespace messaging {
         }
 
         // next(receiver)
-        bool nextReceiver(Receiver ^);
-        bool nextReceiver(Receiver ^, Duration ^ timeout);
+        bool NextReceiver(Receiver ^ rcvr);
+        bool NextReceiver(Receiver ^ rcvr, Duration ^ timeout);
 
         // receiver = next()
-        Receiver ^ nextReceiver();
-        Receiver ^ nextReceiver(Duration ^ timeout);
+        Receiver ^ NextReceiver();
+        Receiver ^ NextReceiver(Duration ^ timeout);
 
 
-        Sender   ^ createSender  (System::String ^ address);
-        Receiver ^ createReceiver(System::String ^ address);
-        Receiver ^ createReceiver();
+        Sender   ^ CreateSender  (System::String ^ address);
+        Receiver ^ CreateReceiver(System::String ^ address);
+        Receiver ^ CreateReceiver();
 
-        Sender   ^ getSender(System::String ^ name);
-        Receiver ^ getReceiver(System::String ^ name);
+        Sender   ^ GetSender(System::String ^ name);
+        Receiver ^ GetReceiver(System::String ^ name);
 
-        Connection ^ getConnection();
+        Connection ^ GetConnection();
 
         property System::Boolean HasError
         {
             System::Boolean get () { return sessionp->hasError(); }
         }
 
-        void checkError();
+        void CheckError();
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
index 3fbe1e2..d463e66 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
@@ -29,10 +29,10 @@
 #include "QpidTypeCheck.h"
 #include "QpidMarshal.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Translate between managed and native types.
@@ -42,11 +42,12 @@ namespace messaging {
     // The given object is a Dictionary.
     // Add its elements to the qpid map.
     //
-    void TypeTranslator::ManagedToNative(::qpid::types::Variant::Map & theMapp,
-                         QpidMap ^ theObjp)
+    void TypeTranslator::ManagedToNative(QpidMap ^ theDictionary,
+										 ::qpid::types::Variant::Map & qpidMap)
     {
         // iterate the items, converting each to a variant and adding to the map
-        for each (System::Collections::Generic::KeyValuePair<System::String^, System::Object^> kvp in theObjp)
+        for each (System::Collections::Generic::KeyValuePair
+			<System::String^, System::Object^> kvp in theDictionary)
         {
             if (QpidTypeCheck::ObjectIsMap(kvp.Value))
             {
@@ -55,7 +56,7 @@ namespace messaging {
                 ::qpid::types::Variant::Map newMap;
 
                 // Add the map variables to the map
-                ManagedToNative(newMap, (QpidMap ^)kvp.Value);
+                ManagedToNative((QpidMap ^)kvp.Value, newMap);
 
                 // Create a variant entry for the inner map
                 std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newMap));
@@ -64,7 +65,7 @@ namespace messaging {
                 std::string entryName = QpidMarshal::ToNative(kvp.Key);
 
                 // Add inner map to outer map
-                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, *newVariantp));
+                qpidMap.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, *newVariantp));
             }
             else if (QpidTypeCheck::ObjectIsList(kvp.Value))
             {
@@ -73,7 +74,7 @@ namespace messaging {
                 ::qpid::types::Variant::List newList;
 
                 // Add the List variables to the list
-                ManagedToNative(newList, (QpidList ^)kvp.Value);
+                ManagedToNative((QpidList ^)kvp.Value, newList);
 
                 // Create a variant entry for the inner map
                 ::qpid::types::Variant::List newVariant(newList);
@@ -84,7 +85,7 @@ namespace messaging {
                 std::string entryName = QpidMarshal::ToNative(kvp.Key);
 
                 // Add inner list to outer map
-                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, newVariant));
+                qpidMap.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, newVariant));
             }
             else
             {
@@ -92,7 +93,7 @@ namespace messaging {
                 ::qpid::types::Variant entryValue;
                 ManagedToNativeObject(kvp.Value, entryValue);
                 std::string entryName = QpidMarshal::ToNative(kvp.Key);
-                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, entryValue));
+                qpidMap.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, entryValue));
             }
         }
     }
@@ -103,11 +104,11 @@ namespace messaging {
     // The given object is a List.
     // Add its elements to the qpid list.
     //
-    void TypeTranslator::ManagedToNative(::qpid::types::Variant::List & theListp,
-                         QpidList ^ theObjp)
+    void TypeTranslator::ManagedToNative(QpidList ^ theList,
+										 ::qpid::types::Variant::List & qpidList)
     {
         // iterate the items, converting each to a variant and adding to the map
-        for each (System::Object ^ listObj in theObjp)
+        for each (System::Object ^ listObj in theList)
         {
             if (QpidTypeCheck::ObjectIsMap(listObj))
             {
@@ -116,13 +117,13 @@ namespace messaging {
                 ::qpid::types::Variant::Map newMap;
 
                 // Add the map variables to the map
-                ManagedToNative(newMap, (QpidMap ^)listObj);
+                ManagedToNative((QpidMap ^)listObj, newMap);
 
                 // Create a variant entry for the inner map
                 std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newMap));
 
                 // Add inner map to outer list
-                theListp.push_back(*newVariantp);
+                qpidList.push_back(*newVariantp);
             }
             else if (QpidTypeCheck::ObjectIsList(listObj))
             {
@@ -131,20 +132,20 @@ namespace messaging {
                 ::qpid::types::Variant::List newList;
 
                 // Add the List variables to the list
-                ManagedToNative(newList, (QpidList ^)listObj);
+                ManagedToNative((QpidList ^)listObj, newList);
 
                 // Create a variant entry for the inner list
                 std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newList));
 
                 // Add inner list to outer list
-                theListp.push_back(*newVariantp);
+                qpidList.push_back(*newVariantp);
             }
             else
             {
                 // Add a simple native type to list
                 ::qpid::types::Variant entryValue;
                 ManagedToNativeObject(listObj, entryValue);
-                theListp.push_back(entryValue);
+                qpidList.push_back(entryValue);
             }
         }
     }
@@ -155,57 +156,57 @@ namespace messaging {
     // Returns a variant representing simple native type object.
     // Not to be called for Map/List objects.
     //
-    void TypeTranslator::ManagedToNativeObject(System::Object ^ theObjp, 
-                               ::qpid::types::Variant & targetp)
+    void TypeTranslator::ManagedToNativeObject(System::Object ^ managedValue, 
+                               ::qpid::types::Variant & qpidVariant)
     {
-        System::Type     ^ typeP    = (*theObjp).GetType();
+        System::Type     ^ typeP    = (*managedValue).GetType();
         System::TypeCode   typeCode = System::Type::GetTypeCode( typeP );
 
         switch (typeCode)
         {
         case System::TypeCode::Boolean :
-            targetp = System::Convert::ToBoolean(theObjp);
+			qpidVariant = System::Convert::ToBoolean(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::Byte :
-            targetp = System::Convert::ToByte(theObjp);
+            qpidVariant = System::Convert::ToByte(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::UInt16 :
-            targetp = System::Convert::ToUInt16(theObjp);
+            qpidVariant = System::Convert::ToUInt16(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::UInt32 :
-            targetp = System::Convert::ToUInt32(theObjp);
+            qpidVariant = System::Convert::ToUInt32(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::UInt64 :
-            targetp = System::Convert::ToUInt64(theObjp);
+            qpidVariant = System::Convert::ToUInt64(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::Char :
         case System::TypeCode::SByte :
-            targetp = System::Convert::ToSByte(theObjp);
+            qpidVariant = System::Convert::ToSByte(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::Int16 :
-            targetp = System::Convert::ToInt16(theObjp);
+            qpidVariant = System::Convert::ToInt16(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::Int32 :
-            targetp = System::Convert::ToInt32(theObjp);
+            qpidVariant = System::Convert::ToInt32(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::Int64 :
-            targetp = System::Convert::ToInt64(theObjp);
+            qpidVariant = System::Convert::ToInt64(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::Single :
-            targetp = System::Convert::ToSingle(theObjp);
+            qpidVariant = System::Convert::ToSingle(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::Double :
-            targetp = System::Convert::ToDouble(theObjp);
+            qpidVariant = System::Convert::ToDouble(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::String :
@@ -213,10 +214,10 @@ namespace messaging {
                 std::string      rString;
                 System::String ^ rpString;
 
-                rpString = System::Convert::ToString(theObjp);
+                rpString = System::Convert::ToString(managedValue, System::Globalization::CultureInfo::InvariantCulture);
                 rString = QpidMarshal::ToNative(rpString);
-                targetp = rString;
-                targetp.setEncoding(QpidMarshal::ToNative("utf8"));
+                qpidVariant = rString;
+                qpidVariant.setEncoding(QpidMarshal::ToNative("utf8"));
             }
             break;
 
@@ -232,11 +233,12 @@ namespace messaging {
     // Given a user Dictionary and a qpid map,
     //   extract the qpid elements and put them into the dictionary.
     //
-    void TypeTranslator::NativeToManaged(QpidMap ^ dict, ::qpid::types::Variant::Map & map)
+    void TypeTranslator::NativeToManaged(::qpid::types::Variant::Map & qpidMap,
+										 QpidMap ^ dict)
     {
         // For each object in the message map, 
         //  create a .NET object and add it to the dictionary.
-        for (::qpid::types::Variant::Map::const_iterator i = map.begin(); i != map.end(); ++i) {
+        for (::qpid::types::Variant::Map::const_iterator i = qpidMap.begin(); i != qpidMap.end(); ++i) {
             // Get the name
             System::String ^ elementName = gcnew String(i->first.c_str());
 
@@ -299,7 +301,7 @@ namespace messaging {
                 {
                     QpidMap ^ newDict = gcnew QpidMap();
 
-                    NativeToManaged(newDict, variant.asMap());
+                    NativeToManaged(variant.asMap(), newDict);
 
                     dict[elementName] = newDict;
                     break;
@@ -309,7 +311,7 @@ namespace messaging {
                 {
                     QpidList ^ newList = gcnew QpidList();
 
-                    NativeToManaged(newList, variant.asList());
+                    NativeToManaged(variant.asList(), newList);
 
                     dict[elementName] = newList;
                     break;
@@ -322,10 +324,10 @@ namespace messaging {
     }
 
 
-    void TypeTranslator::NativeToManaged(QpidList ^ vList, ::qpid::types::Variant::List & qpidList)
+    void TypeTranslator::NativeToManaged(::qpid::types::Variant::List & qpidList, QpidList ^ managedList)
     {
-        // For each object in the message map, 
-        //  create a .NET object and add it to the dictionary.
+        // For each object in the qpidList 
+        //  create a .NET object and add it to the managed List.
         for (::qpid::types::Variant::List::const_iterator i = qpidList.begin(); i != qpidList.end(); ++i) 
         {
             ::qpid::types::Variant     variant = *i;
@@ -334,62 +336,62 @@ namespace messaging {
             switch (vType)
             {
             case ::qpid::types::VAR_BOOL:
-                (*vList).Add(variant.asBool());
+                (*managedList).Add(variant.asBool());
                 break;
                 
             case ::qpid::types::VAR_UINT8:
-                (*vList).Add(variant.asUint8());
+                (*managedList).Add(variant.asUint8());
                 break;
                 
             case ::qpid::types::VAR_UINT16:
-                (*vList).Add(variant.asUint16());
+                (*managedList).Add(variant.asUint16());
                 break;
                 
             case ::qpid::types::VAR_UINT32:
-                (*vList).Add(variant.asUint32());
+                (*managedList).Add(variant.asUint32());
                 break;
                 
             case ::qpid::types::VAR_UINT64:
-                (*vList).Add(variant.asUint64());
+                (*managedList).Add(variant.asUint64());
                 break;
                 
             case ::qpid::types::VAR_INT8:
-                (*vList).Add(variant.asInt8());
+                (*managedList).Add(variant.asInt8());
                 break;
                 
             case ::qpid::types::VAR_INT16:
-                (*vList).Add(variant.asInt16());
+                (*managedList).Add(variant.asInt16());
                 break;
                 
             case ::qpid::types::VAR_INT32:
-                (*vList).Add(variant.asInt32());
+                (*managedList).Add(variant.asInt32());
                 break;
                 
             case ::qpid::types::VAR_INT64:
-                (*vList).Add(variant.asInt64());
+                (*managedList).Add(variant.asInt64());
                 break;
                 
             case ::qpid::types::VAR_FLOAT:
-                (*vList).Add(variant.asFloat());
+                (*managedList).Add(variant.asFloat());
                 break;
                 
             case ::qpid::types::VAR_DOUBLE:
-                (*vList).Add(variant.asDouble());
+                (*managedList).Add(variant.asDouble());
                 break;
                 
             case ::qpid::types::VAR_STRING:
                 {
                     System::String ^ elementValue = gcnew System::String(variant.asString().c_str());
-                    (*vList).Add(elementValue);
+                    (*managedList).Add(elementValue);
                     break;
                 }
             case ::qpid::types::VAR_MAP:
                 {
                     QpidMap ^ newDict = gcnew QpidMap();
 
-                    NativeToManaged(newDict, variant.asMap());
+                    NativeToManaged(variant.asMap(), newDict);
 
-                    (*vList).Add(newDict);
+                    (*managedList).Add(newDict);
                     break;
                 }
 
@@ -397,9 +399,9 @@ namespace messaging {
                 {
                     QpidList ^ newList = gcnew QpidList();
 
-                    NativeToManaged(newList, variant.asList());
+                    NativeToManaged(variant.asList(), newList);
 
-                    (*vList).Add(newList);
+                    (*managedList).Add(newList);
                     break;
                 }
                 
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h
index 7ffba69..df12689 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h
@@ -28,43 +28,44 @@
 
 #include "QpidTypeCheck.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// TypeTranslator provides codec between .NET Dictionary/List and
     /// qpid messaging Map/List.
     /// </summary>
-
-    public ref class TypeTranslator
+    public ref class TypeTranslator sealed
     {
+	private:
+		TypeTranslator::TypeTranslator() {}
 
     public:
-        // The given object is a Dictionary.
+        // The given object is a managed Dictionary.
         // Add its elements to the qpid map.
-        static void ManagedToNative(::qpid::types::Variant::Map & theMapp,
-                                    QpidMap ^ theObjp);
+        static void ManagedToNative(QpidMap ^ theDictionary,
+									::qpid::types::Variant::Map & qpidMap);
 
-        // The given object is a List.
+        // The given object is a managed List.
         // Add its elements to the qpid list.
-        static void ManagedToNative(::qpid::types::Variant::List & theListp,
-                                    QpidList ^ theObjp);
+        static void ManagedToNative(QpidList ^ theList,
+									::qpid::types::Variant::List & qpidList);
 
-        // The given object is a simple native type (not a Dictionary or List)
+        // The given object is a simple managed type (not a Dictionary or List)
         // Returns a variant representing simple native type object.
-        static void ManagedToNativeObject(System::Object ^ theObjp,
-                                          ::qpid::types::Variant & targetp);
+        static void ManagedToNativeObject(System::Object ^ managedValue,
+                                          ::qpid::types::Variant & qpidVariant);
 
-        // Given a Dictionary,
-        // Return its values in a Qpid map
-        static void NativeToManaged(QpidMap ^ dict, 
-                                    ::qpid::types::Variant::Map & map);
+        // The given object is a qpid map.
+        // Add its elements to the managed Dictionary.
+        static void NativeToManaged(::qpid::types::Variant::Map & qpidMap,
+									QpidMap ^ dict);
 
-        // Given a List,
-        // Return its values in a Qpid list
-        static void NativeToManaged(QpidList ^ vList, 
-                                    ::qpid::types::Variant::List & qpidList);
+        // The given object is a qpid list.
+        // Add its elements to the managed List.
+        static void NativeToManaged(::qpid::types::Variant::List & qpidList,
+									QpidList ^ managedList);
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc
index 0e47bae..71f051c 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc
+++ b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc
@@ -69,12 +69,12 @@ BEGIN
     BEGIN
         BLOCK "040904b0"
         BEGIN
-            VALUE "FileDescription", "org"
+            VALUE "FileDescription", "org.apache.qpid.messaging"
             VALUE "FileVersion", "1, 3, 0, 1"
-            VALUE "InternalName", "org"
+            VALUE "InternalName", "org.apache.qpid.messaging"
             VALUE "LegalCopyright", "Copyright (C) 2010"
             VALUE "OriginalFilename", "org.apache.qpid.messaging"
-            VALUE "ProductName", "org"
+            VALUE "ProductName", "org.apache.qpid.messaging"
             VALUE "ProductVersion", "1, 3, 0, 1"
         END
     END
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
index 7c31781..9700b59 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
+++ b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
@@ -2,7 +2,7 @@
 <VisualStudioProject
 	ProjectType="Visual C++"
 	Version="9.00"
-	Name="org.apache.qpid.messaging"
+	Name="Org.Apache.Qpid.Messaging"
 	ProjectGUID="{AA5A3B83-5F98-406D-A01C-5A921467A57D}"
 	RootNamespace="org.apache.qpid.messaging"
 	Keyword="ManagedCProj"
@@ -244,6 +244,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\QpidException.h"
+				>
+			</File>
+			<File
 				RelativePath=".\QpidMarshal.h"
 				>
 			</File>
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs
index 57f83ad..19c1ea9 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs
@@ -24,11 +24,11 @@ using System.Runtime.InteropServices;
 // General Information about an assembly is controlled through the following 
 // set of attributes. Change these attribute values to modify the information
 // associated with an assembly.
-[assembly: AssemblyTitle("org.apache.qpid.messaging.sessionreceiver")]
+[assembly: AssemblyTitle("Org.Apache.Qpid.Messaging.SessionReceiver")]
 [assembly: AssemblyDescription("")]
 [assembly: AssemblyConfiguration("")]
 [assembly: AssemblyCompany("")]
-[assembly: AssemblyProduct("org.apache.qpid.messaging.sessionreceiver")]
+[assembly: AssemblyProduct("Org.Apache.Qpid.Messaging.SessionReceiver")]
 [assembly: AssemblyCopyright("Copyright   2010")]
 [assembly: AssemblyTrademark("")]
 [assembly: AssemblyCulture("")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs
index 73956ec..c5a1a7e 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs
@@ -23,9 +23,9 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
-using org.apache.qpid.messaging;
+using Org.Apache.Qpid.Messaging;
 
-namespace org.apache.qpid.messaging.sessionreceiver
+namespace Org.Apache.Qpid.Messaging.SessionReceiver
 {
     /// <summary>
     /// ISessionReceiver interface defines the callback for users to supply.
@@ -43,19 +43,19 @@ namespace org.apache.qpid.messaging.sessionreceiver
 
     
     /// <summary>
-    /// eventEngine - wait for messages from the underlying C++ code.
+    /// EventEngine - wait for messages from the underlying C++ code.
     /// When available get them and deliver them via callback to our 
     /// client through the ISessionReceiver interface.
     /// This class consumes the thread that calls the Run() function.
     /// </summary>
 
-    internal class eventEngine
+    internal class EventEngine
     {
         private Session          session;
         private ISessionReceiver callback;
         private bool             keepRunning;
 
-        public eventEngine(Session theSession, ISessionReceiver thecallback)
+        public EventEngine(Session theSession, ISessionReceiver thecallback)
         {
             this.session  = theSession;
             this.callback = thecallback;
@@ -65,35 +65,35 @@ namespace org.apache.qpid.messaging.sessionreceiver
         /// Function to call Session's nextReceiver, discover messages,
         /// and to deliver messages through the callback.
         /// </summary>
-        public void open()
+        public void Open()
         {
-            Receiver rcvr = session.createReceiver();
+            Receiver rcvr = session.CreateReceiver();
             Message  msg;
 
             keepRunning = true;
             while (keepRunning)
             {
-                if (session.nextReceiver(rcvr, DurationConstants.SECOND))
+                if (session.NextReceiver(rcvr, DurationConstants.SECOND))
                 {
                     if (keepRunning)
                     {
-                        msg = rcvr.fetch(DurationConstants.SECOND);
+                        msg = rcvr.Fetch(DurationConstants.SECOND);
                         this.callback.SessionReceiver(rcvr, msg);
                     }
                 }
                 //else
                 //    receive timed out
-                //    eventEngine exits the nextReceiver() function periodically
+                //    EventEngine exits the nextReceiver() function periodically
                 //    in order to test the keepRunning flag
             }
             // Private thread is now exiting.
         }
 
         /// <summary>
-        /// Function to stop the eventEngine. Private thread will exit within
+        /// Function to stop the EventEngine. Private thread will exit within
         /// one second.
         /// </summary>
-        public void close()
+        public void Close()
         {
             keepRunning = false;
         }
@@ -104,9 +104,9 @@ namespace org.apache.qpid.messaging.sessionreceiver
     /// server is the class that users instantiate to connect a SessionReceiver
     /// callback to the stream of received messages received on a Session.
     /// </summary>
-    public class server
+    public class CallbackServer
     {
-        private eventEngine ee;
+        private EventEngine ee;
 
         /// <summary>
         /// Constructor for the server.
@@ -114,20 +114,20 @@ namespace org.apache.qpid.messaging.sessionreceiver
         /// <param name="session">The Session whose messages are collected.</param>
         /// <param name="callback">The user function call with each message.</param>
         /// 
-        public server(Session session, ISessionReceiver callback)
+        public CallbackServer(Session session, ISessionReceiver callback)
         {
-            ee = new eventEngine(session, callback);
+            ee = new EventEngine(session, callback);
 
             new System.Threading.Thread(
-                new System.Threading.ThreadStart(ee.open)).Start();
+                new System.Threading.ThreadStart(ee.Open)).Start();
         }
 
         /// <summary>
         /// Function to stop the server.
         /// </summary>
-        public void close()
+        public void Close()
         {
-            ee.close();
+            ee.Close();
         }
     }
 }
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
index 5d16172..923952b 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
@@ -2,9 +2,9 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
-using org.apache.qpid.messaging;
+using Org.Apache.Qpid.Messaging;
 
-namespace org.apache.qpid.messaging
+namespace Org.Apache.Qpid.Messaging
 {
     class Program
     {
@@ -64,22 +64,22 @@ namespace org.apache.qpid.messaging
 
             Address aType = new Address ("check3", "subj", options, "hot");
 
-            Console.WriteLine("aEmpty : {0}", aEmpty.str());
-            Console.WriteLine("aStr   : {0}", aStr.str());
-            Console.WriteLine("aSubj  : {0}", aSubj.str());
-            Console.WriteLine("aType  : {0}", aType.str());
+            Console.WriteLine("aEmpty : {0}", aEmpty.ToStr());
+            Console.WriteLine("aStr   : {0}", aStr.ToStr());
+            Console.WriteLine("aSubj  : {0}", aSubj.ToStr());
+            Console.WriteLine("aType  : {0}", aType.ToStr());
 
             //
             // Raw message data retrieval
             //
 
             Message m2 = new Message("rarey");
-            UInt64 m2Size = m2.getContentSize();
+            UInt64 m2Size = m2.GetContentSize();
 
 
             byte[] myRaw = new byte [m2Size];
 
-            m2.getRaw(myRaw);
+            m2.GetRaw(myRaw);
             Console.WriteLine("Got raw array size {0}", m2Size);
             for (UInt64 i = 0; i < m2Size; i++)
                 Console.Write("{0} ", myRaw[i].ToString());
-- 
1.5.5.6

From aa84d40e15cbc74803425d2c49c1c0ce1e4ba484 Mon Sep 17 00:00:00 2001
From: Stephen D. Huston <shuston@apache.org>
Date: Fri, 11 Jun 2010 00:52:28 +0000
Subject: [PATCH] Fix unreferenced variable warnings on Windows build.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953523 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 6315831712123af530943bd9129425c6dc6d7a17)
---
 qpid/cpp/src/qpid/acl/AclData.cpp      |    4 ++--
 qpid/cpp/src/qpid/acl/AclValidator.cpp |    2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/qpid/cpp/src/qpid/acl/AclData.cpp b/qpid/cpp/src/qpid/acl/AclData.cpp
index a03d5b4..658529b 100644
--- a/qpid/cpp/src/qpid/acl/AclData.cpp
+++ b/qpid/cpp/src/qpid/acl/AclData.cpp
@@ -101,7 +101,7 @@ AclResult AclData::lookup(const std::string& id, const Action& action, const Obj
 
                                                           try{                      
                                                               aclMax = boost::lexical_cast<uint64_t>(pMItr->second);
-                                                          }catch(const boost::bad_lexical_cast& e){
+                                                          }catch(const boost::bad_lexical_cast&){
                                                               match = false;  
                                                               QPID_LOG(error,"Error evaluating rule. " << 
                                                               "Illegal value given in ACL source <" << aclSource <<
@@ -113,7 +113,7 @@ AclResult AclData::lookup(const std::string& id, const Action& action, const Obj
                                         
                                                           try{
                                                               paramMax = boost::lexical_cast<uint64_t>(paramItr->second);
-                                                          }catch(const boost::bad_lexical_cast& e){
+                                                          }catch(const boost::bad_lexical_cast&){
                                                               match = false;
                                                               QPID_LOG(error,"Error evaluating rule. " <<
                                                               "Illegal value given in lookup for property '" <<  
diff --git a/qpid/cpp/src/qpid/acl/AclValidator.cpp b/qpid/cpp/src/qpid/acl/AclValidator.cpp
index aeaf638..57b68e5 100644
--- a/qpid/cpp/src/qpid/acl/AclValidator.cpp
+++ b/qpid/cpp/src/qpid/acl/AclValidator.cpp
@@ -37,7 +37,7 @@ bool AclValidator::IntPropertyType::validate(const std::string& val) {
   try
   {
     v = boost::lexical_cast<int64_t>(val);
-  }catch(const boost::bad_lexical_cast& e){
+  }catch(const boost::bad_lexical_cast&){
     return 0;
   }
 
-- 
1.5.5.6

From e2f488f7e8257ffb3ace8ba414d21784e625d3e2 Mon Sep 17 00:00:00 2001
From: Stephen D. Huston <shuston@apache.org>
Date: Fri, 11 Jun 2010 00:59:41 +0000
Subject: [PATCH] Refer to struct Url as that, not a class - fixes compile warnings on Windows.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953526 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 5a8d36c5bfb045876b21da5864ee747e80a1d1f6)
---
 qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.h b/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.h
index f32a075..904cef7 100644
--- a/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.h
+++ b/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.h
@@ -31,7 +31,7 @@
 #include <vector>
 
 namespace qpid {
-class Url;
+struct Url;
 
 namespace client {
 namespace amqp0_10 {
-- 
1.5.5.6

From a74bf473f490b7c7cdca1ad865261f7d82255e2a Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@redhat.com>
Date: Mon, 14 Jun 2010 15:12:58 -0400
Subject: [PATCH] Revert "QPID-2617: Fix the windows build for modified method signature"

This reverts commit 512db9306e1ac6cf8f05f7a646d36f282f88293e.
---
 .../src/qpid/broker/windows/SaslAuthenticator.cpp  |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp b/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp
index 608a8f7..642be29 100644
--- a/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp
+++ b/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp
@@ -68,7 +68,7 @@ bool SaslAuthenticator::available(void)
 }
 
 // Initialize the SASL mechanism; throw if it fails.
-void SaslAuthenticator::init(const std::string& /*saslName*/, const std::string& /*saslConfig*/)
+void SaslAuthenticator::init(const std::string& /*saslName*/)
 {
     return;
 }
-- 
1.5.5.6

From a1cdf640e11415c3376c3e420d40113d2bcc723a Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Tue, 15 Jun 2010 15:34:10 +0000
Subject: [PATCH] Bug 603839 - Fixed - Concurrent tagging of message with trace id while message is delivered from another queue causes segfault

QPID-2670: copy-on-write when tagging message for loop detection

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954933 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit a3ba0d75d20cc5f08bd06046f2eba29650980c40)
---
 qpid/cpp/src/qpid/broker/Message.cpp   |    6 ++++++
 qpid/cpp/src/qpid/broker/Message.h     |    1 +
 qpid/cpp/src/qpid/broker/Queue.cpp     |   13 ++++++++++---
 qpid/cpp/src/qpid/broker/Queue.h       |    2 +-
 qpid/cpp/src/qpid/framing/FrameSet.cpp |   10 ++++++++++
 qpid/cpp/src/qpid/framing/FrameSet.h   |    1 +
 6 files changed, 29 insertions(+), 4 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Message.cpp b/qpid/cpp/src/qpid/broker/Message.cpp
index b086d59..1e56544 100644
--- a/qpid/cpp/src/qpid/broker/Message.cpp
+++ b/qpid/cpp/src/qpid/broker/Message.cpp
@@ -52,6 +52,12 @@ Message::Message(const framing::SequenceNumber& id) :
     expiration(FAR_FUTURE), enqueueCallback(0), dequeueCallback(0),
     inCallback(false), requiredCredit(0) {}
 
+Message::Message(const Message& original) :
+    PersistableMessage(), frames(original.frames), persistenceId(0), redelivered(false), loaded(false),
+    staged(false), forcePersistentPolicy(false), publisher(0), adapter(0), 
+    expiration(FAR_FUTURE), enqueueCallback(0), dequeueCallback(0),
+    inCallback(false), requiredCredit(0) {}
+
 Message::~Message()
 {
     if (expiryPolicy)
diff --git a/qpid/cpp/src/qpid/broker/Message.h b/qpid/cpp/src/qpid/broker/Message.h
index 4330a03..ee80657 100644
--- a/qpid/cpp/src/qpid/broker/Message.h
+++ b/qpid/cpp/src/qpid/broker/Message.h
@@ -53,6 +53,7 @@ public:
     typedef boost::function<void (const boost::intrusive_ptr<Message>&)> MessageCallback;
     
     QPID_BROKER_EXTERN Message(const framing::SequenceNumber& id = framing::SequenceNumber());
+    QPID_BROKER_EXTERN Message(const Message&);
     QPID_BROKER_EXTERN ~Message();
         
     uint64_t getPersistenceId() const { return persistenceId; }
diff --git a/qpid/cpp/src/qpid/broker/Queue.cpp b/qpid/cpp/src/qpid/broker/Queue.cpp
index 8c9e5b8..7f7b2bc 100644
--- a/qpid/cpp/src/qpid/broker/Queue.cpp
+++ b/qpid/cpp/src/qpid/broker/Queue.cpp
@@ -216,7 +216,8 @@ void Queue::requeue(const QueuedMessage& msg){
         if(inLastNodeFailure && persistLastNode && !msg.payload->isStoredOnQueue(shared_from_this())) {
             msg.payload->forcePersistent();
             if (msg.payload->isForcedPersistent() ){
-            	enqueue(0, msg.payload);
+                boost::intrusive_ptr<Message> payload = msg.payload;
+            	enqueue(0, payload);
             }
         }
     }
@@ -720,7 +721,7 @@ void Queue::setLastNodeFailure()
 
 
 // return true if store exists, 
-bool Queue::enqueue(TransactionContext* ctxt, boost::intrusive_ptr<Message> msg, bool suppressPolicyCheck)
+bool Queue::enqueue(TransactionContext* ctxt, boost::intrusive_ptr<Message>& msg, bool suppressPolicyCheck)
 {
     ScopedUse u(barrier);
     if (!u.acquired) return false;
@@ -741,6 +742,11 @@ bool Queue::enqueue(TransactionContext* ctxt, boost::intrusive_ptr<Message> msg,
     }
        
     if (traceId.size()) {
+        //copy on write: take deep copy of message before modifying it
+        //as the frames may already be available for delivery on other
+        //threads
+        boost::intrusive_ptr<Message> copy(new Message(*msg));
+        msg = copy;
         msg->addTraceId(traceId);
     }
 
@@ -1158,7 +1164,8 @@ void Queue::enqueued(const QueuedMessage& m)
             policy->enqueued(m);
         }
         mgntEnqStats(m.payload);
-        enqueue ( 0, m.payload, true );
+        boost::intrusive_ptr<Message> payload = m.payload;
+        enqueue ( 0, payload, true );
     } else {
         QPID_LOG(warning, "Queue informed of enqueued message that has no payload");
     }
diff --git a/qpid/cpp/src/qpid/broker/Queue.h b/qpid/cpp/src/qpid/broker/Queue.h
index cdfa8a1..ebef6e4 100644
--- a/qpid/cpp/src/qpid/broker/Queue.h
+++ b/qpid/cpp/src/qpid/broker/Queue.h
@@ -260,7 +260,7 @@ namespace qpid {
             QPID_BROKER_EXTERN void setLastNodeFailure();
             QPID_BROKER_EXTERN void clearLastNodeFailure();
 
-            bool enqueue(TransactionContext* ctxt, boost::intrusive_ptr<Message> msg, bool suppressPolicyCheck = false);
+            bool enqueue(TransactionContext* ctxt, boost::intrusive_ptr<Message>& msg, bool suppressPolicyCheck = false);
             void enqueueAborted(boost::intrusive_ptr<Message> msg);
             /**
              * dequeue from store (only done once messages is acknowledged)
diff --git a/qpid/cpp/src/qpid/framing/FrameSet.cpp b/qpid/cpp/src/qpid/framing/FrameSet.cpp
index c03dd39..255aaf6 100644
--- a/qpid/cpp/src/qpid/framing/FrameSet.cpp
+++ b/qpid/cpp/src/qpid/framing/FrameSet.cpp
@@ -29,6 +29,16 @@ using namespace qpid::framing;
 using namespace boost;
 
 FrameSet::FrameSet(const SequenceNumber& _id) : id(_id),contentSize(0),recalculateSize(true) { }
+FrameSet::FrameSet(const FrameSet& original) : id(original.id), contentSize(0), recalculateSize(true)
+{
+    for (Frames::const_iterator i = original.begin(); i != original.end(); ++i) {
+        parts.push_back(AMQFrame(*(i->getBody())));
+        parts.back().setFirstSegment(i->isFirstSegment());
+        parts.back().setLastSegment(i->isLastSegment());
+        parts.back().setFirstFrame(i->isFirstFrame());
+        parts.back().setLastFrame(i->isLastFrame());
+    }
+}
 
 void FrameSet::append(const AMQFrame& part)
 {
diff --git a/qpid/cpp/src/qpid/framing/FrameSet.h b/qpid/cpp/src/qpid/framing/FrameSet.h
index 398a709..cae75e5 100644
--- a/qpid/cpp/src/qpid/framing/FrameSet.h
+++ b/qpid/cpp/src/qpid/framing/FrameSet.h
@@ -46,6 +46,7 @@ public:
     typedef boost::shared_ptr<FrameSet> shared_ptr;
 
     QPID_COMMON_EXTERN FrameSet(const SequenceNumber& id);
+    QPID_COMMON_EXTERN FrameSet(const FrameSet&);
     QPID_COMMON_EXTERN void append(const AMQFrame& part);
     QPID_COMMON_EXTERN bool isComplete() const;
 
-- 
1.5.5.6

From abf93417bf2083fdb56ed2cb5e0be50e34d52860 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 16 Jun 2010 18:25:30 +0000
Subject: [PATCH] Bug 602198 - Fix part 1 - qpidd crashes when testing heartbeats

remove assertion for condition that is in fact valid (the callback could have been processed on the back of an event concurrently returned with the interrupt request)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@955339 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 66ea76a8dfe6a1833a1049bfdbc472e9102d6d9f)
---
 qpid/cpp/src/qpid/sys/DispatchHandle.cpp |    2 --
 1 files changed, 0 insertions(+), 2 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/DispatchHandle.cpp b/qpid/cpp/src/qpid/sys/DispatchHandle.cpp
index 605edab..95da87a 100644
--- a/qpid/cpp/src/qpid/sys/DispatchHandle.cpp
+++ b/qpid/cpp/src/qpid/sys/DispatchHandle.cpp
@@ -291,8 +291,6 @@ void DispatchHandle::processEvent(Poller::EventType type) {
         break;
     case Poller::INTERRUPTED:
         {
-        // We could only be interrupted if we also had a callback to do
-        assert(callbacks.size() > 0);
         // We'll actually do the interrupt below
         }
         break;
-- 
1.5.5.6

From eb748c3ccbb31c0567b6b7dfcd47e106dddd1e40 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@redhat.com>
Date: Wed, 16 Jun 2010 14:46:19 -0400
Subject: [PATCH] Bug 602198 - Fix part 2 - qpidd crashes when testing heartbeats

Prevent 'interrupt' callback on object already deleted.
---
 qpid/cpp/src/qpid/sys/DispatchHandle.cpp |   10 ++++++++++
 1 files changed, 10 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/DispatchHandle.cpp b/qpid/cpp/src/qpid/sys/DispatchHandle.cpp
index 95da87a..cd9bfd0 100644
--- a/qpid/cpp/src/qpid/sys/DispatchHandle.cpp
+++ b/qpid/cpp/src/qpid/sys/DispatchHandle.cpp
@@ -302,12 +302,22 @@ void DispatchHandle::processEvent(Poller::EventType type) {
     // (because we use a copy from before the previous callbacks we won't
     //  do anything yet that was just added) 
     while (callbacks.size() > 0) {
+        {
+        ScopedLock<Mutex> lock(stateLock);
+        switch (state) {
+        case DELETING:
+            goto finishcallbacks;
+        default:
+            break;
+        }
+        }
         Callback cb = callbacks.front();
         assert(cb);
         cb(*this);
         callbacks.pop();
     }
 
+finishcallbacks:
     {
     ScopedLock<Mutex> lock(stateLock);
     switch (state) {
-- 
1.5.5.6

From 38ce79eee4d48e2be75c6d74ded2c383fba5810c Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Tue, 15 Jun 2010 10:11:39 +0000
Subject: [PATCH] BZ-567249 added back values method for backwards compatibility

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954787 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/ops.py |    9 +++++++--
 1 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/qpid/python/qpid/ops.py b/qpid/python/qpid/ops.py
index acb54ae..8c9f8a0 100644
--- a/qpid/python/qpid/ops.py
+++ b/qpid/python/qpid/ops.py
@@ -16,14 +16,19 @@
 # specific language governing permissions and limitations
 # under the License.
 #
-import os, mllib, cPickle as pickle
+import os, mllib, cPickle as pickle, sys
 from util import fill
 
 class Primitive(object):
   pass
 
 class Enum(object):
-  pass
+
+  # XXX: for backwards compatibility
+  @classmethod
+  def values(cls):
+    print >> sys.stderr, "warning, please use .VALUES instead of .values()"
+    return cls.VALUES
 
 class Field:
 
-- 
1.5.5.6

From 4e05457ddfe178ac4cfa55bb1dcd6986c272e500 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Tue, 15 Jun 2010 14:13:15 +0000
Subject: [PATCH] BZ-567249 fix for python 2.3

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954901 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/ops.py |    4 +++-
 1 files changed, 3 insertions(+), 1 deletions(-)

diff --git a/qpid/python/qpid/ops.py b/qpid/python/qpid/ops.py
index 8c9f8a0..390552b 100644
--- a/qpid/python/qpid/ops.py
+++ b/qpid/python/qpid/ops.py
@@ -25,10 +25,12 @@ class Primitive(object):
 class Enum(object):
 
   # XXX: for backwards compatibility
-  @classmethod
   def values(cls):
     print >> sys.stderr, "warning, please use .VALUES instead of .values()"
     return cls.VALUES
+  # we can't use the backport preprocessor here because this code gets
+  # called by setup.py
+  values = classmethod(values)
 
 class Field:
 
-- 
1.5.5.6

From b0ae853c18fad859d5e7daabcb0598ab2d197ea6 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Wed, 16 Jun 2010 16:47:18 +0000
Subject: [PATCH] BZ-596677 performance tweaks for receive: added configurable threshold for issuing credit; don't disable byte credit more than necessary; avoided n-squared loop for generating acks

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@955296 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py    |   19 ++++++++++++++++---
 qpid/python/qpid/messaging/endpoints.py |    7 +++++--
 2 files changed, 21 insertions(+), 5 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index 8463aea..16f1b29 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -208,6 +208,7 @@ class LinkIn:
     _rcv.destination = str(rcv.id)
     sst.destinations[_rcv.destination] = _rcv
     _rcv.draining = False
+    _rcv.bytes_open = False
     _rcv.on_unlink = []
 
   def do_link(self, sst, rcv, _rcv, type, subtype, action):
@@ -762,6 +763,7 @@ class Engine:
       sst.write_op(SessionCommandPoint(sst.sent, 0))
       sst.outgoing_idx = 0
       sst.acked = []
+      sst.acked_idx = 0
       if ssn.transactional:
         sst.write_cmd(TxSelect())
       self._attachments[ssn] = sst
@@ -965,7 +967,8 @@ class Engine:
       self.process_receiver(rcv)
 
     if ssn.acked:
-      messages = [m for m in ssn.acked if m not in sst.acked]
+      messages = ssn.acked[sst.acked_idx:]
+      delta = len(messages)
       if messages:
         ids = RangedSet()
 
@@ -975,6 +978,7 @@ class Engine:
           # could we deal this via some message-id based purge?
           if m._transfer_id is None:
             ssn.acked.remove(m)
+            delta -= 1
             continue
           ids.add(m._transfer_id)
           disp = m._disposition or DEFAULT_DISPOSITION
@@ -992,6 +996,7 @@ class Engine:
           def ack_ack():
             for m in msgs:
               ssn.acked.remove(m)
+              sst.acked_idx -= 1
               if not ssn.transactional:
                 sst.acked.remove(m)
           return ack_ack
@@ -1011,7 +1016,9 @@ class Engine:
             for m in msgs:
               log.debug("SACK[%s]: %s, %s", ssn.log_id, m, m._disposition)
 
+        # XXX: could add messages with _transfer_id of None
         sst.acked.extend(messages)
+        sst.acked_idx += delta
 
     if ssn.committing and not sst.committing:
       def commit_ok():
@@ -1076,11 +1083,15 @@ class Engine:
       delta = max(rcv.granted, rcv.received) - rcv.impending
 
     if delta is UNLIMITED:
-      sst.write_cmd(MessageFlow(_rcv.destination, credit_unit.byte, UNLIMITED.value))
+      if not _rcv.bytes_open:
+        sst.write_cmd(MessageFlow(_rcv.destination, credit_unit.byte, UNLIMITED.value))
+        _rcv.bytes_open = True
       sst.write_cmd(MessageFlow(_rcv.destination, credit_unit.message, UNLIMITED.value))
       rcv.impending = UNLIMITED
     elif delta > 0:
-      sst.write_cmd(MessageFlow(_rcv.destination, credit_unit.byte, UNLIMITED.value))
+      if not _rcv.bytes_open:
+        sst.write_cmd(MessageFlow(_rcv.destination, credit_unit.byte, UNLIMITED.value))
+        _rcv.bytes_open = True
       sst.write_cmd(MessageFlow(_rcv.destination, credit_unit.message, delta))
       rcv.impending += delta
     elif delta < 0 and not rcv.draining:
@@ -1088,6 +1099,7 @@ class Engine:
       def do_stop():
         rcv.impending = rcv.received
         _rcv.draining = False
+        _rcv.bytes_open = False
         self.grant(rcv)
       sst.write_cmd(MessageStop(_rcv.destination), do_stop)
 
@@ -1097,6 +1109,7 @@ class Engine:
         rcv.impending = rcv.received
         rcv.granted = rcv.impending
         _rcv.draining = False
+        _rcv.bytes_open = False
         rcv.draining = False
       sst.write_cmd(MessageFlush(_rcv.destination), do_flush)
 
diff --git a/qpid/python/qpid/messaging/endpoints.py b/qpid/python/qpid/messaging/endpoints.py
index f5f957c..707aee3 100644
--- a/qpid/python/qpid/messaging/endpoints.py
+++ b/qpid/python/qpid/messaging/endpoints.py
@@ -29,6 +29,7 @@ Areas that still need work:
 """
 
 from logging import getLogger
+from math import ceil
 from qpid.codec010 import StringCodec
 from qpid.concurrency import synchronized, Waiter, Condition
 from qpid.datatypes import Serial, uuid4
@@ -843,6 +844,7 @@ class Receiver(object):
     self._lock = self.session._lock
     self._capacity = 0
     self._set_capacity(options.get("capacity", 0), False)
+    self.threshold = 0.5
 
   @synchronized
   def _set_capacity(self, c, wakeup=True):
@@ -931,8 +933,9 @@ class Receiver(object):
       if msg is None:
         raise Empty()
     elif self._capacity not in (0, UNLIMITED.value):
-      self.granted += 1
-      self._wakeup()
+      if self.received - self.returned <= int(ceil(self.threshold * self._capacity)):
+        self.granted = self.received + self._capacity
+        self._wakeup()
     return msg
 
   def _grant(self):
-- 
1.5.5.6

From c8e4559e0a26efe70e3a462f8e49a4bd55ba46a2 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@redhat.com>
Date: Tue, 15 Jun 2010 15:52:51 -0400
Subject: [PATCH] Bug 603835 - cluster_tests.test_management failing.

Clean up connections causing extra connection objects in the mangement agent map.
- update connection was not being closed.
- connections belonging to members that left the cluster were not fully cleaned up

Also fixed test errors making failover_soak fail sporadically.

Corresponds to trunk r955370
---
 qpid/cpp/src/qpid/cluster/Cluster.cpp           |    3 +-
 qpid/cpp/src/qpid/cluster/Connection.cpp        |   47 +++++++++++++---------
 qpid/cpp/src/qpid/cluster/Connection.h          |    5 ++-
 qpid/cpp/src/qpid/cluster/OutputInterceptor.cpp |    2 +-
 qpid/cpp/src/qpid/cluster/UpdateClient.cpp      |   22 ++++++----
 qpid/cpp/src/tests/failover_soak.cpp            |   12 +++--
 6 files changed, 54 insertions(+), 37 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/Cluster.cpp b/qpid/cpp/src/qpid/cluster/Cluster.cpp
index 6b9fcec..bc47e0b 100644
--- a/qpid/cpp/src/qpid/cluster/Cluster.cpp
+++ b/qpid/cpp/src/qpid/cluster/Cluster.cpp
@@ -361,7 +361,6 @@ void Cluster::erase(const ConnectionId& id) {
 
 // Called by Connection::deliverClose() in deliverFrameQueue thread.
 void Cluster::erase(const ConnectionId& id, Lock&) {
-    QPID_LOG(info, *this << " connection closed " << id);
     connections.erase(id);
     decoder.erase(id);
 }
@@ -1022,7 +1021,7 @@ void Cluster::memberUpdate(Lock& l) {
         ConnectionMap::iterator j = i++;
         MemberId m = j->second->getId().getMember();
         if (m != self && !map.isMember(m)) {
-            j->second->getBrokerConnection().closed();
+            j->second->close();
             erase(j->second->getId(), l);
         }
     }
diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index c402415..a2d1cc8 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -101,19 +101,18 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
     if (isLocalClient()) {
         // Local clients are announced to the cluster
         // and initialized when the announce is received.
-        QPID_LOG(info, "new client connection " << *this);
         giveReadCredit(cluster.getSettings().readMax); // Flow control
         init();
     }
     else {
         // Catch-up shadow connections initialized using nextShadow id.
         assert(catchUp);
-        QPID_LOG(info, "new catch-up connection " << *this);
-        connectionCtor.mgmtId = updateIn.nextShadowMgmtId;
+        if (!updateIn.nextShadowMgmtId.empty())
+            connectionCtor.mgmtId = updateIn.nextShadowMgmtId;
         updateIn.nextShadowMgmtId.clear();
         init();
     }
-
+    QPID_LOG(info, "incoming connection " << *this);
 }
 
 void Connection::setSecureConnection(broker::SecureConnection* sc) {
@@ -123,8 +122,6 @@ void Connection::setSecureConnection(broker::SecureConnection* sc) {
 
 void Connection::init() {
     connection = connectionCtor.construct();
-    QPID_LOG(debug, cluster << " initialized connection: " << *this
-             << " ssf=" << connection->getExternalSecuritySettings().ssf);
     if (isLocalClient()) {
         if (secureConnection) connection->setSecureConnection(secureConnection);
         // Actively send cluster-order frames from local node
@@ -171,7 +168,6 @@ void Connection::announce(
 
 Connection::~Connection() {
     if (connection.get()) connection->setErrorListener(0);
-    QPID_LOG(debug, cluster << " deleted connection: " << *this);
 }
 
 bool Connection::doOutput() {
@@ -250,16 +246,15 @@ void Connection::deliveredFrame(const EventFrame& f) {
 // A local connection is closed by the network layer.
 void Connection::closed() {
     try {
-        if (catchUp) {
+        if (isUpdated()) {
+            QPID_LOG(debug, cluster << " update connection closed " << *this);
+            close();
+        }
+        else if (catchUp) {
             QPID_LOG(critical, cluster << " catch-up connection closed prematurely " << *this);
             cluster.leave();
         }
-        else if (isUpdated()) {
-            QPID_LOG(debug, cluster << " closed update connection " << *this);
-            if (connection.get()) connection->closed();
-        }
         else if (isLocal()) {
-            QPID_LOG(debug, cluster << " local close of replicated connection " << *this);
             // This was a local replicated connection. Multicast a deliver
             // closed and process any outstanding frames from the cluster
             // until self-delivery of deliver-close.
@@ -275,15 +270,20 @@ void Connection::closed() {
 // Self-delivery of close message, close the connection.
 void Connection::deliverClose () {
     assert(!catchUp);
+    close();
+    cluster.erase(self);
+}
+
+// Close the connection
+void Connection::close() {
     if (connection.get()) {
         connection->closed();
         // Ensure we delete the broker::Connection in the deliver thread.
         connection.reset();
     }
-    cluster.erase(self);
 }
 
-// The connection has been killed for misbehaving
+// The connection has been killed for misbehaving, called in connection thread.
 void Connection::abort() {
     if (connection.get()) {
         connection->abort();
@@ -424,7 +424,7 @@ void Connection::shadowReady(
     uint64_t memberId, uint64_t connectionId, const string& mgmtId,
     const string& username, const string& fragment, uint32_t sendMax)
 {
-    QPID_ASSERT(mgmtId == getBrokerConnection().getMgmtId());
+    QPID_ASSERT(mgmtId == getBrokerConnection()->getMgmtId());
     ConnectionId shadowId = ConnectionId(memberId, connectionId);
     QPID_LOG(debug, cluster << " catch-up connection " << *this
              << " becomes shadow " << shadowId);
@@ -442,13 +442,19 @@ void Connection::membership(const FieldTable& joiners, const FieldTable& members
     QPID_LOG(debug, cluster << " incoming update complete on connection " << *this);
     cluster.updateInDone(ClusterMap(joiners, members, frameSeq));
     updateIn.consumerNumbering.clear();
-    self.second = 0;        // Mark this as completed update connection.
+    closeUpdated();
 }
 
 void Connection::retractOffer() {
     QPID_LOG(info, cluster << " incoming update retracted on connection " << *this);
     cluster.updateInRetracted();
-    self.second = 0;        // Mark this as completed update connection.
+    closeUpdated();
+}
+
+void Connection::closeUpdated() {
+    self.second = 0;      // Mark this as completed update connection.
+    if (connection.get())
+        connection->close(connection::CLOSE_CODE_NORMAL, "OK");
 }
 
 bool Connection::isLocal() const {
@@ -527,7 +533,10 @@ std::ostream& operator<<(std::ostream& o, const Connection& c) {
     if (c.isLocal()) type = "local";
     else if (c.isShadow()) type = "shadow";
     else if (c.isUpdated()) type = "updated";
-    return o << c.getId() << "(" << type << (c.isCatchUp() ? ",catchup" : "") << ")";
+    const broker::Connection* bc = c.getBrokerConnection();
+    if (bc) o << bc->getMgmtId();
+    else o << "<disconnected>";
+    return o << "(" << c.getId() << " " << type << (c.isCatchUp() ? ",catchup":"") << ")";
 }
 
 void Connection::txStart() {
diff --git a/qpid/cpp/src/qpid/cluster/Connection.h b/qpid/cpp/src/qpid/cluster/Connection.h
index 70c4d0e..45d832a 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.h
+++ b/qpid/cpp/src/qpid/cluster/Connection.h
@@ -75,7 +75,8 @@ class Connection :
     ~Connection();
     
     ConnectionId getId() const { return self; }
-    broker::Connection& getBrokerConnection() { return *connection; }
+    broker::Connection* getBrokerConnection() { return connection.get(); }
+    const broker::Connection* getBrokerConnection() const { return connection.get(); }
 
     /** Local connections may be clients or catch-up connections */
     bool isLocal() const;
@@ -167,6 +168,7 @@ class Connection :
     void announce(const std::string& mgmtId, uint32_t ssf, const std::string& authid,
                   bool nodict, const std::string& username,
                   const std::string& initFrames);
+    void close();
     void abort();
     void deliverClose();
 
@@ -227,6 +229,7 @@ class Connection :
     broker::SessionState& sessionState();
     broker::SemanticState& semanticState();
     broker::QueuedMessage getUpdateMessage();
+    void closeUpdated();
 
     Cluster& cluster;
     ConnectionId self;
diff --git a/qpid/cpp/src/qpid/cluster/OutputInterceptor.cpp b/qpid/cpp/src/qpid/cluster/OutputInterceptor.cpp
index f80eb9c..1354dab 100644
--- a/qpid/cpp/src/qpid/cluster/OutputInterceptor.cpp
+++ b/qpid/cpp/src/qpid/cluster/OutputInterceptor.cpp
@@ -83,7 +83,7 @@ void OutputInterceptor::deliverDoOutput(uint32_t limit) {
             newLimit = (sendMax + sent) / 2;
     }
     sent = 0;
-    while (sent < limit && parent.getBrokerConnection().doOutput())
+    while (sent < limit && parent.getBrokerConnection()->doOutput())
         ++sent;
     if (sent == limit) sendDoOutput(newLimit);
 }
diff --git a/qpid/cpp/src/qpid/cluster/UpdateClient.cpp b/qpid/cpp/src/qpid/cluster/UpdateClient.cpp
index 6499519..90f5bcf 100644
--- a/qpid/cpp/src/qpid/cluster/UpdateClient.cpp
+++ b/qpid/cpp/src/qpid/cluster/UpdateClient.cpp
@@ -150,7 +150,8 @@ void UpdateClient::update() {
     // longer on their original queue.
     session.queueDeclare(arg::queue=UPDATE, arg::autoDelete=true);
     session.sync();
-    std::for_each(connections.begin(), connections.end(), boost::bind(&UpdateClient::updateConnection, this, _1));
+    std::for_each(connections.begin(), connections.end(),
+                  boost::bind(&UpdateClient::updateConnection, this, _1));
     session.queueDelete(arg::queue=UPDATE);
     session.close();
 
@@ -167,15 +168,18 @@ void UpdateClient::update() {
     client::ConnectionAccess::getImpl(connection)->expand(frame.encodedSize(), false);
     client::ConnectionAccess::getImpl(connection)->handle(frame);
 
-    connection.close();
-    QPID_LOG(debug,  updaterId << " update completed to " << updateeId
-             << " at " << updateeUrl << ": " << membership);
+    // FIXME aconway 2010-06-16: Connection will be closed from the other end.
+    // connection.close();
+
     // FIXME aconway 2010-03-15: This sleep avoids the race condition
     // described in // https://bugzilla.redhat.com/show_bug.cgi?id=568831.
     // It allows the connection to fully close before destroying the
     // Connection object. Remove when the bug is fixed.
     //
-    sys::usleep(10*1000);       // 100ms
+    sys::usleep(10*1000);
+
+    QPID_LOG(debug,  updaterId << " update completed to " << updateeId
+             << " at " << updateeUrl << ": " << membership);
 }
 
 namespace {
@@ -347,9 +351,11 @@ void UpdateClient::updateOutputTask(const sys::OutputTask* task) {
 
 void UpdateClient::updateConnection(const boost::intrusive_ptr<Connection>& updateConnection) {
     QPID_LOG(debug, updaterId << " updating connection " << *updateConnection);
+    assert(updateConnection->getBrokerConnection());
+    broker::Connection& bc = *updateConnection->getBrokerConnection();
 
     // Send the management ID first on the main connection.
-    std::string mgmtId = updateConnection->getBrokerConnection().getMgmtId();
+    std::string mgmtId = updateConnection->getBrokerConnection()->getMgmtId();
     ClusterConnectionProxy(session).shadowPrepare(mgmtId);
     // Make sure its received before opening shadow connection
     session.sync();
@@ -357,7 +363,6 @@ void UpdateClient::updateConnection(const boost::intrusive_ptr<Connection>& upda
     // Open shadow connection and update it.
     shadowConnection = catchUpConnection();
 
-    broker::Connection& bc = updateConnection->getBrokerConnection();
     connectionSettings.maxFrameSize = bc.getFrameMax();
     shadowConnection.open(updateeUrl, connectionSettings);
     bc.eachSessionHandler(boost::bind(&UpdateClient::updateSession, this, _1));
@@ -381,8 +386,7 @@ void UpdateClient::updateSession(broker::SessionHandler& sh) {
     broker::SessionState* ss = sh.getSession();
     if (!ss) return;            // no session.
 
-    QPID_LOG(debug, updaterId << " updating session " << &sh.getConnection()
-             << "[" << sh.getChannel() << "] = " << ss->getId());
+    QPID_LOG(debug, updaterId << " updating session " << ss->getId());
 
     // Create a client session to update session state. 
     boost::shared_ptr<client::ConnectionImpl> cimpl = client::ConnectionAccess::getImpl(shadowConnection);
diff --git a/qpid/cpp/src/tests/failover_soak.cpp b/qpid/cpp/src/tests/failover_soak.cpp
index cd7aaa6..058f59e 100644
--- a/qpid/cpp/src/tests/failover_soak.cpp
+++ b/qpid/cpp/src/tests/failover_soak.cpp
@@ -464,11 +464,12 @@ runDeclareQueuesClient ( brokerVector brokers,
              << endl;
     stringstream portSs;
     portSs << port;
+    string portS(portSs.str());
 
     vector<const char*> argv;
     argv.push_back ( "declareQueues" );
     argv.push_back ( host );
-    argv.push_back ( portSs.str().c_str() );
+    argv.push_back ( portS.c_str() );
     if ( durable )
       argv.push_back ( "1" );
     else
@@ -672,7 +673,7 @@ main ( int argc, char const ** argv )
      // Get prefix for each queue name.
      stringstream queue_prefix;
      queue_prefix << "failover_soak_" << getpid();
-
+     string queue_prefix_str(queue_prefix.str());
 
      // Run the declareQueues child.
      int childStatus;
@@ -682,7 +683,7 @@ main ( int argc, char const ** argv )
                               declareQueuesPath, 
                               verbosity, 
                               durable,
-                              queue_prefix.str().c_str(),
+                              queue_prefix_str.c_str(),
                               n_queues
                             );
      if ( -1 == dqClientPid ) {
@@ -706,6 +707,7 @@ main ( int argc, char const ** argv )
 
          stringstream queue_name;
          queue_name << queue_prefix.str() << '_' << i;
+         string queue_name_str(queue_name.str());
 
          // Receiving client ---------------------------
          pid_t receivingClientPid =
@@ -714,7 +716,7 @@ main ( int argc, char const ** argv )
                                   receiverPath,
                                   reportFrequency,
                                   verbosity,
-                                  queue_name.str().c_str() );
+                                  queue_name_str.c_str() );
          if ( -1 == receivingClientPid ) {
              cerr << "END_OF_TEST ERROR_START_RECEIVER\n";
              return CANT_FORK_RECEIVER;
@@ -730,7 +732,7 @@ main ( int argc, char const ** argv )
                                 reportFrequency,
                                 verbosity,
                                 durable,
-                                queue_name.str().c_str() );
+                                queue_name_str.c_str() );
          if ( -1 == sendingClientPid ) {
              cerr << "END_OF_TEST ERROR_START_SENDER\n";
              return CANT_FORK_SENDER;
-- 
1.5.5.6

From e1c3a645453c2796b67625a1e00341894777f223 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Wed, 16 Jun 2010 22:15:14 +0000
Subject: [PATCH] BZ-574817 don't always set the sync bit on send

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@955414 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py    |   14 ++++++++++----
 qpid/python/qpid/messaging/endpoints.py |   25 +++++++++++++++++++++----
 2 files changed, 31 insertions(+), 8 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index 16f1b29..a6170c0 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -114,6 +114,7 @@ class SessionState:
     self.min_completion = self.sent
     self.max_completion = self.sent
     self.results = {}
+    self.need_sync = False
 
     # receiver state
     self.received = None
@@ -131,12 +132,12 @@ class SessionState:
     for k, v in overrides.items():
       cmd[k.replace('-', '_')] = v
 
-  def write_cmd(self, cmd, action=noop, overrides=None):
+  def write_cmd(self, cmd, action=noop, overrides=None, sync=True):
     if overrides:
       self.apply_overrides(cmd, overrides)
 
-    if action != noop:
-      cmd.sync = True
+    if sync or action != noop:
+      cmd.sync = sync
     if self.detached:
       raise Exception("detached")
     cmd.id = self.sent
@@ -144,6 +145,7 @@ class SessionState:
     self.actions[cmd.id] = action
     self.max_completion = cmd.id
     self.write_op(cmd)
+    self.need_sync = not cmd.sync
 
   def write_cmds(self, cmds, action=noop):
     if cmds:
@@ -963,6 +965,10 @@ class Engine:
       else:
         break
 
+    for snd in ssn.senders:
+      if snd.synced >= snd.queued and sst.need_sync:
+        sst.write_cmd(ExecutionSync(), sync=True)
+
     for rcv in ssn.receivers:
       self.process_receiver(rcv)
 
@@ -1167,7 +1173,7 @@ class Engine:
       log.debug("RACK[%s]: %s", sst.session.log_id, msg)
       assert msg == m
     sst.write_cmd(MessageTransfer(destination=_snd._exchange, headers=(dp, mp),
-                                  payload=body), msg_acked)
+                                  payload=body), msg_acked, sync=msg._sync)
     log.debug("SENT[%s]: %s", sst.session.log_id, msg)
 
   def do_message_transfer(self, xfr):
diff --git a/qpid/python/qpid/messaging/endpoints.py b/qpid/python/qpid/messaging/endpoints.py
index 707aee3..58a654e 100644
--- a/qpid/python/qpid/messaging/endpoints.py
+++ b/qpid/python/qpid/messaging/endpoints.py
@@ -677,12 +677,20 @@ class Session:
     assert self.aborted
 
   @synchronized
+  def sync(self):
+    """
+    Sync the session.
+    """
+    for snd in self.senders:
+      snd.sync()
+    self._ewait(lambda: not self.outgoing and not self.acked)
+
+  @synchronized
   def close(self):
     """
     Close the session.
     """
-    # XXX: should be able to express this condition through API calls
-    self._ewait(lambda: not self.outgoing and not self.acked)
+    self.sync()
 
     for link in self.receivers + self.senders:
       link.close()
@@ -704,8 +712,10 @@ class Sender:
     self.target = target
     self.options = options
     self.capacity = options.get("capacity", UNLIMITED)
+    self.threshold = 0.5
     self.durable = options.get("durable")
     self.queued = Serial(0)
+    self.synced = Serial(0)
     self.acked = Serial(0)
     self.error = None
     self.linked = False
@@ -792,18 +802,25 @@ class Sender:
 
     # XXX: what if we send the same message to multiple senders?
     message._sender = self
+    if self.capacity is not UNLIMITED:
+      message._sync = sync or self.available() <= int(ceil(self.threshold*self.capacity))
+    else:
+      message._sync = sync
     self.session.outgoing.append(message)
     self.queued += 1
 
-    self._wakeup()
-
     if sync:
       self.sync()
       assert message not in self.session.outgoing
+    else:
+      self._wakeup()
 
   @synchronized
   def sync(self):
     mno = self.queued
+    if self.synced < mno:
+      self.synced = mno
+      self._wakeup()
     self._ewait(lambda: self.acked >= mno)
 
   @synchronized
-- 
1.5.5.6

From df73fc4c6a53f8b266fb88af60ea68df03057668 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Thu, 17 Jun 2010 02:18:24 +0000
Subject: [PATCH] BZ-604836 reset reconnect delay after successful connect

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@955462 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index a6170c0..7f04903 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -480,6 +480,7 @@ class Driver:
       self._timeout = None
       self._attempts = 0
       self._host = 0
+      self._delay = self.connection.reconnect_interval_min
       self._retrying = False
     except socket.error, e:
       self._host = (self._host + 1) % len(self._hosts)
-- 
1.5.5.6

From a7229e8f44b08aed075be8a5da16187017314735 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Thu, 17 Jun 2010 16:55:54 +0000
Subject: [PATCH] Allow libraries to be independently versioned in the autotools build.

Each library libfoo or plugin foo has a variable FOO_VERSION_INFO with
a value passed as -version-info to libtool.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@955672 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/configure.ac       |    7 -------
 qpid/cpp/src/Makefile.am    |   27 ++++++++++++++++++++-------
 qpid/cpp/src/acl.mk         |    4 +++-
 qpid/cpp/src/cluster.mk     |    6 ++++--
 qpid/cpp/src/qmf.mk         |   20 ++++----------------
 qpid/cpp/src/qmfc.mk        |    3 +++
 qpid/cpp/src/replication.mk |   11 +++++++++--
 qpid/cpp/src/ssl.mk         |   10 ++++++----
 qpid/cpp/src/xml.mk         |    4 +++-
 9 files changed, 52 insertions(+), 40 deletions(-)

diff --git a/qpid/cpp/configure.ac b/qpid/cpp/configure.ac
index 4eec5f1..37c0c0a 100644
--- a/qpid/cpp/configure.ac
+++ b/qpid/cpp/configure.ac
@@ -114,13 +114,6 @@ gl_saved_libs=$LIBS
   AC_SUBST([LIB_DLOPEN])
 LIBS=$gl_saved_libs
 
-# Set the argument to be used in "libtool -version-info ARG".
-QPID_CURRENT=2
-QPID_REVISION=0
-QPID_AGE=0
-LIBTOOL_VERSION_INFO_ARG=$QPID_CURRENT:$QPID_REVISION:$QPID_AGE
-AC_SUBST(LIBTOOL_VERSION_INFO_ARG)
-
 gl_CLOCK_TIME
 
 # Enable Valgrind	
diff --git a/qpid/cpp/src/Makefile.am b/qpid/cpp/src/Makefile.am
index 2df445e..6a65c15 100644
--- a/qpid/cpp/src/Makefile.am
+++ b/qpid/cpp/src/Makefile.am
@@ -107,7 +107,6 @@ include $(srcdir)/managementgen.mk
 
 ## Compiler flags
 AM_CXXFLAGS = $(WARNING_CFLAGS)
-AM_LDFLAGS = -version-info $(LIBTOOL_VERSION_INFO_ARG)
 INCLUDES = -I$(top_srcdir)/include -I$(top_builddir)/include -I$(srcdir) -I=$(builddir)
 
 #
@@ -224,8 +223,8 @@ librdmawrap_la_CXXFLAGS = \
   $(AM_CXXFLAGS) -Wno-missing-field-initializers
 lib_LTLIBRARIES += \
   librdmawrap.la
-librdmawrap_la_LDFLAGS = \
-  -no-undefined
+RDMAWRAP_VERSION_INFO  = 2:0:0
+librdmawrap_la_LDFLAGS = -version-info $(RDMAWRAP_VERSION_INFO) -no-undefined
 
 rdma_la_SOURCES = \
   qpid/sys/RdmaIOPlugin.cpp
@@ -233,7 +232,8 @@ rdma_la_LIBADD = \
   libqpidbroker.la \
   librdmawrap.la \
   -libverbs
-rdma_la_LDFLAGS = $(PLUGINLDFLAGS)
+RDMA_VERSION_INFO  = 2:0:0
+rdma_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(RDMA_VERSION_INFO)
 rdma_la_CXXFLAGS = \
   $(AM_CXXFLAGS) -Wno-missing-field-initializers
 dmodule_LTLIBRARIES += \
@@ -245,7 +245,8 @@ rdmaconnector_la_LIBADD = \
   libqpidclient.la \
   librdmawrap.la \
   -libverbs
-rdmaconnector_la_LDFLAGS = $(PLUGINLDFLAGS)
+RDMACONNECTOR_VERSION_INFO = 2:0:0
+rdmaconnector_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(RDMACONNECTOR_VERSION_INFO)
 rdmaconnector_la_CXXFLAGS = \
   $(AM_CXXFLAGS) -Wno-missing-field-initializers
 cmodule_LTLIBRARIES += \
@@ -268,8 +269,6 @@ if SSL
 include ssl.mk
 endif
 
-# New 0-10 codec, to be integrated in future.
-# libqpidamqp_0_10_la_SOURCES= 
 EXTRA_DIST +=\
   CMakeLists.txt \
   cluster.cmake \
@@ -491,6 +490,9 @@ libqpidcommon_la_SOURCES += qpid/sys/cyrus/CyrusSecurityLayer.cpp
 libqpidcommon_la_LIBADD += -lsasl2
 endif
 
+QPIDCOMMON_VERSION_INFO = 2:0:0
+libqpidcommon_la_LDFLAGS=-version-info $(QPIDCOMMON_VERSION_INFO)
+
 libqpidbroker_la_LIBADD = libqpidcommon.la -luuid
 
 libqpidbroker_la_SOURCES = \
@@ -648,6 +650,9 @@ libqpidbroker_la_SOURCES = \
   qpid/management/ManagementTopicExchange.h \
   qpid/sys/TCPIOPlugin.cpp
 
+# Library Version Information:
+QPIDBROKER_VERSION_INFO = 2:0:0
+libqpidbroker_la_LDFLAGS = -version-info $(QPIDBROKER_VERSION_INFO)
 
 libqpidclient_la_LIBADD = libqpidcommon.la  -luuid
 
@@ -709,6 +714,10 @@ libqpidclient_la_SOURCES =			\
   qpid/client/TCPConnector.cpp			\
   qpid/client/TCPConnector.h
 
+# Library Version Information:
+QPIDCLIENT_VERSION_INFO  = 2:0:0
+libqpidclient_la_LDFLAGS = -version-info $(QPIDCLIENT_VERSION_INFO)
+
 libqpidmessaging_la_LIBADD = libqpidclient.la
 
 libqpidmessaging_la_SOURCES =			\
@@ -751,6 +760,10 @@ libqpidmessaging_la_SOURCES =			\
   qpid/client/amqp0_10/SimpleUrlParser.h	\
   qpid/client/amqp0_10/SimpleUrlParser.cpp
 
+# Library Version Information:
+QPIDMESSAGING_VERSION_INFO  = 2:0:0
+libqpidmessaging_la_LDFLAGS = -version-info $(QPIDMESSAGING_VERSION_INFO)
+
 # NOTE: only public header files (which should be in ../include)
 # should go in this list. Private headers should go in the SOURCES
 # list for one of the libraries or executables that includes it.
diff --git a/qpid/cpp/src/acl.mk b/qpid/cpp/src/acl.mk
index cedac7d..0450905 100644
--- a/qpid/cpp/src/acl.mk
+++ b/qpid/cpp/src/acl.mk
@@ -37,4 +37,6 @@ if SUNOS
   acl_la_LIBADD +=  libqmfagent.la libqmfconsole.la libqpidcommon.la -lboost_program_options $(SUNCC_RUNTIME_LIBS)
 endif
 
-acl_la_LDFLAGS = $(PLUGINLDFLAGS)
+ACL_VERSION_INFO  = 2:0:0
+acl_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(ACL_VERSION_INFO)
+
diff --git a/qpid/cpp/src/cluster.mk b/qpid/cpp/src/cluster.mk
index 2a648e9..2e4942d 100644
--- a/qpid/cpp/src/cluster.mk
+++ b/qpid/cpp/src/cluster.mk
@@ -97,13 +97,15 @@ cluster_la_SOURCES =				\
 
 cluster_la_LIBADD=  -lcpg $(libcman) libqpidbroker.la libqpidclient.la
 cluster_la_CXXFLAGS = $(AM_CXXFLAGS) -fno-strict-aliasing
-cluster_la_LDFLAGS = $(PLUGINLDFLAGS)
+CLUSTER_VERSION_INFO = 2:0:0
+cluster_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(CLUSTER_VERSION_INFO)
 
 # The watchdog plugin and helper executable
 dmodule_LTLIBRARIES += watchdog.la
 watchdog_la_SOURCES = qpid/cluster/WatchDogPlugin.cpp
 watchdog_la_LIBADD = libqpidbroker.la
-watchdog_la_LDFLAGS = $(PLUGINLDFLAGS)
+WATCHDOG_VERSION_INFO  = 2:0:0
+watchdog_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(WATCHDOG_VERSION_INFO)
 
 qpidexec_PROGRAMS += qpidd_watchdog
 qpidd_watchdog_SOURCES = qpid/cluster/qpidd_watchdog.cpp
diff --git a/qpid/cpp/src/qmf.mk b/qpid/cpp/src/qmf.mk
index 1e4c59b..93f1817 100644
--- a/qpid/cpp/src/qmf.mk
+++ b/qpid/cpp/src/qmf.mk
@@ -96,20 +96,8 @@ libqmfengine_la_SOURCES =			\
 libqmf_la_LIBADD = libqmfengine.la
 libqmfengine_la_LIBADD = libqpidclient.la
 
-# Library Version Information:
-#
-#  CURRENT  => API/ABI version.  Bump this if the interface changes
-#  REVISION => Version of underlying implementation.
-#              Bump if implementation changes but API/ABI doesn't
-#  AGE      => Number of API/ABI versions this is backward compatible with
-#
-QMF_CURRENT  = 1
-QMF_REVISION = 0
-QMF_AGE      = 0
-
-QMF_ENGINE_CURRENT  = 1
-QMF_ENGINE_REVISION = 1
-QMF_ENGINE_AGE      = 0
+QMF_VERSION_INFO = 1:0:0
+QMFENGINE_VERSION_INFO  = 1:1:0
 
-libqmf_la_LDFLAGS = -version-info $(QMF_CURRENT):$(QMF_REVISION):$(QMF_AGE)
-libqmfengine_la_LDFLAGS = -version-info $(QMF_ENGINE_CURRENT):$(QMF_ENGINE_REVISION):$(QMF_ENGINE_AGE)
+libqmf_la_LDFLAGS = -version-info $(QMF_VERSION_INFO)
+libqmfengine_la_LDFLAGS = -version-info $(QMFENGINE_VERSION_INFO)
diff --git a/qpid/cpp/src/qmfc.mk b/qpid/cpp/src/qmfc.mk
index f3e6dc2..9e8078f 100644
--- a/qpid/cpp/src/qmfc.mk
+++ b/qpid/cpp/src/qmfc.mk
@@ -53,3 +53,6 @@ libqmfconsole_la_SOURCES =			\
 
 libqmfconsole_la_LIBADD = libqpidclient.la
 
+# Library Version Information:
+QMFCONSOLE_VERSION_INFO  = 2:0:0
+libqmfconsole_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(QMFCONSOLE_VERSION_INFO)
diff --git a/qpid/cpp/src/replication.mk b/qpid/cpp/src/replication.mk
index 4a51fb9..e27920d 100644
--- a/qpid/cpp/src/replication.mk
+++ b/qpid/cpp/src/replication.mk
@@ -33,7 +33,10 @@ if SUNOS
   replicating_listener_la_LIBADD += libqpidcommon.la -lboost_program_options -luuid $(SUNCC_RUNTIME_LIBS)
 endif
 
-replicating_listener_la_LDFLAGS = $(PLUGINLDFLAGS)
+# Library Version Information:
+REPLICATING_LISTENER_VERSION_INFO = 2:0:0
+replicating_listener_la_LDFLAGS = $(PLUGINLDFLAGS) \
+  -version-info $(REPLICATING_LISTENER_VERSION_INFO)
 
 # a custom exchange plugin that allows an exchange to be created that
 # can process the messages from a replication queue (populated on the
@@ -49,4 +52,8 @@ replication_exchange_la_LIBADD = libqpidbroker.la
 if SUNOS
   replication_exchange_la_LIBADD += libqpidcommon.la -lboost_program_options $(SUNCC_RUNTIME_LIBS) -luuid
 endif
-replication_exchange_la_LDFLAGS = $(PLUGINLDFLAGS)
+# Library Version Information:
+REPLICATION_EXCHANGE_VERSION_INFO  = 2:0:0
+replication_exchange_la_LDFLAGS = $(PLUGINLDFLAGS) \
+  -version-info $(REPLICATION_EXCHANGE_VERSION_INFO)
+
diff --git a/qpid/cpp/src/ssl.mk b/qpid/cpp/src/ssl.mk
index f7fba7b..40cb9d0 100644
--- a/qpid/cpp/src/ssl.mk
+++ b/qpid/cpp/src/ssl.mk
@@ -29,8 +29,9 @@ libsslcommon_la_SOURCES = \
   qpid/sys/ssl/SslIo.h \
   qpid/sys/ssl/SslIo.cpp
 
+SSLCOMMON_VERSION_INFO  = 2:0:0
+libsslcommon_la_LDFLAGS = -version-info $(SSLCOMMON_VERSION_INFO)
 libsslcommon_la_LIBADD= -lnss3 -lssl3 -lnspr4 libqpidcommon.la
-
 libsslcommon_la_CXXFLAGS=$(AM_CXXFLAGS) $(SSL_CFLAGS)
 
 lib_LTLIBRARIES +=  libsslcommon.la
@@ -44,11 +45,11 @@ ssl_la_LIBADD= libqpidbroker.la libsslcommon.la
 
 ssl_la_CXXFLAGS=$(AM_CXXFLAGS) $(SSL_CFLAGS)
 
-ssl_la_LDFLAGS = $(PLUGINLDFLAGS)
+SSL_VERSION_INFO  = 2:0:0
+ssl_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(SSL_VERSION_INFO)
 
 dmodule_LTLIBRARIES += ssl.la
 
-
 sslconnector_la_SOURCES = \
   qpid/client/SslConnector.cpp
 
@@ -58,7 +59,8 @@ sslconnector_la_LIBADD = \
 
 sslconnector_la_CXXFLAGS = $(AM_CXXFLAGS) -DQPIDC_CONF_FILE=\"$(confdir)/qpidc.conf\"  $(SSL_CFLAGS)
 
-sslconnector_la_LDFLAGS = $(PLUGINLDFLAGS)
+SSLCONNECTOR_VERSION_INFO  = 2:0:0
+sslconnector_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(SSLCONNECTOR_VERSION_INFO)
 
 cmodule_LTLIBRARIES += \
   sslconnector.la
diff --git a/qpid/cpp/src/xml.mk b/qpid/cpp/src/xml.mk
index 957a18e..2372202 100644
--- a/qpid/cpp/src/xml.mk
+++ b/qpid/cpp/src/xml.mk
@@ -25,4 +25,6 @@ xml_la_SOURCES =  \
 
 xml_la_LIBADD = -lxerces-c -lxqilla libqpidbroker.la
 
-xml_la_LDFLAGS = $(PLUGINLDFLAGS)
+XML_VERSION_INFO = 2:0:0
+xml_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(XML_VERSION_INFO)
+
-- 
1.5.5.6

From 6df566bff554a1c95637a8e32398462ee3e1d9ee Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Fri, 18 Jun 2010 13:40:04 +0000
Subject: [PATCH] Fix version info

- no version info for modules
- no $(PLUGINLDFLAGS)  on libqmfconsole, typo in previous merge.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@956001 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 882656ef4d0d8a26804fbb5a2ced3dcad433dc3b)
---
 qpid/cpp/src/Makefile.am    |    9 ++-------
 qpid/cpp/src/acl.mk         |    3 +--
 qpid/cpp/src/cluster.mk     |    6 ++----
 qpid/cpp/src/qmfc.mk        |    3 +--
 qpid/cpp/src/replication.mk |   11 ++---------
 qpid/cpp/src/ssl.mk         |    6 ++----
 qpid/cpp/src/xml.mk         |    3 +--
 7 files changed, 11 insertions(+), 30 deletions(-)

diff --git a/qpid/cpp/src/Makefile.am b/qpid/cpp/src/Makefile.am
index 6a65c15..27a60e4 100644
--- a/qpid/cpp/src/Makefile.am
+++ b/qpid/cpp/src/Makefile.am
@@ -232,8 +232,7 @@ rdma_la_LIBADD = \
   libqpidbroker.la \
   librdmawrap.la \
   -libverbs
-RDMA_VERSION_INFO  = 2:0:0
-rdma_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(RDMA_VERSION_INFO)
+rdma_la_LDFLAGS = $(PLUGINLDFLAGS)
 rdma_la_CXXFLAGS = \
   $(AM_CXXFLAGS) -Wno-missing-field-initializers
 dmodule_LTLIBRARIES += \
@@ -245,8 +244,7 @@ rdmaconnector_la_LIBADD = \
   libqpidclient.la \
   librdmawrap.la \
   -libverbs
-RDMACONNECTOR_VERSION_INFO = 2:0:0
-rdmaconnector_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(RDMACONNECTOR_VERSION_INFO)
+rdmaconnector_la_LDFLAGS = $(PLUGINLDFLAGS)
 rdmaconnector_la_CXXFLAGS = \
   $(AM_CXXFLAGS) -Wno-missing-field-initializers
 cmodule_LTLIBRARIES += \
@@ -650,7 +648,6 @@ libqpidbroker_la_SOURCES = \
   qpid/management/ManagementTopicExchange.h \
   qpid/sys/TCPIOPlugin.cpp
 
-# Library Version Information:
 QPIDBROKER_VERSION_INFO = 2:0:0
 libqpidbroker_la_LDFLAGS = -version-info $(QPIDBROKER_VERSION_INFO)
 
@@ -714,7 +711,6 @@ libqpidclient_la_SOURCES =			\
   qpid/client/TCPConnector.cpp			\
   qpid/client/TCPConnector.h
 
-# Library Version Information:
 QPIDCLIENT_VERSION_INFO  = 2:0:0
 libqpidclient_la_LDFLAGS = -version-info $(QPIDCLIENT_VERSION_INFO)
 
@@ -760,7 +756,6 @@ libqpidmessaging_la_SOURCES =			\
   qpid/client/amqp0_10/SimpleUrlParser.h	\
   qpid/client/amqp0_10/SimpleUrlParser.cpp
 
-# Library Version Information:
 QPIDMESSAGING_VERSION_INFO  = 2:0:0
 libqpidmessaging_la_LDFLAGS = -version-info $(QPIDMESSAGING_VERSION_INFO)
 
diff --git a/qpid/cpp/src/acl.mk b/qpid/cpp/src/acl.mk
index 0450905..bcd1d88 100644
--- a/qpid/cpp/src/acl.mk
+++ b/qpid/cpp/src/acl.mk
@@ -37,6 +37,5 @@ if SUNOS
   acl_la_LIBADD +=  libqmfagent.la libqmfconsole.la libqpidcommon.la -lboost_program_options $(SUNCC_RUNTIME_LIBS)
 endif
 
-ACL_VERSION_INFO  = 2:0:0
-acl_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(ACL_VERSION_INFO)
+acl_la_LDFLAGS = $(PLUGINLDFLAGS)
 
diff --git a/qpid/cpp/src/cluster.mk b/qpid/cpp/src/cluster.mk
index 2e4942d..2a648e9 100644
--- a/qpid/cpp/src/cluster.mk
+++ b/qpid/cpp/src/cluster.mk
@@ -97,15 +97,13 @@ cluster_la_SOURCES =				\
 
 cluster_la_LIBADD=  -lcpg $(libcman) libqpidbroker.la libqpidclient.la
 cluster_la_CXXFLAGS = $(AM_CXXFLAGS) -fno-strict-aliasing
-CLUSTER_VERSION_INFO = 2:0:0
-cluster_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(CLUSTER_VERSION_INFO)
+cluster_la_LDFLAGS = $(PLUGINLDFLAGS)
 
 # The watchdog plugin and helper executable
 dmodule_LTLIBRARIES += watchdog.la
 watchdog_la_SOURCES = qpid/cluster/WatchDogPlugin.cpp
 watchdog_la_LIBADD = libqpidbroker.la
-WATCHDOG_VERSION_INFO  = 2:0:0
-watchdog_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(WATCHDOG_VERSION_INFO)
+watchdog_la_LDFLAGS = $(PLUGINLDFLAGS)
 
 qpidexec_PROGRAMS += qpidd_watchdog
 qpidd_watchdog_SOURCES = qpid/cluster/qpidd_watchdog.cpp
diff --git a/qpid/cpp/src/qmfc.mk b/qpid/cpp/src/qmfc.mk
index 9e8078f..b0ef68d 100644
--- a/qpid/cpp/src/qmfc.mk
+++ b/qpid/cpp/src/qmfc.mk
@@ -53,6 +53,5 @@ libqmfconsole_la_SOURCES =			\
 
 libqmfconsole_la_LIBADD = libqpidclient.la
 
-# Library Version Information:
 QMFCONSOLE_VERSION_INFO  = 2:0:0
-libqmfconsole_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(QMFCONSOLE_VERSION_INFO)
+libqmfconsole_la_LDFLAGS = -version-info $(QMFCONSOLE_VERSION_INFO)
diff --git a/qpid/cpp/src/replication.mk b/qpid/cpp/src/replication.mk
index e27920d..dbe071f 100644
--- a/qpid/cpp/src/replication.mk
+++ b/qpid/cpp/src/replication.mk
@@ -32,11 +32,7 @@ replicating_listener_la_LIBADD = libqpidbroker.la
 if SUNOS
   replicating_listener_la_LIBADD += libqpidcommon.la -lboost_program_options -luuid $(SUNCC_RUNTIME_LIBS)
 endif
-
-# Library Version Information:
-REPLICATING_LISTENER_VERSION_INFO = 2:0:0
-replicating_listener_la_LDFLAGS = $(PLUGINLDFLAGS) \
-  -version-info $(REPLICATING_LISTENER_VERSION_INFO)
+replicating_listener_la_LDFLAGS = $(PLUGINLDFLAGS)
 
 # a custom exchange plugin that allows an exchange to be created that
 # can process the messages from a replication queue (populated on the
@@ -52,8 +48,5 @@ replication_exchange_la_LIBADD = libqpidbroker.la
 if SUNOS
   replication_exchange_la_LIBADD += libqpidcommon.la -lboost_program_options $(SUNCC_RUNTIME_LIBS) -luuid
 endif
-# Library Version Information:
-REPLICATION_EXCHANGE_VERSION_INFO  = 2:0:0
-replication_exchange_la_LDFLAGS = $(PLUGINLDFLAGS) \
-  -version-info $(REPLICATION_EXCHANGE_VERSION_INFO)
+replication_exchange_la_LDFLAGS = $(PLUGINLDFLAGS)
 
diff --git a/qpid/cpp/src/ssl.mk b/qpid/cpp/src/ssl.mk
index 40cb9d0..5fbdd55 100644
--- a/qpid/cpp/src/ssl.mk
+++ b/qpid/cpp/src/ssl.mk
@@ -45,8 +45,7 @@ ssl_la_LIBADD= libqpidbroker.la libsslcommon.la
 
 ssl_la_CXXFLAGS=$(AM_CXXFLAGS) $(SSL_CFLAGS)
 
-SSL_VERSION_INFO  = 2:0:0
-ssl_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(SSL_VERSION_INFO)
+ssl_la_LDFLAGS = $(PLUGINLDFLAGS)
 
 dmodule_LTLIBRARIES += ssl.la
 
@@ -59,8 +58,7 @@ sslconnector_la_LIBADD = \
 
 sslconnector_la_CXXFLAGS = $(AM_CXXFLAGS) -DQPIDC_CONF_FILE=\"$(confdir)/qpidc.conf\"  $(SSL_CFLAGS)
 
-SSLCONNECTOR_VERSION_INFO  = 2:0:0
-sslconnector_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(SSLCONNECTOR_VERSION_INFO)
+sslconnector_la_LDFLAGS = $(PLUGINLDFLAGS)
 
 cmodule_LTLIBRARIES += \
   sslconnector.la
diff --git a/qpid/cpp/src/xml.mk b/qpid/cpp/src/xml.mk
index 2372202..0d700fc 100644
--- a/qpid/cpp/src/xml.mk
+++ b/qpid/cpp/src/xml.mk
@@ -25,6 +25,5 @@ xml_la_SOURCES =  \
 
 xml_la_LIBADD = -lxerces-c -lxqilla libqpidbroker.la
 
-XML_VERSION_INFO = 2:0:0
-xml_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(XML_VERSION_INFO)
+xml_la_LDFLAGS = $(PLUGINLDFLAGS)
 
-- 
1.5.5.6

From 0f5083fda071b089376561b6de3b89a89d0d7823 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Tue, 22 Jun 2010 13:29:52 +0000
Subject: [PATCH] Bug 605763 - Failures in long cluster_tests.test_management

Fix cluster broker crashes when management is active.

Cluser brokers were exiting with errors "modified cluster state
outside cluster context" and "confirmed < (50+0) but only sent < (49+0)"

Fix was to:
 - delay completion of incoming update till update connection closes.
 - delay addding new connections to managment until connection is announced.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@956882 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 8c6bdbf58524a38ded50903ffd457a3f1aa59fc1)
---
 qpid/cpp/src/qpid/broker/Connection.cpp          |   30 +-
 qpid/cpp/src/qpid/broker/Connection.h            |   14 +-
 qpid/cpp/src/qpid/cluster/Cluster.cpp            |   13 +-
 qpid/cpp/src/qpid/cluster/Cluster.h              |    3 +-
 qpid/cpp/src/qpid/cluster/Connection.cpp         |   45 ++-
 qpid/cpp/src/qpid/cluster/Connection.h           |   14 +-
 qpid/cpp/src/qpid/management/ManagementAgent.cpp |   21 +-
 qpid/cpp/src/qpid/sys/ClusterSafe.cpp            |   11 +-
 qpid/cpp/src/tests/cluster_tests.py              |    2 +-
 qpid/cpp/src/tests/run_long_cluster_tests        |    2 +-
 qpid/cpp/src/tests/verify_cluster_objects        |  456 ++++------------------
 qpid/cpp/xml/cluster.xml                         |    4 +-
 12 files changed, 188 insertions(+), 427 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Connection.cpp b/qpid/cpp/src/qpid/broker/Connection.cpp
index 619f1a1..bc755e3 100644
--- a/qpid/cpp/src/qpid/broker/Connection.cpp
+++ b/qpid/cpp/src/qpid/broker/Connection.cpp
@@ -76,8 +76,14 @@ struct ConnectionTimeoutTask : public sys::TimerTask {
     }
 };
 
-Connection::Connection(ConnectionOutputHandler* out_, Broker& broker_, const std::string& mgmtId_,
-                       const qpid::sys::SecuritySettings& external, bool isLink_, uint64_t objectId, bool shadow_) :
+Connection::Connection(ConnectionOutputHandler* out_,
+                       Broker& broker_, const
+                       std::string& mgmtId_,
+                       const qpid::sys::SecuritySettings& external,
+                       bool isLink_,
+                       uint64_t objectId_,
+                       bool shadow_,
+                       bool delayManagement) :
     ConnectionState(out_, broker_),
     securitySettings(external),
     adapter(*this, isLink_, shadow_),
@@ -89,26 +95,30 @@ Connection::Connection(ConnectionOutputHandler* out_, Broker& broker_, const std
     agent(0),
     timer(broker_.getTimer()),
     errorListener(0),
+    objectId(objectId_),
     shadow(shadow_)
 {
-    Manageable* parent = broker.GetVhostObject();
-
     if (isLink)
         links.notifyConnection(mgmtId, this);
+    // In a cluster, allow adding the management object to be delayed.
+    if (!delayManagement) addManagementObject();
+    if (!isShadow()) broker.getConnectionCounter().inc_connectionCount();
+}
 
-    if (parent != 0)
-    {
-        agent = broker_.getManagementAgent();
-
-        // TODO set last bool true if system connection
+void Connection::addManagementObject() {
+    assert(agent == 0);
+    assert(mgmtObject == 0);
+    Manageable* parent = broker.GetVhostObject();
+    if (parent != 0) {
+        agent = broker.getManagementAgent();
         if (agent != 0) {
+            // TODO set last bool true if system connection
             mgmtObject = new _qmf::Connection(agent, this, parent, mgmtId, !isLink, false);
             mgmtObject->set_shadow(shadow);
             agent->addObject(mgmtObject, objectId);
         }
         ConnectionState::setUrl(mgmtId);
     }
-    if (!isShadow()) broker.getConnectionCounter().inc_connectionCount();
 }
 
 void Connection::requestIOProcessing(boost::function0<void> callback)
diff --git a/qpid/cpp/src/qpid/broker/Connection.h b/qpid/cpp/src/qpid/broker/Connection.h
index cf199fa..8ad78f6 100644
--- a/qpid/cpp/src/qpid/broker/Connection.h
+++ b/qpid/cpp/src/qpid/broker/Connection.h
@@ -79,9 +79,15 @@ class Connection : public sys::ConnectionInputHandler,
         virtual void connectionError(const std::string&) = 0;
     };
 
-    Connection(sys::ConnectionOutputHandler* out, Broker& broker, const std::string& mgmtId,
+    Connection(sys::ConnectionOutputHandler* out,
+               Broker& broker,
+               const std::string& mgmtId,
                const qpid::sys::SecuritySettings&,
-               bool isLink = false, uint64_t objectId = 0, bool shadow=false);
+               bool isLink = false,
+               uint64_t objectId = 0,
+               bool shadow=false,
+               bool delayManagement = false);
+
     ~Connection ();
 
     /** Get the SessionHandler for channel. Create if it does not already exist */
@@ -139,6 +145,9 @@ class Connection : public sys::ConnectionInputHandler,
     // Used by cluster to update connection status
     sys::AggregateOutput& getOutputTasks() { return outputTasks; }
 
+    /** Cluster delays adding management object in the constructor then calls this. */
+    void addManagementObject();
+
     const qpid::sys::SecuritySettings& getExternalSecuritySettings() const
     { 
         return securitySettings;
@@ -166,6 +175,7 @@ class Connection : public sys::ConnectionInputHandler,
     boost::intrusive_ptr<sys::TimerTask> heartbeatTimer;
     boost::intrusive_ptr<ConnectionTimeoutTask> timeoutTimer;
     ErrorListener* errorListener;
+    uint64_t objectId;
     bool shadow;
 
   public:
diff --git a/qpid/cpp/src/qpid/cluster/Cluster.cpp b/qpid/cpp/src/qpid/cluster/Cluster.cpp
index bc47e0b..233cc89 100644
--- a/qpid/cpp/src/qpid/cluster/Cluster.cpp
+++ b/qpid/cpp/src/qpid/cluster/Cluster.cpp
@@ -194,7 +194,7 @@ namespace _qmf = ::qmf::org::apache::qpid::cluster;
  * Currently use SVN revision to avoid clashes with versions from
  * different branches.
  */
-const uint32_t Cluster::CLUSTER_VERSION = 904565;
+const uint32_t Cluster::CLUSTER_VERSION = 956001;
 
 struct ClusterDispatcher : public framing::AMQP_AllOperations::ClusterHandler {
     qpid::cluster::Cluster& cluster;
@@ -269,6 +269,7 @@ Cluster::Cluster(const ClusterSettings& set, broker::Broker& b) :
     lastAliveCount(0),
     lastBroker(false),
     updateRetracted(false),
+    updateClosed(false),
     error(*this)
 {
     // We give ownership of the timer to the broker and keep a plain pointer.
@@ -861,6 +862,14 @@ void Cluster::updateStart(const MemberId& updatee, const Url& url, Lock& l) {
                          connectionSettings(settings)));
 }
 
+// Called in network thread
+void Cluster::updateInClosed() {
+    Lock l(lock);
+    assert(!updateClosed);
+    updateClosed = true;
+    checkUpdateIn(l);
+}
+
 // Called in update thread.
 void Cluster::updateInDone(const ClusterMap& m) {
     Lock l(lock);
@@ -877,6 +886,7 @@ void Cluster::updateInRetracted() {
 
 void Cluster::checkUpdateIn(Lock& l) {
     if (state != UPDATEE) return; // Wait till we reach the stall point.
+    if (!updateClosed) return;  // Wait till update connection closes.
     if (updatedMap) { // We're up to date
         map = *updatedMap;
         failoverExchange->setUrls(getUrls(l));
@@ -893,6 +903,7 @@ void Cluster::checkUpdateIn(Lock& l) {
     }
     else if (updateRetracted) { // Update was retracted, request another update
         updateRetracted = false;
+        updateClosed = false;
         state = JOINER;
         QPID_LOG(notice, *this << " update retracted, sending new update request.");
         mcast.mcastControl(ClusterUpdateRequestBody(ProtocolVersion(), myUrl.str()), self);
diff --git a/qpid/cpp/src/qpid/cluster/Cluster.h b/qpid/cpp/src/qpid/cluster/Cluster.h
index 0d8b55c..84dee27 100644
--- a/qpid/cpp/src/qpid/cluster/Cluster.h
+++ b/qpid/cpp/src/qpid/cluster/Cluster.h
@@ -97,6 +97,7 @@ class Cluster : private Cpg::Handler, public management::Manageable {
     void leave();
 
     // Update completed - called in update thread
+    void updateInClosed();
     void updateInDone(const ClusterMap&);
     void updateInRetracted();
 
@@ -277,7 +278,7 @@ class Cluster : private Cpg::Handler, public management::Manageable {
     bool lastBroker;
     sys::Thread updateThread;
     boost::optional<ClusterMap> updatedMap;
-    bool updateRetracted;
+    bool updateRetracted, updateClosed;
     ErrorCheck error;
     UpdateReceiver updateReceiver;
     ClusterTimer* timer;
diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index a2d1cc8..e0c0465 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -22,7 +22,6 @@
 #include "UpdateClient.h"
 #include "Cluster.h"
 #include "UpdateReceiver.h"
-
 #include "qpid/assert.h"
 #include "qpid/broker/SessionState.h"
 #include "qpid/broker/SemanticState.h"
@@ -43,7 +42,6 @@
 #include "qpid/framing/ConnectionCloseOkBody.h"
 #include "qpid/log/Statement.h"
 #include "qpid/management/ManagementAgent.h"
-
 #include <boost/current_function.hpp>
 
 
@@ -99,10 +97,9 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
 {
     cluster.addLocalConnection(this);
     if (isLocalClient()) {
-        // Local clients are announced to the cluster
-        // and initialized when the announce is received.
         giveReadCredit(cluster.getSettings().readMax); // Flow control
-        init();
+        // Delay adding the connection to the management map until announce()
+        connectionCtor.delayManagement = true;
     }
     else {
         // Catch-up shadow connections initialized using nextShadow id.
@@ -110,9 +107,9 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
         if (!updateIn.nextShadowMgmtId.empty())
             connectionCtor.mgmtId = updateIn.nextShadowMgmtId;
         updateIn.nextShadowMgmtId.clear();
-        init();
-    }
-    QPID_LOG(info, "incoming connection " << *this);
+     }
+    init();
+    QPID_LOG(debug, cluster << " local connection " << *this);
 }
 
 void Connection::setSecureConnection(broker::SecureConnection* sc) {
@@ -152,8 +149,11 @@ void Connection::announce(
     QPID_ASSERT(ssf == connectionCtor.external.ssf);
     QPID_ASSERT(authid == connectionCtor.external.authid);
     QPID_ASSERT(nodict == connectionCtor.external.nodict);
-    // Local connections are already initialized.
-    if (isShadow()) {
+    // Local connections are already initialized but with management delayed.
+    if (isLocalClient()) {
+        connection->addManagementObject();
+    }
+    else if (isShadow()) {
         init();
         // Play initial frames into the connection.
         Buffer buf(const_cast<char*>(initialFrames.data()), initialFrames.size());
@@ -162,8 +162,9 @@ void Connection::announce(
             connection->received(frame);
          connection->setUserId(username);
     }
-    // Raise the connection management event now that the connection is replicated.
+    // Do managment actions now that the connection is replicated.
     connection->raiseConnectEvent();
+    QPID_LOG(debug, cluster << " replicated connection " << *this);
 }
 
 Connection::~Connection() {
@@ -249,6 +250,7 @@ void Connection::closed() {
         if (isUpdated()) {
             QPID_LOG(debug, cluster << " update connection closed " << *this);
             close();
+            cluster.updateInClosed();
         }
         else if (catchUp) {
             QPID_LOG(critical, cluster << " catch-up connection closed prematurely " << *this);
@@ -259,7 +261,8 @@ void Connection::closed() {
             // closed and process any outstanding frames from the cluster
             // until self-delivery of deliver-close.
             output.closeOutput();
-            cluster.getMulticast().mcastControl(ClusterConnectionDeliverCloseBody(), self);
+            cluster.getMulticast().mcastControl(
+                ClusterConnectionDeliverCloseBody(ProtocolVersion(), false), self);
         }
     }
     catch (const std::exception& e) {
@@ -268,17 +271,21 @@ void Connection::closed() {
 }
 
 // Self-delivery of close message, close the connection.
-void Connection::deliverClose () {
-    assert(!catchUp);
-    close();
+void Connection::deliverClose (bool aborted) {
+    QPID_LOG(debug, cluster << " replicated close of " << *this);
+    if (connection.get()) {
+        if (aborted) connection->abort();
+        else connection->closed();
+        connection.reset();
+    }
     cluster.erase(self);
 }
 
 // Close the connection
 void Connection::close() {
+    QPID_LOG(debug, cluster << " local close of " << *this);
     if (connection.get()) {
         connection->closed();
-        // Ensure we delete the broker::Connection in the deliver thread.
         connection.reset();
     }
 }
@@ -286,11 +293,9 @@ void Connection::close() {
 // The connection has been killed for misbehaving, called in connection thread.
 void Connection::abort() {
     if (connection.get()) {
-        connection->abort();
-        // Ensure we delete the broker::Connection in the deliver thread.
-        connection.reset();
+        cluster.getMulticast().mcastControl(
+            ClusterConnectionDeliverCloseBody(ProtocolVersion(), true), self);
     }
-    cluster.erase(self);
 }
 
 // ConnectionCodec::decode receives read buffers from  directly-connected clients.
diff --git a/qpid/cpp/src/qpid/cluster/Connection.h b/qpid/cpp/src/qpid/cluster/Connection.h
index 45d832a..72a98c1 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.h
+++ b/qpid/cpp/src/qpid/cluster/Connection.h
@@ -170,7 +170,7 @@ class Connection :
                   const std::string& initFrames);
     void close();
     void abort();
-    void deliverClose();
+    void deliverClose(bool);
 
     OutputInterceptor& getOutput() { return output; }
 
@@ -194,6 +194,7 @@ class Connection :
         bool isLink;
         uint64_t objectId;
         bool shadow;
+        bool delayManagement;
 
         ConnectionCtor(
             sys::ConnectionOutputHandler* out_,
@@ -202,14 +203,19 @@ class Connection :
             const qpid::sys::SecuritySettings& external_,
             bool isLink_=false,
             uint64_t objectId_=0,
-            bool shadow_=false
+            bool shadow_=false,
+            bool delayManagement_=false
         ) : out(out_), broker(broker_), mgmtId(mgmtId_), external(external_),
-            isLink(isLink_), objectId(objectId_), shadow(shadow_)
+            isLink(isLink_), objectId(objectId_), shadow(shadow_),
+            delayManagement(delayManagement_)
         {}
 
         std::auto_ptr<broker::Connection> construct() {
             return std::auto_ptr<broker::Connection>(
-                new broker::Connection(out, broker, mgmtId, external, isLink, objectId, shadow));
+                new broker::Connection(
+                    out, broker, mgmtId, external, isLink, objectId,
+                    shadow, delayManagement)
+            );
         }
     };
 
diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.cpp b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
index b1c2780..8818a4c 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.cpp
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
@@ -2321,6 +2321,23 @@ void ManagementAgent::importAgents(qpid::framing::Buffer& inBuf) {
     }
 }
 
+namespace {
+bool isNotDeleted(const ManagementObjectMap::value_type& value) {
+    return !value.second->isDeleted();
+}
+
+size_t countNotDeleted(const ManagementObjectMap& map) {
+    return std::count_if(map.begin(), map.end(), isNotDeleted);
+}
+
+void dumpMap(std::ostream& o, const ManagementObjectMap& map) {
+    for (ManagementObjectMap::const_iterator i = map.begin(); i != map.end(); ++i) {
+        if (!i->second->isDeleted())
+            o << endl << "   " << i->second->getObjectId().getV2Key();
+    }
+}
+} // namespace
+
 string ManagementAgent::debugSnapshot() {
     ostringstream msg;
     msg << " management snapshot:";
@@ -2328,8 +2345,8 @@ string ManagementAgent::debugSnapshot() {
          i != remoteAgents.end(); ++i)
         msg << " " << i->second->routingKey;
     msg << " packages: " << packages.size();
-    msg << " objects: " << managementObjects.size();
-    msg << " new objects: " << newManagementObjects.size();
+    msg << " objects: " << countNotDeleted(managementObjects);
+    msg << " new objects: " << countNotDeleted(newManagementObjects);
     return msg.str();
 }
 
diff --git a/qpid/cpp/src/qpid/sys/ClusterSafe.cpp b/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
index e051591..6105fc9 100644
--- a/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
+++ b/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
@@ -43,8 +43,15 @@ void assertClusterSafe()  {
     }
 }
 
-ClusterSafeScope::ClusterSafeScope() { inContext = true; }
-ClusterSafeScope::~ClusterSafeScope() { inContext = false; }
+ClusterSafeScope::ClusterSafeScope() {
+    assert(!inContext);
+    inContext = true;
+}
+
+ClusterSafeScope::~ClusterSafeScope() {
+    assert(inContext);
+    inContext = false;
+}
 
 void enableClusterSafe() { inCluster = true; }
 
diff --git a/qpid/cpp/src/tests/cluster_tests.py b/qpid/cpp/src/tests/cluster_tests.py
index 983a8bd..ebb07a1 100755
--- a/qpid/cpp/src/tests/cluster_tests.py
+++ b/qpid/cpp/src/tests/cluster_tests.py
@@ -199,7 +199,7 @@ class LongTests(BrokerTest):
                 StoppableThread.stop(self)
 
         # def test_management
-        args=["--mgmt-pub-interval", 1] # Publish management information every second.
+        args = ["--mgmt-pub-interval", 1] # Publish management information every second.
         # Use store if present.
         if BrokerTest.store_lib: args +=["--load-module", BrokerTest.store_lib]
         cluster = self.cluster(3, args)
diff --git a/qpid/cpp/src/tests/run_long_cluster_tests b/qpid/cpp/src/tests/run_long_cluster_tests
index 05c7867..5dce0be 100755
--- a/qpid/cpp/src/tests/run_long_cluster_tests
+++ b/qpid/cpp/src/tests/run_long_cluster_tests
@@ -20,5 +20,5 @@
 #
 
 srcdir=`dirname $0`
-$srcdir/run_cluster_tests 'cluster_tests.LongTests.*' -DDURATION=2
+$srcdir/run_cluster_tests 'cluster_tests.LongTests.*' -DDURATION=4
 
diff --git a/qpid/cpp/src/tests/verify_cluster_objects b/qpid/cpp/src/tests/verify_cluster_objects
index be6d67d..a96c636 100755
--- a/qpid/cpp/src/tests/verify_cluster_objects
+++ b/qpid/cpp/src/tests/verify_cluster_objects
@@ -1,6 +1,5 @@
 #!/usr/bin/env python
 
-#
 # Licensed to the Apache Software Foundation (ASF) under one
 # or more contributor license agreements.  See the NOTICE file
 # distributed with this work for additional information
@@ -19,390 +18,83 @@
 # under the License.
 #
 
-import os
-import getopt
-import sys
-import locale
-import socket
-import re
-from qmf.console import Session, SchemaClass
-
-_host = "localhost"
-_connTimeout = 10
-_verbose = 0
-_del_test = False;
-pattern = re.compile("^\\d+\\.\\d+\\.\\d+\\.\\d+:\\d+$")
-_debug_recursion = 0
-
-def Usage ():
-    print "Usage:  verify_cluster_objects [OPTIONS] [broker-addr]"
-    print
-    print "             broker-addr is in the form:   [username/password@] hostname | ip-address [:<port>]"
-    print "             ex:  localhost, 10.1.1.7:10000, broker-host:10000, guest/guest@localhost"
-    print
-    print "    This program contacts every node of a cluster, loads all manageable objects from"
-    print "    those nodes and verifies that the management data is identical across the clusters."
-    print
-    print "Options:"
-    print "    --timeout seconds (10)  Maximum time to wait for broker connection"
-    print "    --verbose level (0)     Show details of objects and their IDs"
-    print "    --delete                Delete some objects after creation, to test synchup"
-    print
-    sys.exit (1)
-
-class IpAddr:
-    def __init__(self, text):
-        if text.find("@") != -1:
-            tokens = text.split("@")
-            text = tokens[1]
-        if text.find(":") != -1:
-            tokens = text.split(":")
-            text = tokens[0]
-            self.port = int(tokens[1])
-        else:
-            self.port = 5672
-        self.dottedQuad = socket.gethostbyname(text)
-        nums = self.dottedQuad.split(".")
-        self.addr = (int(nums[0]) << 24) + (int(nums[1]) << 16) + (int(nums[2]) << 8) + int(nums[3])
-
-    def bestAddr(self, addrPortList):
-        bestDiff = 0xFFFFFFFFL
-        bestAddr = None
-        for addrPort in addrPortList:
-            diff = IpAddr(addrPort[0]).addr ^ self.addr
-            if diff < bestDiff:
-                bestDiff = diff
-                bestAddr = addrPort
-        return bestAddr
-
-class ObjectId:
-    """Object identity, use for dictionaries by object id"""
-    def __init__(self, object): self.object = object
-    def __eq__(self, other): return self.object is other.object
-    def __hash__(self): return hash(id(self.object))
-
-class Broker(object):
-    def __init__(self, qmf, broker):
-        self.broker = broker
-        self.qmf = qmf
-
-        agents = qmf.getAgents()
-        for a in agents:
-            if a.getAgentBank() == '0':
-                self.brokerAgent = a
-
-        bobj = qmf.getObjects(_class="broker", _package="org.apache.qpid.broker",
-                              _agent=self.brokerAgent)[0]
-        self.currentTime = bobj.getTimestamps()[0]
-        try:
-            self.uptime = bobj.uptime
-        except:
-            self.uptime = 0
-        self.tablesByName = {}
-        self.package = "org.apache.qpid.broker"
-        self.id_cache = {}              # Cache for getAbstractId
-
-    def getUrl(self):
-        return self.broker.getUrl()
-
-    def getData(self):
-        if _verbose > 1:
-            print "Broker:", self.broker
-
-        classList = self.qmf.getClasses(self.package)
-        for cls in classList:
-            if self.qmf.getSchema(cls).kind == SchemaClass.CLASS_KIND_TABLE:
-                self.loadTable(cls)
+# Verify managment objects are consistent in a cluster.
+# Arguments: url of one broker in the cluster.
 
+import qmf.console, sys, re
 
-    #
-    # this should be a method on an object, but is kept here for now, until
-    # we finish sorting out the treatment of names in qmfv2
-    #
-    def getAbstractId(self, object):
-      """ return a string the of the hierarchical name """
-      if (ObjectId(object) in self.id_cache): return self.id_cache[ObjectId(object)]
-      global _debug_recursion
-      result = u""
-      valstr = u""
-      _debug_recursion += 1
-      debug_prefix = _debug_recursion
-      if (_verbose > 9):
-          print debug_prefix, "  enter gai: props ", object._properties
-      for property, value in object._properties:
+class Session(qmf.console.Session):
+    """A qmf.console.Session that caches useful values"""
 
-          # we want to recurse on things which are refs.  we tell by
-          # asking each property if it's an index.  I think...
-          if (_verbose > 9):
-              print debug_prefix, "  prop ", property, " val " , value, " idx ", 
-              property.index, " type ", property.type
-
-          # property is an instance, you can ask its type, name, etc.
-
-          # special case system refs, as they will never be the same on
-          # distinct cluster nodes.  later we probably want a different
-          # way of representing these objects, like for instance don't
-          # include the system ref in the hierarchy.
-
-          if property.name == "systemRef":
-              _debug_recursion -= 1
-              self.id_cache[ObjectId(object)] = ""
-              return ""
-
-          if property.index:
-              if result != u"":
-                  result += u":"
-              if property.type == 10:
-                  try:
-                      recursive_objects = object._session.getObjects(_objectId = value, _broker=object._broker)
-                      if (_verbose > 9):
-                          print debug_prefix, "   r ", recursive_objects[0]
-                          for rp, rv in recursive_objects[0]._properties:
-                              print debug_prefix, "   rrr ", rp, " idx-p ", rp.index, " v ", rv
-                          print debug_prefix, "    recursing on ", recursive_objects[0]
-                      valstr = self.getAbstractId(recursive_objects[0])
-                      if (_verbose > 9):
-                          print debug_prefix,  "    recursing on ", recursive_objects[0],
-                          " -> ", valstr
-                  except Exception, e:
-                      if (_verbose > 9):
-                          print debug_prefix, "          except ", e
-                      valstr = u"<undecodable>"
-              else:
-                  # this yields UUID-blah.  not good.  try something else
-                  # valstr = value.__repr__()
-                  # print debug_prefix, " val ", value
-          
-                  # yetch.  this needs to be abstracted someplace?  I don't
-                  # think we have the infrastructure we need to make these id
-                  # strings be sensible in the general case
-                  if property.name == "systemId":
-                      # special case.  try to do something sensible about systemref objects
-                      valstr = object.nodeName
-                  else:
-                      valstr = value.__repr__() # I think...
-          result += valstr
-          if (_verbose > 9):
-              print debug_prefix, "    id ", self, " -> ", result
-      _debug_recursion -= 1
-      self.id_cache[ObjectId(object)] = result
-      return result
-
-    def loadTable(self, cls):
-        if _verbose > 1:
-            print "  Class:", cls.getClassName()
-        list = self.qmf.getObjects(_class=cls.getClassName(),
-                                   _package=cls.getPackageName(),
-                                   _agent=self.brokerAgent)
-
-        # tables-by-name maps class name to a table by object-name of
-        # objects.  ie use the class name ("broker", "queue", etc) to
-        # index tables-by-name, returning a second table, use the
-        # object name to index that to get an object.
-
-        self.tablesByName[cls.getClassName()] = {}
-        for obj in list:
-            # make sure we aren't colliding on name.  it's an internal
-            # error (ie, the name-generation code is busted) if we do
-            key = self.getAbstractId(obj)
-            if key in self.tablesByName[cls.getClassName()]:
-                raise Exception("internal error: collision for %s on key %s\n"
-                                % (obj, key))
-                
-            self.tablesByName[cls.getClassName()][key] = obj
-            if _verbose > 1:
-                print "   ", obj.getObjectId(), " ", obj.getIndex(), " ", key
-
-
-class BrokerManager:
     def __init__(self):
-        self.brokerName = None
-        self.qmf        = None
-        self.broker     = None
-        self.brokers    = []
-        self.cluster    = None
-
-    def SetBroker(self, brokerUrl):
-        self.url = brokerUrl
-        self.qmf = Session()
-        self.broker = self.qmf.addBroker(brokerUrl, _connTimeout)
-        agents = self.qmf.getAgents()
-        for a in agents:
-            if a.getAgentBank() == '0':
-                self.brokerAgent = a
-
-    def Disconnect(self):
-        if self.broker:
-            self.qmf.delBroker(self.broker)
-
-    def _getCluster(self):
-        packages = self.qmf.getPackages()
-        if "org.apache.qpid.cluster" not in packages:
-            return None
+        qmf.console.Session.__init__(self)
+        self.classes = None
 
-        clusters = self.qmf.getObjects(_class="cluster", _agent=self.brokerAgent)
-        if len(clusters) == 0:
-            print "Clustering is installed but not enabled on the broker."
-            return None
+    def all_classes(self):
+        if self.classes is None:
+            self.classes = [c for p in self.getPackages() for c in self.getClasses(p)]
+        return self.classes
 
-        self.cluster = clusters[0]
-
-    def _getHostList(self, urlList):
-        hosts = []
-        hostAddr = IpAddr(_host)
-        for url in urlList:
-            if url.find("amqp:") != 0:
-                raise Exception("Invalid URL 1")
-            url = url[5:]
-            addrs = str(url).split(",")
-            addrList = []
-            for addr in addrs:
-                tokens = addr.split(":")
-                if len(tokens) != 3:
-                    raise Exception("Invalid URL 2")
-                addrList.append((tokens[1], tokens[2]))
-
-            # Find the address in the list that is most likely to be
-            # in the same subnet as the address with which we made the
-            # original QMF connection.  This increases the probability
-            # that we will be able to reach the cluster member.
-
-            best = hostAddr.bestAddr(addrList)
-            bestUrl = best[0] + ":" + best[1]
-            hosts.append(bestUrl)
-        return hosts
-
-
-    # the main fun which tests for broker state "identity".  now that
-    # we're using qmf2 style object names across the board, that test
-    # means that we are ensuring that for all objects of a given
-    # class, an object of that class with the same object name exists
-    # on the peer broker.
-
-    def verify(self):
-        if _verbose > 0:
-            print "Connecting to the cluster..."
-        self._getCluster()
-        if self.cluster:
-            memberList = self.cluster.members.split(";")
-            hostList = self._getHostList(memberList)
-            self.qmf.delBroker(self.broker)
-            self.broker = None
-            for host in hostList:
-                b = self.qmf.addBroker(host, _connTimeout)
-                self.brokers.append(Broker(self.qmf, b))
-                if _verbose > 0:
-                    print "   ", b
-        else:
-            raise Exception("Failed - Not a cluster")
-
-        failures = []
-
-        # Wait until connections to all nodes are established before
-        # loading the management data.  This will ensure that the
-        # objects are all stable and the same.
-        if _verbose > 0:
-            print "Loading management data from nodes..."
-        for broker in self.brokers:
-            broker.getData()
-
-        # If we're testing delete-some-objects functionality, create a
-        # few widgets here and then delete them.
-        if _del_test:
-            if _verbose > 0:
-                print "Running delete test"
-            # just stick 'em in the first broker
-            b = self.brokers[0]
-            session = b.qmf.brokers[0].getAmqpSession()
-            session.queue_declare(queue="foo", exclusive=True, auto_delete=True)
-            session.exchange_bind(exchange="amq.direct",
-                                                 queue="foo", binding_key="foo")
-            session.queue_declare(queue="bar", exclusive=True, auto_delete=True)
-            session.exchange_bind(exchange="amq.direct",
-                                                 queue="bar", binding_key="bar")
-            # now delete 'em
-            session.exchange_unbind(queue="foo", exchange="amq.direct", binding_key="foo")
-            session.exchange_unbind(queue="bar", exchange="amq.direct", binding_key="bar")
-            session.queue_delete("bar")
-            session.queue_delete("foo")
-
-        # Verify that each node has the same set of objects (based on
-        # object name).
-        if _verbose > 0:
-            print "Verifying objects based on object name..."
-        base = self.brokers[0]
-        for broker in self.brokers[1:]:
-
-            # walk over the class names, for each class (with some
-            # exceptions) walk over the objects of that class, making
-            # sure they match between broker A and broker B
-
-            for className in base.tablesByName:
-                if className in ["broker", "system", "connection"]:
-                    continue
-
-                tab1 = base.tablesByName[className]
-                tab2 = broker.tablesByName[className]
-
-                for key in tab1:
-                    if key not in tab2:
-                        failures.append("%s key %s not found on node %s" %
-                                        (className, key, broker.getUrl()))
-                for key in tab2:
-                    if key not in tab1:
-                        failures.append("%s key %s not found on node %s" %
-                                        (className, key, base.getUrl()))
-
-        if len(failures) > 0:
-            print "Failures:"
-            for failure in failures:
-                print "  %s" % failure
-            raise Exception("Failures")
-
-        if _verbose > 0:
-            print "Success"
-
-##
-## Main Program
-##
-
-try:
-    longOpts = ("verbose=", "timeout=", "delete")
-    (optlist, encArgs) = getopt.gnu_getopt(sys.argv[1:], "", longOpts)
-except:
-    Usage()
-
-try:
-    encoding = locale.getpreferredencoding()
-    cargs = [a.decode(encoding) for a in encArgs]
-except:
-    cargs = encArgs
-
-for opt in optlist:
-    if opt[0] == "--timeout":
-        _connTimeout = int(opt[1])
-        if _connTimeout == 0:
-            _connTimeout = None
-    elif opt[0] == "--verbose":
-        _verbose = int(opt[1])
-    elif opt[0] == "--delete":
-        _del_test = True;
-    else:
-        Usage()
-
-nargs = len(cargs)
-bm    = BrokerManager()
-
-if nargs == 1:
-    _host = cargs[0]
-
-try:
-    bm.SetBroker(_host)
-    bm.verify()
-except KeyboardInterrupt:
-    print
-except Exception,e:
-    print "Failed: %s - %s" % (e.__class__.__name__, e)
-    sys.exit(1)
-
-bm.Disconnect()
+class Broker:
+    def __init__(self, url, qmf):
+        self.url = url
+        self.qmf = qmf
+        self.broker = self.qmf.addBroker(url)
+        self.broker._waitForStable()
+        self.objects = None
+        self.ignore_list = [ re.compile("org.apache.qpid.broker:system:") ]
+
+    def get_objects(self):
+        def ignore(name):
+            for m in (m for m in self.ignore_list if m.match(name)):
+                return True
+        if self.objects is None:
+            obj_list = []
+            for c in self.qmf.all_classes():
+                for o in self.qmf.getObjects(_key=c, _broker=self.broker):
+                    name=o.getObjectId().getObject()
+                    if not ignore(name): obj_list.append(name)
+            self.objects = set(obj_list)
+            if (len(obj_list) != len(self.objects)):
+                raise Exception("Duplicates in object list for %s"%(self.url))
+        return self.objects
+
+    def compare(self,other):
+        def compare1(x,y):
+            diff = x.get_objects() - y.get_objects()
+            if diff:
+                print "ERROR: found on %s but not %s"%(x, y)
+                for o in diff: print "    %s"%(o)
+                return False
+            return True
+
+        so = compare1(self, other)
+        os = compare1(other, self)
+        return so and os
+
+    def __str__(self): return self.url
+
+    def get_cluster(self):
+        """Given one Broker, return list of all brokers in its cluster"""
+        clusters = self.qmf.getObjects(_class="cluster")
+        if not clusters: raise ("%s is not a cluster member"%(self.url))
+        def first_address(url):
+            """Python doesn't understand the brokers URL syntax. Extract a simple addres"""
+            return re.compile("amqp:tcp:([^,]*)").match(url).group(1)
+        return [Broker(first_address(url), self.qmf) for url in clusters[0].members.split(";")]
+
+    def __del__(self): self.qmf.delBroker(self.broker)
+
+def main(argv=None):
+    if argv is None: argv = sys.argv
+    qmf = Session()
+    brokers = Broker(argv[1], qmf).get_cluster()
+    base = brokers.pop(0)
+    result = 0
+    for b in brokers:
+        if not base.compare(b): result = 1
+    del base
+    del brokers
+    return result
+
+if __name__ == "__main__": sys.exit(main())
diff --git a/qpid/cpp/xml/cluster.xml b/qpid/cpp/xml/cluster.xml
index 30cd159..25ad978 100644
--- a/qpid/cpp/xml/cluster.xml
+++ b/qpid/cpp/xml/cluster.xml
@@ -134,7 +134,9 @@
     </control>
 
     <!-- Marks the cluster-wide point when a connection is considered closed. -->
-    <control name="deliver-close" code="0x2"/>
+    <control name="deliver-close" code="0x2">
+      <field name="aborted" type="bit"/>
+    </control>
 
     <!-- Permission to generate output up to the limit. -->
     <control name="deliver-do-output" code="0x3">
-- 
1.5.5.6

From 5fbdc4c62f80ea01c9bd82187b1decdca36dde7e Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Tue, 22 Jun 2010 15:42:35 +0000
Subject: [PATCH] Bug 603896 - Fixed - Message traffic freezes after queues back up

Don't hold QueueRegistry lock while iterating over queues to purge them of expired messages.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@956923 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 1a85afb37de55697e172acd001db98dd9b4722a1)
---
 qpid/cpp/src/qpid/broker/QueueCleaner.cpp |   18 +++++++++++++++++-
 1 files changed, 17 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/QueueCleaner.cpp b/qpid/cpp/src/qpid/broker/QueueCleaner.cpp
index c80fe89..ed98468 100644
--- a/qpid/cpp/src/qpid/broker/QueueCleaner.cpp
+++ b/qpid/cpp/src/qpid/broker/QueueCleaner.cpp
@@ -46,9 +46,25 @@ void QueueCleaner::Task::fire()
     parent.fired();
 }
 
+namespace {
+struct CollectQueues
+{
+    std::vector<Queue::shared_ptr>* queues;
+    CollectQueues(std::vector<Queue::shared_ptr>* q) : queues(q) {}
+    void operator()(Queue::shared_ptr q)
+    {
+        queues->push_back(q);
+    }
+};
+}
+
 void QueueCleaner::fired()
 {
-    queues.eachQueue(boost::bind(&Queue::purgeExpired, _1));
+    //collect copy of list of queues to avoid holding registry lock while we perform purge
+    std::vector<Queue::shared_ptr> copy;
+    CollectQueues collect(&copy);
+    queues.eachQueue(collect);
+    std::for_each(copy.begin(), copy.end(), boost::bind(&Queue::purgeExpired, _1));
     task->setupNextFire();
     timer.add(task);
 }
-- 
1.5.5.6

From 7361da16e3ffdd0b3b4804d774ae768503c2460c Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Tue, 22 Jun 2010 18:13:35 +0000
Subject: [PATCH] Bug 605763 - Failures in long cluster_tests.test_management

Fix bad assertion introduced in prevoius commit r956882

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@956965 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 9f875847254c6a47f7fc9fef3fcfee7e0391d39e)
---
 qpid/cpp/src/qpid/sys/ClusterSafe.cpp |    6 +++---
 qpid/cpp/src/qpid/sys/ClusterSafe.h   |    5 ++++-
 2 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/ClusterSafe.cpp b/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
index 6105fc9..c6b527d 100644
--- a/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
+++ b/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
@@ -43,14 +43,14 @@ void assertClusterSafe()  {
     }
 }
 
-ClusterSafeScope::ClusterSafeScope() {
-    assert(!inContext);
+ClusterSafeScope::ClusterSafeScope()  {
+    save = inContext;
     inContext = true;
 }
 
 ClusterSafeScope::~ClusterSafeScope() {
     assert(inContext);
-    inContext = false;
+    inContext = save;
 }
 
 void enableClusterSafe() { inCluster = true; }
diff --git a/qpid/cpp/src/qpid/sys/ClusterSafe.h b/qpid/cpp/src/qpid/sys/ClusterSafe.h
index f338230..15675e8 100644
--- a/qpid/cpp/src/qpid/sys/ClusterSafe.h
+++ b/qpid/cpp/src/qpid/sys/ClusterSafe.h
@@ -61,9 +61,12 @@ QPID_COMMON_EXTERN bool isCluster();
  * and provides functions to assist detecting bugs in cluster
  * behavior.
  */
-struct ClusterSafeScope {
+class ClusterSafeScope {
+  public:
     ClusterSafeScope();
     ~ClusterSafeScope();
+  private:
+    bool save;
 };
 
 /**
-- 
1.5.5.6

From 60a76e31d0b05c93662101a61bf573067440daec Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Tue, 22 Jun 2010 19:27:12 +0000
Subject: [PATCH] Bug 606824 - Fixed - Acquired but Not Accepted Messages Not Sent to Alternate Exchange

QPID-2688: ensure that unacked messages are requeued before autodeletion occurs when session closes

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@956988 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 91c77007649756868748b02fa8fd7ff9d6e881b4)
---
 qpid/cpp/src/qpid/broker/SemanticState.cpp |   41 +++++++++++++++++++++------
 qpid/cpp/src/qpid/broker/SemanticState.h   |    4 +++
 qpid/cpp/src/qpid/broker/SessionState.cpp  |    1 +
 3 files changed, 37 insertions(+), 9 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/SemanticState.cpp b/qpid/cpp/src/qpid/broker/SemanticState.cpp
index b8981b4..c91cfba 100644
--- a/qpid/cpp/src/qpid/broker/SemanticState.cpp
+++ b/qpid/cpp/src/qpid/broker/SemanticState.cpp
@@ -73,21 +73,34 @@ SemanticState::SemanticState(DeliveryAdapter& da, SessionContext& ss)
       authMsg(getSession().getBroker().getOptions().auth && !getSession().getConnection().isFederationLink()),
       userID(getSession().getConnection().getUserId()),
       userName(getSession().getConnection().getUserId().substr(0,getSession().getConnection().getUserId().find('@'))),
-      isDefaultRealm(userID.find('@') != std::string::npos && getSession().getBroker().getOptions().realm == userID.substr(userID.find('@')+1,userID.size()))
+      isDefaultRealm(userID.find('@') != std::string::npos && getSession().getBroker().getOptions().realm == userID.substr(userID.find('@')+1,userID.size())),
+      closeComplete(false)
 {
     acl = getSession().getBroker().getAcl();
 }
 
 SemanticState::~SemanticState() {
-    //cancel all consumers
-    for (ConsumerImplMap::iterator i = consumers.begin(); i != consumers.end(); i++) {
-        cancel(i->second);
-    }
+    closed();
+}
 
-    if (dtxBuffer.get()) {
-        dtxBuffer->fail();
+void SemanticState::closed() {
+    if (!closeComplete) {
+        //prevent requeued messages being redelivered to consumers
+        for (ConsumerImplMap::iterator i = consumers.begin(); i != consumers.end(); i++) {
+            disable(i->second);
+        }        
+        if (dtxBuffer.get()) {
+            dtxBuffer->fail();
+        }
+        recover(true);
+
+        //now unsubscribe, which may trigger queue deletion and thus
+        //needs to occur after the requeueing of unacked messages
+        for (ConsumerImplMap::iterator i = consumers.begin(); i != consumers.end(); i++) {
+            unsubscribe(i->second);
+        }
+        closeComplete = true;
     }
-    recover(true);
 }
 
 bool SemanticState::exists(const string& consumerTag){
@@ -389,11 +402,15 @@ SemanticState::ConsumerImpl::~ConsumerImpl()
         mgmtObject->resourceDestroy ();
 }
 
-void SemanticState::cancel(ConsumerImpl::shared_ptr c)
+void SemanticState::disable(ConsumerImpl::shared_ptr c)
 {
     c->disableNotify();
     if (session.isAttached())
         session.getConnection().outputTasks.removeOutputTask(c.get());
+}
+
+void SemanticState::unsubscribe(ConsumerImpl::shared_ptr c)
+{
     Queue::shared_ptr queue = c->getQueue();
     if(queue) {
         queue->cancel(c);
@@ -403,6 +420,12 @@ void SemanticState::cancel(ConsumerImpl::shared_ptr c)
     }
 }
 
+void SemanticState::cancel(ConsumerImpl::shared_ptr c)
+{
+    disable(c);
+    unsubscribe(c);
+}
+
 void SemanticState::handle(intrusive_ptr<Message> msg) {
     if (txBuffer.get()) {
         TxPublish* deliverable(new TxPublish(msg));
diff --git a/qpid/cpp/src/qpid/broker/SemanticState.h b/qpid/cpp/src/qpid/broker/SemanticState.h
index cae8527..2b31492 100644
--- a/qpid/cpp/src/qpid/broker/SemanticState.h
+++ b/qpid/cpp/src/qpid/broker/SemanticState.h
@@ -157,6 +157,7 @@ class SemanticState : private boost::noncopyable {
     const string userID;
     const string userName;
     const bool isDefaultRealm;
+    bool closeComplete;
 
     void route(boost::intrusive_ptr<Message> msg, Deliverable& strategy);
     void checkDtxTimeout();
@@ -165,6 +166,8 @@ class SemanticState : private boost::noncopyable {
     AckRange findRange(DeliveryId first, DeliveryId last);
     void requestDispatch();
     void cancel(ConsumerImpl::shared_ptr);
+    void unsubscribe(ConsumerImpl::shared_ptr);
+    void disable(ConsumerImpl::shared_ptr);
 
   public:
     SemanticState(DeliveryAdapter&, SessionContext&);
@@ -220,6 +223,7 @@ class SemanticState : private boost::noncopyable {
 
     void attached();
     void detached();
+    void closed();
 
     // Used by cluster to re-create sessions
     template <class F> void eachConsumer(F f) {
diff --git a/qpid/cpp/src/qpid/broker/SessionState.cpp b/qpid/cpp/src/qpid/broker/SessionState.cpp
index ddf68ca..be4f8c7 100644
--- a/qpid/cpp/src/qpid/broker/SessionState.cpp
+++ b/qpid/cpp/src/qpid/broker/SessionState.cpp
@@ -88,6 +88,7 @@ SessionState::SessionState(
 }
 
 SessionState::~SessionState() {
+    semanticState.closed();
     if (mgmtObject != 0)
         mgmtObject->resourceDestroy ();
 
-- 
1.5.5.6

From c3f1bef98288cc54c6434e295d82bc2dec3888ca Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Wed, 23 Jun 2010 04:52:49 +0000
Subject: [PATCH] BZ 606761:

QPID-2388: Do not unmask signals whilst waiting for IO to happen
- The client and common libraries do not use signals at all so
  there is no real reason to allow signal handling on IO threads.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@957109 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp |   12 ------------
 qpid/cpp/src/tests/DispatcherTest.cpp       |    8 ++------
 2 files changed, 2 insertions(+), 18 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp b/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp
index 9ae9bce..9ad05c7 100644
--- a/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp
+++ b/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp
@@ -262,7 +262,6 @@ class PollerPrivate {
     const int epollFd;
     bool isShutdown;
     InterruptHandle interruptHandle;
-    ::sigset_t sigMask;
     HandleSet registeredHandles;
     AtomicCount threadCount;
 
@@ -294,7 +293,6 @@ class PollerPrivate {
         epollFd(::epoll_create(DefaultFds)),
         isShutdown(false) {
         QPID_POSIX_CHECK(epollFd);
-        ::sigemptyset(&sigMask);
         // Add always readable fd into our set (but not listening to it yet)
         ::epoll_event epe;
         epe.events = 0;
@@ -562,17 +560,7 @@ Poller::Event Poller::wait(Duration timeout) {
     // Repeat until we weren't interrupted by signal
     do {
         PollerHandleDeletionManager.markAllUnusedInThisThread();
-        // Need to run on kernels without epoll_pwait()
-        // - fortunately in this case we don't really need the atomicity of epoll_pwait()
-#if 1
-        sigset_t os;
-        pthread_sigmask(SIG_SETMASK, &impl->sigMask, &os);
         int rc = ::epoll_wait(impl->epollFd, &epe, 1, timeoutMs);
-        pthread_sigmask(SIG_SETMASK, &os, 0);
-#else
-        int rc = ::epoll_pwait(impl->epollFd, &epe, 1, timeoutMs, &impl->sigMask);
-#endif
-
         if (rc ==-1 && errno != EINTR) {
             QPID_POSIX_CHECK(rc);
         } else if (rc > 0) {
diff --git a/qpid/cpp/src/tests/DispatcherTest.cpp b/qpid/cpp/src/tests/DispatcherTest.cpp
index 17b3b4e..41e6054 100644
--- a/qpid/cpp/src/tests/DispatcherTest.cpp
+++ b/qpid/cpp/src/tests/DispatcherTest.cpp
@@ -161,12 +161,8 @@ int main(int /*argc*/, char** /*argv*/)
     wh->startWatch(poller);
 
     // Set up a regular itimer interupt
-
-    // Ignore signal in this thread
-    ::sigset_t sm;
-    ::sigemptyset(&sm);
-    ::sigaddset(&sm, SIGRTMIN);
-    ::pthread_sigmask(SIG_BLOCK, &sm, 0);
+    // We assume that this thread will handle the signals whilst sleeping
+    // as the Poller threads have signal handling blocked
 
     // Signal handling
     struct ::sigaction sa;
-- 
1.5.5.6

From 162d3fdea6a041706de430aec6ebdeea0dc1fae6 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Thu, 24 Jun 2010 11:22:28 +0000
Subject: [PATCH] Bug 607552 - Fixed - ttl is lost for federation routes where trace id is added

QPID-2691: ensure ttl adjustment uses correct expiration on cloned message

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@957511 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit f6f5a3deb6dfe337081d58bcb6d97ec4f03e6531)
---
 qpid/cpp/src/qpid/broker/Message.cpp |    7 +++++--
 qpid/cpp/src/qpid/broker/Queue.cpp   |    2 +-
 qpid/cpp/src/qpid/broker/Queue.h     |    2 +-
 qpid/cpp/src/tests/federation.py     |    4 +++-
 4 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Message.cpp b/qpid/cpp/src/qpid/broker/Message.cpp
index 1e56544..ad67bff 100644
--- a/qpid/cpp/src/qpid/broker/Message.cpp
+++ b/qpid/cpp/src/qpid/broker/Message.cpp
@@ -55,8 +55,11 @@ Message::Message(const framing::SequenceNumber& id) :
 Message::Message(const Message& original) :
     PersistableMessage(), frames(original.frames), persistenceId(0), redelivered(false), loaded(false),
     staged(false), forcePersistentPolicy(false), publisher(0), adapter(0), 
-    expiration(FAR_FUTURE), enqueueCallback(0), dequeueCallback(0),
-    inCallback(false), requiredCredit(0) {}
+    expiration(original.expiration), enqueueCallback(0), dequeueCallback(0),
+    inCallback(false), requiredCredit(0) 
+{
+    setExpiryPolicy(original.expiryPolicy);
+}
 
 Message::~Message()
 {
diff --git a/qpid/cpp/src/qpid/broker/Queue.cpp b/qpid/cpp/src/qpid/broker/Queue.cpp
index 7f7b2bc..dd077aa 100644
--- a/qpid/cpp/src/qpid/broker/Queue.cpp
+++ b/qpid/cpp/src/qpid/broker/Queue.cpp
@@ -141,7 +141,7 @@ bool Queue::isExcluded(boost::intrusive_ptr<Message>& msg)
     return traceExclude.size() && msg->isExcluded(traceExclude);
 }
 
-void Queue::deliver(boost::intrusive_ptr<Message>& msg){
+void Queue::deliver(boost::intrusive_ptr<Message> msg){
     if (msg->isImmediate() && getConsumerCount() == 0) {
         if (alternateExchange) {
             DeliverableMessage deliverable(msg);
diff --git a/qpid/cpp/src/qpid/broker/Queue.h b/qpid/cpp/src/qpid/broker/Queue.h
index ebef6e4..41c6b46 100644
--- a/qpid/cpp/src/qpid/broker/Queue.h
+++ b/qpid/cpp/src/qpid/broker/Queue.h
@@ -211,7 +211,7 @@ namespace qpid {
              * Delivers a message to the queue. Will record it as
              * enqueued if persistent then process it.
              */
-            QPID_BROKER_EXTERN void deliver(boost::intrusive_ptr<Message>& msg);
+            QPID_BROKER_EXTERN void deliver(boost::intrusive_ptr<Message> msg);
             /**
              * Dispatches the messages immediately to a consumer if
              * one is available or stores it for later if not.
diff --git a/qpid/cpp/src/tests/federation.py b/qpid/cpp/src/tests/federation.py
index d7f9342..63e3f2b 100755
--- a/qpid/cpp/src/tests/federation.py
+++ b/qpid/cpp/src/tests/federation.py
@@ -358,7 +358,7 @@ class FederationTests(TestBase010):
         for b, t in zip(body, trace):
             headers = {}
             if (t): headers["x-qpid.trace"]=t
-            dp = r_session.delivery_properties(routing_key="my-key")
+            dp = r_session.delivery_properties(routing_key="my-key", ttl=1000*60*5)
             mp = r_session.message_properties(application_headers=headers)
             r_session.message_transfer(destination="amq.direct", message=Message(dp, mp, b))
 
@@ -366,6 +366,8 @@ class FederationTests(TestBase010):
             msg = queue.get(timeout=5)
             self.assertEqual("yes", msg.body)
             self.assertEqual(e, self.getAppHeader(msg, "x-qpid.trace"))
+            assert(msg.get("delivery_properties").ttl > 0)
+            assert(msg.get("delivery_properties").ttl < 1000*60*50)
 
         try:
             extra = queue.get(timeout=1)
-- 
1.5.5.6

From abe5059836d94a9aa121e1211f080a4b3d2c03eb Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Thu, 24 Jun 2010 11:34:18 +0000
Subject: [PATCH] Bug 607550 - Fixed - spout: Ignoring frame while closing connection

Ensure spout example waits for all messages to be sent before detaching session

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@957513 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 9b98d16351d428295a9108ff53994bc80f92e46d)
---
 qpid/cpp/examples/messaging/spout.cpp |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/examples/messaging/spout.cpp b/qpid/cpp/examples/messaging/spout.cpp
index e100560..57b955c 100644
--- a/qpid/cpp/examples/messaging/spout.cpp
+++ b/qpid/cpp/examples/messaging/spout.cpp
@@ -161,6 +161,7 @@ int main(int argc, char** argv)
                 message.getProperties()["spout-id"] = spoutid.str();
                 sender.send(message);
             }
+            session.sync();
             connection.close();
             return 0;
         } catch(const std::exception& error) {
-- 
1.5.5.6

From da98116bb0e911c9f491c942790ff33543e14571 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Thu, 24 Jun 2010 17:19:58 +0000
Subject: [PATCH] Bug 604842 - cluster_test fails intermittently

The bug is fixed by this and other commits leading up to it.

Fix regression in r956882, sporadic failures of client_test.cpp:testBadClientData

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@957640 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit bc5441acda9f35bef338677868e46145ce7a418b)
---
 qpid/cpp/src/qpid/cluster/Connection.cpp |   23 +++++++++--------------
 qpid/cpp/src/qpid/cluster/Connection.h   |    2 +-
 qpid/cpp/xml/cluster.xml                 |    4 +---
 3 files changed, 11 insertions(+), 18 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index e0c0465..04aced5 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -262,7 +262,7 @@ void Connection::closed() {
             // until self-delivery of deliver-close.
             output.closeOutput();
             cluster.getMulticast().mcastControl(
-                ClusterConnectionDeliverCloseBody(ProtocolVersion(), false), self);
+                ClusterConnectionDeliverCloseBody(), self);
         }
     }
     catch (const std::exception& e) {
@@ -271,31 +271,26 @@ void Connection::closed() {
 }
 
 // Self-delivery of close message, close the connection.
-void Connection::deliverClose (bool aborted) {
-    QPID_LOG(debug, cluster << " replicated close of " << *this);
-    if (connection.get()) {
-        if (aborted) connection->abort();
-        else connection->closed();
-        connection.reset();
-    }
+void Connection::deliverClose () {
+    close();
     cluster.erase(self);
 }
 
 // Close the connection
 void Connection::close() {
-    QPID_LOG(debug, cluster << " local close of " << *this);
     if (connection.get()) {
+        QPID_LOG(debug, cluster << " closed connection " << *this);
         connection->closed();
         connection.reset();
     }
 }
 
-// The connection has been killed for misbehaving, called in connection thread.
+// The connection has sent invalid data and should be aborted.
+// All members will get the same abort since they all process the same data.
 void Connection::abort() {
-    if (connection.get()) {
-        cluster.getMulticast().mcastControl(
-            ClusterConnectionDeliverCloseBody(ProtocolVersion(), true), self);
-    }
+    connection->abort();
+    // Aborting the connection will result in a call to ::closed()
+    // and allow the connection to close in an orderly manner.
 }
 
 // ConnectionCodec::decode receives read buffers from  directly-connected clients.
diff --git a/qpid/cpp/src/qpid/cluster/Connection.h b/qpid/cpp/src/qpid/cluster/Connection.h
index 72a98c1..aec18d7 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.h
+++ b/qpid/cpp/src/qpid/cluster/Connection.h
@@ -170,7 +170,7 @@ class Connection :
                   const std::string& initFrames);
     void close();
     void abort();
-    void deliverClose(bool);
+    void deliverClose();
 
     OutputInterceptor& getOutput() { return output; }
 
diff --git a/qpid/cpp/xml/cluster.xml b/qpid/cpp/xml/cluster.xml
index 25ad978..30cd159 100644
--- a/qpid/cpp/xml/cluster.xml
+++ b/qpid/cpp/xml/cluster.xml
@@ -134,9 +134,7 @@
     </control>
 
     <!-- Marks the cluster-wide point when a connection is considered closed. -->
-    <control name="deliver-close" code="0x2">
-      <field name="aborted" type="bit"/>
-    </control>
+    <control name="deliver-close" code="0x2"/>
 
     <!-- Permission to generate output up to the limit. -->
     <control name="deliver-do-output" code="0x3">
-- 
1.5.5.6

From 3f3e6086766770c3d7e1a7cf9afdfaedce82dd18 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Thu, 24 Jun 2010 17:34:34 +0000
Subject: [PATCH] BZ-560707 added full support for unreliable, at-least-once, and at-most-once reliability options

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@957644 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py          |   59 +++++++++++++++++--------
 qpid/python/qpid/tests/messaging/endpoints.py |   27 +++++++++++
 2 files changed, 68 insertions(+), 18 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index 7f04903..76ccd54 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -95,6 +95,7 @@ CLIENT_PROPERTIES = {"product": "qpid python client",
                      "qpid.client_ppid": ppid}
 
 def noop(): pass
+def sync_noop(): pass
 
 class SessionState:
 
@@ -136,7 +137,7 @@ class SessionState:
     if overrides:
       self.apply_overrides(cmd, overrides)
 
-    if sync or action != noop:
+    if action != noop:
       cmd.sync = sync
     if self.detached:
       raise Exception("detached")
@@ -215,11 +216,14 @@ class LinkIn:
 
   def do_link(self, sst, rcv, _rcv, type, subtype, action):
     link_opts = _rcv.options.get("link", {})
-    # XXX: default?
-    reliability = link_opts.get("reliability", "unreliable")
+    reliability = link_opts.get("reliability", "at-least-once")
     declare = link_opts.get("x-declare", {})
     subscribe = link_opts.get("x-subscribe", {})
     acq_mode = acquire_mode.pre_acquired
+    if reliability in ("unreliable", "at-most-once"):
+      rcv._accept_mode = accept_mode.none
+    else:
+      rcv._accept_mode = accept_mode.explicit
 
     if type == "topic":
       default_name = "%s.%s" % (rcv.session.name, _rcv.destination)
@@ -239,9 +243,12 @@ class LinkIn:
         acq_mode = acquire_mode.not_acquired
       bindings = get_bindings(link_opts, queue=_rcv._queue)
 
+
     sst.write_cmds(bindings)
-    sst.write_cmd(MessageSubscribe(queue=_rcv._queue, destination=_rcv.destination,
-                                   acquire_mode = acq_mode),
+    sst.write_cmd(MessageSubscribe(queue=_rcv._queue,
+                                   destination=_rcv.destination,
+                                   acquire_mode = acq_mode,
+                                   accept_mode = rcv._accept_mode),
                   overrides=subscribe)
     sst.write_cmd(MessageSetFlowMode(_rcv.destination, flow_mode.credit), action)
 
@@ -263,9 +270,12 @@ class LinkOut:
 
   def init_link(self, sst, snd, _snd):
     _snd.closing = False
+    _snd.pre_ack = False
 
   def do_link(self, sst, snd, _snd, type, subtype, action):
     link_opts = _snd.options.get("link", {})
+    reliability = link_opts.get("reliability", "at-least-once")
+    _snd.pre_ack = reliability in ("unreliable", "at-most-once")
     if type == "topic":
       _snd._exchange = _snd.name
       _snd._routing_key = _snd.subject
@@ -968,32 +978,34 @@ class Engine:
 
     for snd in ssn.senders:
       if snd.synced >= snd.queued and sst.need_sync:
-        sst.write_cmd(ExecutionSync(), sync=True)
+        sst.write_cmd(ExecutionSync(), sync_noop)
 
     for rcv in ssn.receivers:
       self.process_receiver(rcv)
 
     if ssn.acked:
       messages = ssn.acked[sst.acked_idx:]
-      delta = len(messages)
       if messages:
         ids = RangedSet()
 
         disposed = [(DEFAULT_DISPOSITION, [])]
+        acked = []
         for m in messages:
           # XXX: we're ignoring acks that get lost when disconnected,
           # could we deal this via some message-id based purge?
           if m._transfer_id is None:
-            ssn.acked.remove(m)
-            delta -= 1
+            acked.append(m)
             continue
           ids.add(m._transfer_id)
-          disp = m._disposition or DEFAULT_DISPOSITION
-          last, msgs = disposed[-1]
-          if disp.type is last.type and disp.options == last.options:
-            msgs.append(m)
+          if m._receiver._accept_mode is accept_mode.explicit:
+            disp = m._disposition or DEFAULT_DISPOSITION
+            last, msgs = disposed[-1]
+            if disp.type is last.type and disp.options == last.options:
+              msgs.append(m)
+            else:
+              disposed.append((disp, [m]))
           else:
-            disposed.append((disp, [m]))
+            acked.append(m)
 
         for range in ids:
           sst.executed.add_range(range)
@@ -1004,6 +1016,7 @@ class Engine:
             for m in msgs:
               ssn.acked.remove(m)
               sst.acked_idx -= 1
+              # XXX: should this check accept_mode too?
               if not ssn.transactional:
                 sst.acked.remove(m)
           return ack_ack
@@ -1023,9 +1036,9 @@ class Engine:
             for m in msgs:
               log.debug("SACK[%s]: %s, %s", ssn.log_id, m, m._disposition)
 
-        # XXX: could add messages with _transfer_id of None
         sst.acked.extend(messages)
-        sst.acked_idx += delta
+        sst.acked_idx += len(messages)
+        ack_acker(acked)()
 
     if ssn.committing and not sst.committing:
       def commit_ok():
@@ -1173,10 +1186,20 @@ class Engine:
       sst.outgoing_idx -= 1
       log.debug("RACK[%s]: %s", sst.session.log_id, msg)
       assert msg == m
-    sst.write_cmd(MessageTransfer(destination=_snd._exchange, headers=(dp, mp),
-                                  payload=body), msg_acked, sync=msg._sync)
+
+    xfr = MessageTransfer(destination=_snd._exchange, headers=(dp, mp),
+                          payload=body)
+
+    if _snd.pre_ack:
+      sst.write_cmd(xfr)
+    else:
+      sst.write_cmd(xfr, msg_acked, sync=msg._sync)
+
     log.debug("SENT[%s]: %s", sst.session.log_id, msg)
 
+    if _snd.pre_ack:
+      msg_acked()
+
   def do_message_transfer(self, xfr):
     sst = self.get_sst(xfr)
     ssn = sst.session
diff --git a/qpid/python/qpid/tests/messaging/endpoints.py b/qpid/python/qpid/tests/messaging/endpoints.py
index 3133fe7..dce8d9b 100644
--- a/qpid/python/qpid/tests/messaging/endpoints.py
+++ b/qpid/python/qpid/tests/messaging/endpoints.py
@@ -685,6 +685,33 @@ class ReceiverTests(Base):
 
   # XXX: need testUnsettled()
 
+  def unreliabilityTest(self, mode="unreliable"):
+    msgs = [self.message("testUnreliable", i) for i in range(3)]
+    snd = self.ssn.sender("test-unreliability-queue; {create: sender, delete: receiver}")
+    rcv = self.ssn.receiver(snd.target)
+    for m in msgs:
+      snd.send(m)
+
+    # close without ack on reliable receiver, messages should be requeued
+    ssn = self.conn.session()
+    rrcv = ssn.receiver("test-unreliability-queue")
+    self.drain(rrcv, expected=msgs)
+    ssn.close()
+
+    # close without ack on unreliable receiver, messages should not be requeued
+    ssn = self.conn.session()
+    urcv = ssn.receiver("test-unreliability-queue; {link: {reliability: %s}}" % mode)
+    self.drain(urcv, expected=msgs, redelivered=True)
+    ssn.close()
+
+    self.assertEmpty(rcv)
+
+  def testUnreliable(self):
+    self.unreliabilityTest(mode="unreliable")
+
+  def testAtMostOnce(self):
+    self.unreliabilityTest(mode="at-most-once")
+
 class AddressTests(Base):
 
   def setup_connection(self):
-- 
1.5.5.6

From 495213b8cc66dc00c15662c559a48dcf04516fd7 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Fri, 25 Jun 2010 17:09:05 +0000
Subject: [PATCH] BZ-569515 added optional timeouts to {connection,session,sender,receiver}.close() as well as connection.detach() and {session,sender}.sync()

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958037 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py          |    2 +
 qpid/python/qpid/messaging/endpoints.py       |   57 +++++++++-----
 qpid/python/qpid/messaging/exceptions.py      |    5 +
 qpid/python/qpid/tests/messaging/__init__.py  |    6 +-
 qpid/python/qpid/tests/messaging/endpoints.py |  103 ++++++++++++++++++++++++-
 5 files changed, 148 insertions(+), 25 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index 76ccd54..6dab24d 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -357,6 +357,8 @@ class Driver:
 
   def stop(self):
     self._selector.unregister(self)
+    if self._transport:
+      self.st_closed()
 
   def fileno(self):
     return self._transport.fileno()
diff --git a/qpid/python/qpid/messaging/endpoints.py b/qpid/python/qpid/messaging/endpoints.py
index 58a654e..30f51fe 100644
--- a/qpid/python/qpid/messaging/endpoints.py
+++ b/qpid/python/qpid/messaging/endpoints.py
@@ -251,15 +251,18 @@ class Connection:
             if not (l.linked or l.error or l.closed)]
 
   @synchronized
-  def detach(self):
+  def detach(self, timeout=None):
     """
     Detach from the remote endpoint.
     """
     self._connected = False
     self._wakeup()
-    self._wait(lambda: not self._transport_connected)
-    self._driver.stop()
-    self._condition.gc()
+    try:
+      if not self._wait(lambda: not self._transport_connected, timeout=timeout):
+        raise Timeout("detach timed out")
+    finally:
+      self._driver.stop()
+      self._condition.gc()
 
   @synchronized
   def attached(self):
@@ -269,15 +272,15 @@ class Connection:
     return self._connected
 
   @synchronized
-  def close(self):
+  def close(self, timeout=None):
     """
     Close the connection and all sessions.
     """
     try:
       for ssn in self.sessions.values():
-        ssn.close()
+        ssn.close(timeout=timeout)
     finally:
-      self.detach()
+      self.detach(timeout=timeout)
       self._open = False
 
 class Session:
@@ -677,28 +680,32 @@ class Session:
     assert self.aborted
 
   @synchronized
-  def sync(self):
+  def sync(self, timeout=None):
     """
     Sync the session.
     """
     for snd in self.senders:
-      snd.sync()
-    self._ewait(lambda: not self.outgoing and not self.acked)
+      snd.sync(timeout=timeout)
+    if not self._ewait(lambda: not self.outgoing and not self.acked, timeout=timeout):
+      raise Timeout("session sync timed out")
 
   @synchronized
-  def close(self):
+  def close(self, timeout=None):
     """
     Close the session.
     """
-    self.sync()
+    self.sync(timeout=timeout)
 
     for link in self.receivers + self.senders:
-      link.close()
+      link.close(timeout=timeout)
 
     self.closing = True
     self._wakeup()
-    self._ewait(lambda: self.closed)
-    self.connection._remove_session(self)
+    try:
+      if not self._ewait(lambda: self.closed, timeout=timeout):
+        raise Timeout("session close timed out")
+    finally:
+      self.connection._remove_session(self)
 
 class Sender:
 
@@ -816,22 +823,29 @@ class Sender:
       self._wakeup()
 
   @synchronized
-  def sync(self):
+  def sync(self, timeout=None):
     mno = self.queued
     if self.synced < mno:
       self.synced = mno
       self._wakeup()
-    self._ewait(lambda: self.acked >= mno)
+    if not self._ewait(lambda: self.acked >= mno, timeout=timeout):
+      raise Timeout("sender sync timed out")
 
   @synchronized
-  def close(self):
+  def close(self, timeout=None):
     """
     Close the Sender.
     """
+    # avoid erroring out when closing a sender that was never
+    # established
+    if self.acked < self.queued:
+      self.sync(timeout=timeout)
+
     self.closing = True
     self._wakeup()
     try:
-      self.session._ewait(lambda: self.closed)
+      if not self.session._ewait(lambda: self.closed, timeout=timeout):
+        raise Timeout("sender close timed out")
     finally:
       self.session.senders.remove(self)
 
@@ -962,14 +976,15 @@ class Receiver(object):
       self.granted = self.received + self._capacity
 
   @synchronized
-  def close(self):
+  def close(self, timeout=None):
     """
     Close the receiver.
     """
     self.closing = True
     self._wakeup()
     try:
-      self.session._ewait(lambda: self.closed)
+      if not self.session._ewait(lambda: self.closed, timeout=timeout):
+        raise Timeout("receiver close timed out")
     finally:
       self.session.receivers.remove(self)
 
diff --git a/qpid/python/qpid/messaging/exceptions.py b/qpid/python/qpid/messaging/exceptions.py
index 0a4941a..f640b6b 100644
--- a/qpid/python/qpid/messaging/exceptions.py
+++ b/qpid/python/qpid/messaging/exceptions.py
@@ -17,6 +17,11 @@
 # under the License.
 #
 
+class Timeout(Exception):
+  pass
+
+## Messaging Errors
+
 class MessagingError(Exception):
 
   def __init__(self, code=None, text=None, **info):
diff --git a/qpid/python/qpid/tests/messaging/__init__.py b/qpid/python/qpid/tests/messaging/__init__.py
index 147dbb8..2c1dce9 100644
--- a/qpid/python/qpid/tests/messaging/__init__.py
+++ b/qpid/python/qpid/tests/messaging/__init__.py
@@ -51,7 +51,11 @@ class Base(Test):
 
   def teardown(self):
     if self.conn is not None and self.conn.attached():
-      self.conn.close()
+      self.teardown_connection(self.conn)
+      self.conn = None
+
+  def teardown_connection(self, conn):
+    conn.close()
 
   def content(self, base, count = None):
     if count is None:
diff --git a/qpid/python/qpid/tests/messaging/endpoints.py b/qpid/python/qpid/tests/messaging/endpoints.py
index dce8d9b..b064d62 100644
--- a/qpid/python/qpid/tests/messaging/endpoints.py
+++ b/qpid/python/qpid/tests/messaging/endpoints.py
@@ -20,10 +20,11 @@
 # setup, usage, teardown, errors(sync), errors(async), stress, soak,
 # boundary-conditions, config
 
-import errno, os, time
+import errno, os, socket, time
 from qpid import compat
 from qpid.compat import set
 from qpid.messaging import *
+from qpid.messaging.transports import TRANSPORTS
 from qpid.tests.messaging import Base
 
 class SetupTests(Base):
@@ -98,8 +99,6 @@ class SetupTests(Base):
 
   def testReconnect(self):
     options = self.connection_options()
-    import socket
-    from qpid.messaging.transports import TRANSPORTS
     real = TRANSPORTS["tcp"]
 
     class flaky:
@@ -213,6 +212,104 @@ class ConnectionTests(Base):
     self.conn.close()
     assert not self.conn.attached()
 
+class hangable:
+
+  def __init__(self, host, port):
+    self.tcp = TRANSPORTS["tcp"](host, port)
+    self.hung = False
+
+  def hang(self):
+    self.hung = True
+
+  def fileno(self):
+    return self.tcp.fileno()
+
+  def reading(self, reading):
+    if self.hung:
+      return True
+    else:
+      return self.tcp.reading(reading)
+
+  def writing(self, writing):
+    if self.hung:
+      return False
+    else:
+      return self.tcp.writing(writing)
+
+  def send(self, bytes):
+    if self.hung:
+      return 0
+    else:
+      return self.tcp.send(bytes)
+
+  def recv(self, n):
+    if self.hung:
+      return ""
+    else:
+      return self.tcp.recv(n)
+
+  def close(self):
+    self.tcp.close()
+
+TRANSPORTS["hangable"] = hangable
+
+class TimeoutTests(Base):
+
+  def setup_connection(self):
+    options = self.connection_options()
+    options["transport"] = "hangable"
+    return Connection.establish(self.broker, **options)
+
+  def setup_session(self):
+    return self.conn.session()
+
+  def setup_sender(self):
+    return self.ssn.sender("amq.topic")
+
+  def setup_receiver(self):
+    return self.ssn.receiver("amq.topic")
+
+  def teardown_connection(self, conn):
+    try:
+      conn.detach(timeout=0)
+    except Timeout:
+      pass
+
+  def hang(self):
+    self.conn._driver._transport.hang()
+
+  def timeoutTest(self, method):
+    self.hang()
+    try:
+      method(timeout=self.delay())
+      assert False, "did not time out"
+    except Timeout:
+      pass
+
+  def testSenderSync(self):
+    self.snd.send(self.content("testSenderSync"), sync=False)
+    self.timeoutTest(self.snd.sync)
+
+  def testSenderClose(self):
+    self.snd.send(self.content("testSenderClose"), sync=False)
+    self.timeoutTest(self.snd.close)
+
+  def testReceiverClose(self):
+    self.timeoutTest(self.rcv.close)
+
+  def testSessionSync(self):
+    self.snd.send(self.content("testSessionSync"), sync=False)
+    self.timeoutTest(self.ssn.sync)
+
+  def testSessionClose(self):
+    self.timeoutTest(self.ssn.close)
+
+  def testConnectionDetach(self):
+    self.timeoutTest(self.conn.detach)
+
+  def testConnectionClose(self):
+    self.timeoutTest(self.conn.close)
+
 ACK_QC = 'test-ack-queue; {create: always}'
 ACK_QD = 'test-ack-queue; {delete: always}'
 
-- 
1.5.5.6

From 9201b99100d8d47b3ed92573eea0e71969996418 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Fri, 25 Jun 2010 18:12:28 +0000
Subject: [PATCH] BZ-608118 added support for x-amqp-0-10.{app-id,content-encoding,routing-key}

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958055 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py         |    9 +++++++++
 qpid/python/qpid/tests/messaging/__init__.py |   14 ++++++++++----
 qpid/python/qpid/tests/messaging/message.py  |    4 +++-
 3 files changed, 22 insertions(+), 5 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index 6dab24d..ed6b602 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -1159,12 +1159,15 @@ class Engine:
       rt = addr2reply_to(msg.reply_to)
     else:
       rt = None
+    content_encoding = msg.properties.get("x-amqp-0-10.content-encoding")
     dp = DeliveryProperties(routing_key=rk)
     mp = MessageProperties(message_id=msg.id,
                            user_id=msg.user_id,
                            reply_to=rt,
                            correlation_id=msg.correlation_id,
+                           app_id = msg.properties.get("x-amqp-0-10.app-id"),
                            content_type=msg.content_type,
+                           content_encoding=content_encoding,
                            application_headers=msg.properties)
     if subject is not None:
       if mp.application_headers is None:
@@ -1242,6 +1245,12 @@ class Engine:
     msg.ttl = dp.ttl
     msg.redelivered = dp.redelivered
     msg.properties = mp.application_headers
+    if mp.app_id is not None:
+      msg.properties["x-amqp-0-10.app-id"] = mp.app_id
+    if mp.content_encoding is not None:
+      msg.properties["x-amqp-0-10.content-encoding"] = mp.content_encoding
+    if dp.routing_key is not None:
+      msg.properties["x-amqp-0-10.routing-key"] = dp.routing_key
     msg.content_type = mp.content_type
     msg._transfer_id = xfr.id
     return msg
diff --git a/qpid/python/qpid/tests/messaging/__init__.py b/qpid/python/qpid/tests/messaging/__init__.py
index 2c1dce9..a160f38 100644
--- a/qpid/python/qpid/tests/messaging/__init__.py
+++ b/qpid/python/qpid/tests/messaging/__init__.py
@@ -88,16 +88,22 @@ class Base(Test):
       self.assertEchos(expected, messages, redelivered)
     return messages
 
-  def diff(self, m1, m2):
+  def diff(self, m1, m2, excluded_properties=()):
     result = {}
     for attr in ("id", "subject", "user_id", "reply_to",
                  "correlation_id", "durable", "priority", "ttl",
-                 "redelivered", "properties", "content_type",
-                 "content"):
+                 "redelivered", "content_type", "content"):
       a1 = getattr(m1, attr)
       a2 = getattr(m2, attr)
       if a1 != a2:
         result[attr] = (a1, a2)
+    p1 = dict(m1.properties)
+    p2 = dict(m2.properties)
+    for ep in excluded_properties:
+      p1.pop(ep, None)
+      p2.pop(ep, None)
+    if p1 != p2:
+      result["properties"] = (p1, p2)
     return result
 
   def assertEcho(self, msg, echo, redelivered=False):
@@ -108,7 +114,7 @@ class Base(Test):
         echo = echo.content
         assert msg == echo, "expected %s, got %s" % (msg, echo)
     else:
-      delta = self.diff(msg, echo)
+      delta = self.diff(msg, echo, ("x-amqp-0-10.routing-key",))
       mttl, ettl = delta.pop("ttl", (0, 0))
       if redelivered:
         assert echo.redelivered, \
diff --git a/qpid/python/qpid/tests/messaging/message.py b/qpid/python/qpid/tests/messaging/message.py
index 2ca1fbf..91aab5f 100644
--- a/qpid/python/qpid/tests/messaging/message.py
+++ b/qpid/python/qpid/tests/messaging/message.py
@@ -85,7 +85,9 @@ class MessageEchoTests(Base):
               "key6": -3.14,
               "key7": ["one", 2, 3.14],
               "key8": [],
-              "key9": {"sub-key0": 3}}
+              "key9": {"sub-key0": 3},
+              "x-amqp-0-10.app-id": "test-app-id",
+              "x-amqp-0-10.content-encoding": "test-content-encoding"}
 
   def testMapContent(self):
     self.check(Message(MessageEchoTests.TEST_MAP))
-- 
1.5.5.6

From d5086ed9cd510ce9f1dc80da90315518d5c3ebd2 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Fri, 25 Jun 2010 18:26:14 +0000
Subject: [PATCH] BZ-608118 make sure we initialize properties even if application_headers is None

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958060 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index ed6b602..a732a60 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -1244,7 +1244,7 @@ class Engine:
     msg.priority = dp.priority
     msg.ttl = dp.ttl
     msg.redelivered = dp.redelivered
-    msg.properties = mp.application_headers
+    msg.properties = mp.application_headers or {}
     if mp.app_id is not None:
       msg.properties["x-amqp-0-10.app-id"] = mp.app_id
     if mp.content_encoding is not None:
-- 
1.5.5.6

From ee19a4688911a9fc55dea5f3176e99d6b77acafe Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Fri, 25 Jun 2010 18:57:59 +0000
Subject: [PATCH] BZ-569515 fix timeout tests to not leave queues lying around

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958077 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/tests/messaging/endpoints.py |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/python/qpid/tests/messaging/endpoints.py b/qpid/python/qpid/tests/messaging/endpoints.py
index b064d62..c01f16e 100644
--- a/qpid/python/qpid/tests/messaging/endpoints.py
+++ b/qpid/python/qpid/tests/messaging/endpoints.py
@@ -267,7 +267,7 @@ class TimeoutTests(Base):
     return self.ssn.sender("amq.topic")
 
   def setup_receiver(self):
-    return self.ssn.receiver("amq.topic")
+    return self.ssn.receiver("amq.topic; {link: {reliability: unreliable}}")
 
   def teardown_connection(self, conn):
     try:
-- 
1.5.5.6

From 1834e02e7dd0abd92d4bee09818f86f4fb6af89b Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Fri, 25 Jun 2010 19:06:05 +0000
Subject: [PATCH] BZ-607798 add uuid prefix to addresses beginning with hash(#)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958083 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/endpoints.py |    8 ++++++++
 1 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/qpid/python/qpid/messaging/endpoints.py b/qpid/python/qpid/messaging/endpoints.py
index 30f51fe..8bddc96 100644
--- a/qpid/python/qpid/messaging/endpoints.py
+++ b/qpid/python/qpid/messaging/endpoints.py
@@ -543,6 +543,7 @@ class Session:
     @rtype: Sender
     @return: a new Sender for the specified target
     """
+    target = _mangle(target)
     sender = Sender(self, self.next_sender_id, target, options)
     self.next_sender_id += 1
     self.senders.append(sender)
@@ -566,6 +567,7 @@ class Session:
     @rtype: Receiver
     @return: a new Receiver for the specified source
     """
+    source = _mangle(source)
     receiver = Receiver(self, self.next_receiver_id, source, options)
     self.next_receiver_id += 1
     self.receivers.append(receiver)
@@ -707,6 +709,12 @@ class Session:
     finally:
       self.connection._remove_session(self)
 
+def _mangle(addr):
+  if addr.startswith("#"):
+    return str(uuid4()) + addr
+  else:
+    return addr
+
 class Sender:
 
   """
-- 
1.5.5.6

From ab7384c897f2bf27147e9b985b4a9d80f7b0600c Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Fri, 25 Jun 2010 17:25:46 +0000
Subject: [PATCH] Bug 608118 - Fixed - New Messaging API lacks access to some 0-10 headers

QPID-2698: recognise special property names for amqp 0-10 specific message- and delivery- properties

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958044 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 1db44a2ebafe023b1adec5f6de140bfe6023c4a2)
---
 .../src/qpid/client/amqp0_10/IncomingMessages.cpp  |   19 ++++++++
 .../src/qpid/client/amqp0_10/OutgoingMessage.cpp   |   32 +++++++++++++-
 qpid/cpp/src/tests/MessagingFixture.h              |    5 ++
 qpid/cpp/src/tests/MessagingSessionTests.cpp       |   45 ++++++++++++++++++++
 4 files changed, 98 insertions(+), 3 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp b/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp
index 30cb634..2c00e6f 100644
--- a/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp
+++ b/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp
@@ -290,6 +290,10 @@ namespace {
 //TODO: unify conversion to and from 0-10 message that is currently
 //split between IncomingMessages and OutgoingMessage
 const std::string SUBJECT("qpid.subject");
+
+const std::string X_APP_ID("x-amqp-0-10.app-id");
+const std::string X_ROUTING_KEY("x-amqp-0-10.routing-key");
+const std::string X_CONTENT_ENCODING("x-amqp-0-10.content-encoding");
 }
 
 void populateHeaders(qpid::messaging::Message& message, 
@@ -312,6 +316,21 @@ void populateHeaders(qpid::messaging::Message& message,
         translate(messageProperties->getApplicationHeaders(), message.getProperties());
         message.setCorrelationId(messageProperties->getCorrelationId());
         message.setUserId(messageProperties->getUserId());
+        if (messageProperties->hasMessageId()) {
+            message.setMessageId(messageProperties->getMessageId().str());
+        }
+        //expose 0-10 specific items through special properties: 
+        //    app-id, content-encoding
+        if (messageProperties->hasAppId()) {
+            message.getProperties()[X_APP_ID] = messageProperties->getAppId();
+        }
+        if (messageProperties->hasContentEncoding()) {
+            message.getProperties()[X_CONTENT_ENCODING] = messageProperties->getContentEncoding();
+        }
+        //    routing-key, others?
+        if (deliveryProperties && deliveryProperties->hasRoutingKey()) {
+            message.getProperties()[X_ROUTING_KEY] = deliveryProperties->getRoutingKey();
+        }
     }
 }
 
diff --git a/qpid/cpp/src/qpid/client/amqp0_10/OutgoingMessage.cpp b/qpid/cpp/src/qpid/client/amqp0_10/OutgoingMessage.cpp
index c22eb54..8235896 100644
--- a/qpid/cpp/src/qpid/client/amqp0_10/OutgoingMessage.cpp
+++ b/qpid/cpp/src/qpid/client/amqp0_10/OutgoingMessage.cpp
@@ -21,10 +21,12 @@
 #include "qpid/client/amqp0_10/OutgoingMessage.h"
 #include "qpid/client/amqp0_10/AddressResolution.h"
 #include "qpid/amqp_0_10/Codecs.h"
+#include "qpid/types/Variant.h"
 #include "qpid/messaging/Address.h"
 #include "qpid/messaging/Message.h"
 #include "qpid/messaging/MessageImpl.h"
 #include "qpid/framing/enum.h"
+#include <sstream>
 
 namespace qpid {
 namespace client {
@@ -32,9 +34,19 @@ namespace amqp0_10 {
 
 using qpid::messaging::Address;
 using qpid::messaging::MessageImplAccess;
+using qpid::types::Variant;
 using namespace qpid::framing::message;
 using namespace qpid::amqp_0_10;
 
+namespace {
+//TODO: unify conversion to and from 0-10 message that is currently
+//split between IncomingMessages and OutgoingMessage
+const std::string SUBJECT("qpid.subject");
+const std::string X_APP_ID("x-amqp-0-10.app-id");
+const std::string X_ROUTING_KEY("x-amqp-0-10.routing-key");
+const std::string X_CONTENT_ENCODING("x-amqp-0-10.content-encoding");
+}
+
 void OutgoingMessage::convert(const qpid::messaging::Message& from)
 {
     //TODO: need to avoid copying as much as possible
@@ -55,10 +67,24 @@ void OutgoingMessage::convert(const qpid::messaging::Message& from)
         message.getDeliveryProperties().setRedelivered(true);
     }
     if (from.getPriority()) message.getDeliveryProperties().setPriority(from.getPriority());
-}
 
-namespace {
-const std::string SUBJECT("qpid.subject");
+    //allow certain 0-10 specific items to be set through special properties: 
+    //    message-id, app-id, content-encoding
+    if (from.getMessageId().size()) {
+        qpid::framing::Uuid uuid;
+        std::istringstream data(from.getMessageId());
+        data >> uuid;
+        message.getMessageProperties().setMessageId(uuid);
+    }
+    Variant::Map::const_iterator i;
+    i = from.getProperties().find(X_APP_ID);
+    if (i != from.getProperties().end()) {
+        message.getMessageProperties().setAppId(i->second.asString());
+    }
+    i = from.getProperties().find(X_CONTENT_ENCODING);
+    if (i != from.getProperties().end()) {
+        message.getMessageProperties().setContentEncoding(i->second.asString());
+    }
 }
 
 void OutgoingMessage::setSubject(const std::string& subject)
diff --git a/qpid/cpp/src/tests/MessagingFixture.h b/qpid/cpp/src/tests/MessagingFixture.h
index 5546b4e..c8ae86d 100644
--- a/qpid/cpp/src/tests/MessagingFixture.h
+++ b/qpid/cpp/src/tests/MessagingFixture.h
@@ -79,6 +79,11 @@ struct BrokerAdmin
         return !result.getNotFound();
     }
 
+    void send(qpid::client::Message& message, const std::string& exchange=std::string())
+    {
+        session.messageTransfer(qpid::client::arg::destination=exchange, qpid::client::arg::content=message);
+    }
+
     ~BrokerAdmin()
     {
         session.close();
diff --git a/qpid/cpp/src/tests/MessagingSessionTests.cpp b/qpid/cpp/src/tests/MessagingSessionTests.cpp
index 375af73..6fee123 100644
--- a/qpid/cpp/src/tests/MessagingSessionTests.cpp
+++ b/qpid/cpp/src/tests/MessagingSessionTests.cpp
@@ -712,6 +712,51 @@ QPID_AUTO_TEST_CASE(testOptionVerification)
     BOOST_CHECK_THROW(fix.session.createReceiver("my-queue; {invalid-option:blah}"), qpid::messaging::AddressError);    
 }
 
+QPID_AUTO_TEST_CASE(testReceiveSpecialProperties)
+{
+    QueueFixture fix;
+
+    qpid::client::Message out;
+    out.getDeliveryProperties().setRoutingKey(fix.queue);
+    out.getMessageProperties().setAppId("my-app-id");
+    out.getMessageProperties().setMessageId(qpid::framing::Uuid(true));
+    out.getMessageProperties().setContentEncoding("my-content-encoding");
+    fix.admin.send(out);
+
+    Receiver receiver = fix.session.createReceiver(fix.queue);
+    Message in = receiver.fetch(Duration::SECOND * 5);
+    BOOST_CHECK_EQUAL(in.getProperties()["x-amqp-0-10.routing-key"].asString(), out.getDeliveryProperties().getRoutingKey());
+    BOOST_CHECK_EQUAL(in.getProperties()["x-amqp-0-10.app-id"].asString(), out.getMessageProperties().getAppId());
+    BOOST_CHECK_EQUAL(in.getProperties()["x-amqp-0-10.content-encoding"].asString(), out.getMessageProperties().getContentEncoding());
+    BOOST_CHECK_EQUAL(in.getMessageId(), out.getMessageProperties().getMessageId().str());
+    fix.session.acknowledge(true);
+}
+
+QPID_AUTO_TEST_CASE(testSendSpecialProperties)
+{
+    QueueFixture fix;
+    Sender sender = fix.session.createSender(fix.queue);
+    Message out("test-message");
+    std::string appId = "my-app-id";
+    std::string contentEncoding = "my-content-encoding";
+    out.getProperties()["x-amqp-0-10.app-id"] = appId;
+    out.getProperties()["x-amqp-0-10.content-encoding"] = contentEncoding;
+    out.setMessageId(qpid::framing::Uuid(true).str());
+    sender.send(out, true);
+
+    qpid::client::LocalQueue q;
+    qpid::client::SubscriptionManager subs(fix.admin.session);
+    qpid::client::Subscription s = subs.subscribe(q, fix.queue);
+    qpid::client::Message in = q.get();
+    s.cancel();
+    fix.admin.session.sync();
+
+    BOOST_CHECK_EQUAL(in.getMessageProperties().getAppId(), appId);
+    BOOST_CHECK_EQUAL(in.getMessageProperties().getContentEncoding(), contentEncoding);
+    BOOST_CHECK_EQUAL(in.getMessageProperties().getMessageId().str(), out.getMessageId());
+}
+
+
 QPID_AUTO_TEST_SUITE_END()
 
 }} // namespace qpid::tests
-- 
1.5.5.6

From dcc6c20a11f1dffac6708a128517757e7b1e0324 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Mon, 28 Jun 2010 11:35:59 +0000
Subject: [PATCH] BZ-607798 fix mangling for addresses that are None

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958547 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/endpoints.py |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/python/qpid/messaging/endpoints.py b/qpid/python/qpid/messaging/endpoints.py
index 8bddc96..62423ca 100644
--- a/qpid/python/qpid/messaging/endpoints.py
+++ b/qpid/python/qpid/messaging/endpoints.py
@@ -710,7 +710,7 @@ class Session:
       self.connection._remove_session(self)
 
 def _mangle(addr):
-  if addr.startswith("#"):
+  if addr and addr.startswith("#"):
     return str(uuid4()) + addr
   else:
     return addr
-- 
1.5.5.6

From 8a7446059bd03eed784ec7f81815e4adab972fdb Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Tue, 15 Jun 2010 17:51:10 +0000
Subject: [PATCH] QPID-2589 - Patch from Chuck Rolke
 More API cleanup and new examples (to match the examples for other languages)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954983 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit fa677aa82da3ee0fa654372d998563d8d652a787)
---
 .../csharp.direct.receiver.cs                      |   47 ++---
 .../csharp.direct.receiver.csproj                  |    4 +-
 .../csharp.direct.sender/csharp.direct.sender.cs   |   42 +++--
 .../csharp.direct.sender.csproj                    |    4 +-
 .../Properties/AssemblyInfo.cs                     |   36 ++++
 .../csharp.example.client/csharp.example.client.cs |   70 +++++++
 .../csharp.example.client.csproj                   |   81 +++++++++
 .../Properties/AssemblyInfo.cs                     |   36 ++++
 .../csharp.example.declare_queues.cs               |   61 +++++++
 .../csharp.example.declare_queues.csproj           |   81 +++++++++
 .../examples/csharp.example.drain/Options.cs       |  181 +++++++++++++++++++
 .../Properties/AssemblyInfo.cs                     |   36 ++++
 .../csharp.example.drain/csharp.example.drain.cs   |   85 +++++++++
 .../csharp.example.drain.csproj                    |   82 +++++++++
 .../Properties/AssemblyInfo.cs                     |   36 ++++
 .../csharp.example.server/csharp.example.server.cs |   61 +++++++
 .../csharp.example.server.csproj                   |   81 +++++++++
 .../examples/csharp.example.spout/Options.cs       |  189 ++++++++++++++++++++
 .../Properties/AssemblyInfo.cs                     |   36 ++++
 .../csharp.example.spout/csharp.example.spout.cs   |  117 ++++++++++++
 .../csharp.example.spout.csproj                    |   82 +++++++++
 .../csharp.map.callback.receiver.csproj            |    4 +-
 .../csharp.map.callback.sender.cs                  |   41 ++++-
 .../csharp.map.callback.sender.csproj              |    4 +-
 .../csharp.map.receiver/csharp.map.receiver.csproj |    4 +-
 .../csharp.map.receiver/csharp.map.recevier.cs     |   11 +-
 .../csharp.map.sender/csharp.map.sender.cs         |   47 +++++-
 .../csharp.map.sender/csharp.map.sender.csproj     |    4 +-
 .../qpid/dotnet/org.apache.qpid.messaging.sln      |   93 ++++++++++-
 qpid/cpp/bindings/qpid/dotnet/src/Message.cpp      |  146 ++++++++++++++--
 qpid/cpp/bindings/qpid/dotnet/src/Message.h        |   22 ++-
 qpid/cpp/bindings/qpid/dotnet/src/Session.cpp      |  102 +++++++++++-
 qpid/cpp/bindings/qpid/dotnet/src/Session.h        |    6 +-
 ...rg.apache.qpid.messaging.sessionreceiver.csproj |    4 +-
 .../dotnet/test/messaging.test/messaging.test.cs   |   31 ++++
 .../test/messaging.test/messaging.test.csproj      |    4 +-
 36 files changed, 1879 insertions(+), 92 deletions(-)
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Options.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Options.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.csproj

diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
index 98531eb..af0b398 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
@@ -32,6 +32,7 @@ namespace CSharpDirect
         // Direct receiver example
         //
         // Receive 10 messages from localhost:5672, amq.direct/key
+        // Messages are assumed to be printable strings.
         //
         static void Main(string[] args)
         {
@@ -52,39 +53,27 @@ namespace CSharpDirect
             Console.WriteLine("nMsg : {0}", nMsg);
             Console.WriteLine();
 
-            Connection conn = new Connection(host);
-
-            conn.Open();
-
-            if (!conn.IsOpen())
-            {
-                Console.WriteLine("Failed to open connection to host : {0}", host);
-            }
-            else
+            Connection connection = null;
+            try
             {
-
-                Session sess = conn.CreateSession();
-
-                Duration dura = new Duration(3600000); // wait forever
-
-                Receiver rcv = sess.CreateReceiver(addr);
-
-                Message msg = new Message("");
-
-                for (int i = 0; i < nMsg; i++)
-                {
-                    try
-                    {
-                        Message msg2 = rcv.Fetch(dura);
+                connection = new Connection(host);
+                connection.Open();
+                if (!connection.IsOpen()) {
+                    Console.WriteLine("Failed to open connection to host : {0}", host);
+                } else {
+                    Session session = connection.CreateSession();
+                    Receiver receiver = session.CreateReceiver(addr);
+                    Message message = new Message("");
+                    for (int i = 0; i < nMsg; i++) {
+                        Message msg2 = receiver.Fetch(DurationConstants.FORVER);
                         Console.WriteLine("Rcvd msg {0} : {1}", i, msg2.GetContent());
                     }
-                    catch (Exception e)
-                    {
-                        Console.WriteLine("Exception {0}.", e);
-                    }
+                    connection.Close();
                 }
-
-                conn.Close();
+            } catch (Exception e) {
+                Console.WriteLine("Exception {0}.", e);
+                if (null != connection)
+                    connection.Close();
             }
         }
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
index 96b4540..172e25a 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{52F880E7-D677-4C91-8516-D679CE0F46A8}</ProjectGuid>
     <OutputType>Exe</OutputType>
@@ -67,7 +67,7 @@
   <ItemGroup>
     <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
   </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
index 71ab75c..b287af2 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
@@ -29,6 +29,11 @@ namespace csharp.direct.sender
 {
     class Program
     {
+        // Direct sender example
+        //
+        // Send 10 messages from localhost:5672, amq.direct/key
+        // Messages are assumed to be printable strings.
+        //
         static void Main(string[] args)
         {
             String host = "localhost:5672";
@@ -48,28 +53,27 @@ namespace csharp.direct.sender
             Console.WriteLine("nMsg : {0}", nMsg);
             Console.WriteLine();
 
-            Connection conn = new Connection(host);
-
-            conn.Open();
-
-            if (!conn.IsOpen())
-            {
-                Console.WriteLine("Failed to open connection to host : {0}", host);
-            }
-            else
+            Connection connection = null;
+            try
             {
-                Session sess = conn.CreateSession();
+                connection = new Connection(host);
+                connection.Open();
 
-                Sender snd = sess.CreateSender(addr);
-
-                for (int i = 0; i < nMsg; i++)
-                {
-                    Message msg = new Message(String.Format("Test Message {0}", i));
-
-                    snd.Send(msg);
+                if (!connection.IsOpen()) {
+                    Console.WriteLine("Failed to open connection to host : {0}", host);
+                } else {
+                    Session session = connection.CreateSession();
+                    Sender sender = session.CreateSender(addr);
+                    for (int i = 0; i < nMsg; i++) {
+                        Message message = new Message(String.Format("Test Message {0}", i));
+                        sender.Send(message);
+                    }
+                    connection.Close();
                 }
-
-                conn.Close();
+            } catch (Exception e) {
+                Console.WriteLine("Exception {0}.", e);
+                if (null != connection)
+                    connection.Close();
             }
         }
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
index 4543222..8e8371c 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}</ProjectGuid>
     <OutputType>Exe</OutputType>
@@ -67,7 +67,7 @@
   <ItemGroup>
     <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
   </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..95433e4
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/Properties/AssemblyInfo.cs
@@ -0,0 +1,36 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.direct.receiver")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.direct.receiver")]
+[assembly: AssemblyCopyright("Copyright ?  2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("c60b17ab-a82c-4edf-ba95-1e88bd4c3e75")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs
new file mode 100644
index 0000000..93459b6
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs
@@ -0,0 +1,70 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using Org.Apache.Qpid.Messaging;
+
+namespace Org.Apache.Qpid.Messaging.Examples {
+    class Client {
+        static void Main(string[] args) {
+            String url = "amqp:tcp:127.0.0.1:5672";
+
+            if (args.Length > 0)
+                url = args[0];
+
+            Connection connection = new Connection(url);
+            try
+            {
+                connection.Open();
+
+                Session session = connection.CreateSession();
+
+                Sender sender = session.CreateSender("service_queue");
+
+                Address responseQueue = new Address("#response-queue; {create:always, delete:always}");
+                Receiver receiver = session.CreateReceiver(responseQueue);
+
+                String[] s = new String[] {
+                    "Twas brillig, and the slithy toves",
+                    "Did gire and gymble in the wabe.",
+                    "All mimsy were the borogroves,",
+                    "And the mome raths outgrabe."
+                };
+
+                Message request = new Message("");
+                request.SetReplyTo(responseQueue);
+
+                for (int i = 0; i < s.Length; i++) {
+                    request.SetContent(s[i]);
+                    sender.Send(request);
+                    Message response = receiver.Fetch();
+                    Console.WriteLine("{0} -> {1}", request.GetContent(), response.GetContent());
+                }
+                connection.Close();
+            }
+            catch (Exception e)
+            {
+                Console.WriteLine("Exception {0}.", e);
+                connection.Close();
+            }
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.csproj
new file mode 100644
index 0000000..76fb1c5
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.csproj
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{0DE01712-C2D1-4CA4-B42C-5856456A8696}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.example.client</RootNamespace>
+    <AssemblyName>csharp.example.client</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.example.client.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>Org.Apache.Qpid.Messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..95433e4
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/Properties/AssemblyInfo.cs
@@ -0,0 +1,36 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.direct.receiver")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.direct.receiver")]
+[assembly: AssemblyCopyright("Copyright ?  2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("c60b17ab-a82c-4edf-ba95-1e88bd4c3e75")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.cs
new file mode 100644
index 0000000..7f116f1
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.cs
@@ -0,0 +1,61 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using Org.Apache.Qpid.Messaging;
+
+namespace Org.Apache.Qpid.Messaging.Examples {
+    class DeclareQueues {
+        //
+        // Sample invocation: csharp.example.declare_queues.exe localhost:5672 my-queue
+        //
+        static void Main(string[] args) {
+            string addr = "localhost:5672";
+            string queue = "my-queue";
+
+            if (args.Length > 0)
+                addr = args[0];
+            if (args.Length > 1)
+                queue = args[1];
+
+            Connection connection = null;
+            try
+            {
+                connection = new Connection(addr);
+                connection.Open();
+                Session session = connection.CreateSession();
+                String queueName = queue + "; {create: always}";
+                Sender sender = session.CreateSender(queueName);
+                session.Close();
+                connection.Close();
+            }
+            catch (Exception e)
+            {
+                Console.WriteLine("Exception {0}.", e);
+                if (null != connection)
+                    connection.Close();
+            }
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.csproj
new file mode 100644
index 0000000..fb7e950
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.csproj
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{E31B349C-830C-4583-8BD9-30DA4398349F}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.example.declare_queues</RootNamespace>
+    <AssemblyName>csharp.example.declare_queues</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.example.declare_queues.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>Org.Apache.Qpid.Messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Options.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Options.cs
new file mode 100644
index 0000000..808e227
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Options.cs
@@ -0,0 +1,181 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+namespace Org.Apache.Qpid.Messaging.Examples
+{
+    using System;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.Diagnostics;
+    using System.IO;
+    using System.Text;
+    using System.Xml;
+
+    public class Options
+    {
+        private string url;
+        private string address;
+        private UInt64 timeout;
+        private int count;
+        private string id;
+        private string replyTo;
+        //private string[] properties;
+        //private string[] entries;
+        private string content;
+        private string connectionOptions;
+        private bool forever;
+
+        public Options(string[] args)
+        {
+            this.url = "amqp:tcp:127.0.0.1:5672";
+            this.address = "";
+            this.timeout = 0;
+            this.count = 1;
+            this.id = "";
+            this.replyTo = "";
+            this.content = "";
+            this.connectionOptions = "";
+            this.forever = false;
+            Parse(args);
+        }
+
+        private void Parse(string[] args)
+        {
+            int argCount = args.Length;
+            int current = 0;
+
+            while ((current + 1) < argCount)
+            {
+                string arg = args[current];
+                if (arg == "--broker")
+                {
+                    this.url = args[++current];
+                }
+                else if (arg == "--address")
+                {
+                    this.address = args[++current];
+                }
+                else if (arg == "--timeout")
+                {
+                    arg = args[++current];
+                    UInt64 i = UInt64.Parse(arg);
+                    if (i >= 0)
+                    {
+                        this.timeout = i;
+                    }
+                }
+                else if (arg == "--count")
+                {
+                    arg = args[++current];
+                    int i = int.Parse(arg);
+                    if (i >= 0)
+                    {
+                        this.count = i;
+                    }
+                }
+                else if (arg == "--id")
+                {
+                    this.id = args[++current];
+                }
+                else if (arg == "--reply-to")
+                {
+                    this.replyTo = args[++current];
+                }
+                else if (arg == "--properties")
+                {
+                    throw new ArgumentException("TODO: properties not implemented");
+                }
+                else if (arg == "--entries")
+                {
+                    throw new ArgumentException("TODO: entries not implemented");
+                }
+                else if (arg == "--content")
+                {
+                    this.content = args[++current];
+                }
+                else if (arg == "--connection-options")
+                {
+                    this.connectionOptions = args[++current];
+                }
+                else if (arg == "--forever")
+                {
+                    this.forever = true;
+                }
+                else
+                {
+                    throw new ArgumentException(String.Format("unknown argument \"{0}\"", arg));
+                }
+
+                current++;
+            }
+
+            if (current == argCount)
+            {
+                throw new ArgumentException("missing argument: address");
+            }
+
+            address = args[current];
+        }
+
+        public string Url
+        {
+            get { return this.url; }
+        }
+
+        public string Address
+        {
+            get { return this.address; }
+        }
+
+        public UInt64 Timeout
+        {
+            get { return this.timeout; }
+        }
+
+        public int Count
+        {
+            get { return this.count; }
+        }
+
+        public string Id
+        {
+            get { return this.id; }
+        }
+
+        public string ReplyTo
+        {
+            get { return this.replyTo; }
+        }
+
+        public string Content
+        {
+            get { return content; }
+        }
+
+        public string ConnectionOptions
+        {
+            get { return this.connectionOptions; }
+        }
+
+        public bool Forever
+        {
+            get { return this.forever; }
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..95433e4
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Properties/AssemblyInfo.cs
@@ -0,0 +1,36 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.direct.receiver")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.direct.receiver")]
+[assembly: AssemblyCopyright("Copyright ?  2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("c60b17ab-a82c-4edf-ba95-1e88bd4c3e75")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs
new file mode 100644
index 0000000..6740e6a
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs
@@ -0,0 +1,85 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using Org.Apache.Qpid.Messaging;
+
+namespace Org.Apache.Qpid.Messaging.Examples {
+    class Drain {
+        //
+        // Sample invocation: csharp.example.drain.exe --broker localhost:5672 --timeout 30 my-queue
+        //
+        static void Main(string[] args) {
+            Options options = new Options(args);
+
+            Connection connection = null;
+            try
+            {
+                connection = new Connection(options.Url, options.ConnectionOptions);
+                connection.Open();
+                Session session = connection.CreateSession();
+                Receiver receiver = session.CreateReceiver(options.Address);
+                Duration timeout = options.Forever ? 
+                                   DurationConstants.FORVER : 
+                                   DurationConstants.SECOND * options.Timeout;
+                Message message = new Message();
+                while (receiver.Fetch(message, timeout))
+                {
+                    Dictionary<string, object> properties = new Dictionary<string, object>();
+                    properties = message.GetProperties();
+                    Console.Write("Message(properties={0}, content='", 
+                                  message.MapAsString(properties));
+
+                    if ("amqp/map" == message.GetContentType())
+                    {
+                        Dictionary<string, object> content = new Dictionary<string, object>();
+                        message.GetContent(content);
+                        Console.Write(message.MapAsString(content));
+                    }
+                    else if ("amqp/list" == message.GetContentType())
+                    {
+                        Collection<object> content = new Collection<object>();
+                        message.GetContent(content);
+                        Console.Write(message.ListAsString(content));
+                    }
+                    else
+                    {
+                        Console.Write(message.GetContent());
+                    }
+                    Console.WriteLine("')");
+                    session.Acknowledge();
+                }
+                receiver.Close();
+                session.Close();
+                connection.Close();
+            }
+            catch (Exception e)
+            {
+                Console.WriteLine("Exception {0}.", e);
+                if (null != connection)
+                    connection.Close();
+            }
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.csproj
new file mode 100644
index 0000000..198900c
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.csproj
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{C43DEB69-8088-420B-B0CA-C699535E6D08}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.example.drain</RootNamespace>
+    <AssemblyName>csharp.example.drain</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.example.drain.cs" />
+    <Compile Include="Options.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>Org.Apache.Qpid.Messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..95433e4
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/Properties/AssemblyInfo.cs
@@ -0,0 +1,36 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.direct.receiver")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.direct.receiver")]
+[assembly: AssemblyCopyright("Copyright ?  2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("c60b17ab-a82c-4edf-ba95-1e88bd4c3e75")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs
new file mode 100644
index 0000000..af01e4b
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs
@@ -0,0 +1,61 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using Org.Apache.Qpid.Messaging;
+
+namespace Org.Apache.Qpid.Messaging.Examples {
+    class Server {
+        static void Main(string[] args) {
+            String url = "amqp:tcp:127.0.0.1:5672";
+
+            if (args.Length > 0)
+                url = args[0];
+
+            try {
+                Connection connection = new Connection(url);
+                connection.Open();
+                Session session = connection.CreateSession();
+                Receiver receiver = session.CreateReceiver("service_queue; {create: always}");
+
+                while (true) {
+                    Message request = receiver.Fetch();
+                    Address address = request.GetReplyTo();
+
+                    if (null != address) {
+                        Sender sender = session.CreateSender(address);
+                        String s = request.GetContent();
+                        Message response = new Message(s.ToUpper());
+                        sender.Send(response);
+                        Console.WriteLine("Processed request: {0} -> {1}", request.GetContent(), response.GetContent());
+                        session.Acknowledge();
+                    } else {
+                        Console.WriteLine("Error: no reply address specified for request: {0}", request.GetContent());
+                        session.Reject(request);
+                    }
+                }
+                // connection.Close();  // unreachable in this example
+            } catch (Exception e) {
+                Console.WriteLine("Exception {0}.", e);
+            }
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.csproj
new file mode 100644
index 0000000..1fa2cc0
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.csproj
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{090A081D-E8B5-4949-AA43-EE182B7101E3}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.example.server</RootNamespace>
+    <AssemblyName>csharp.example.server</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.example.server.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>Org.Apache.Qpid.Messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Options.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Options.cs
new file mode 100644
index 0000000..be55c1e
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Options.cs
@@ -0,0 +1,189 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+namespace Org.Apache.Qpid.Messaging.Examples
+{
+    using System;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.Collections.ObjectModel;
+    using System.Diagnostics;
+    using System.IO;
+    using System.Text;
+    using System.Xml;
+
+    public class Options
+    {
+        private string url;
+        private string address;
+        private int timeout;
+        private int count;
+        private string id;
+        private string replyTo;
+        private Collection<string> properties;
+        private Collection<string> entries;
+        private string content;
+        private string connectionOptions;
+        private bool forever;
+
+        public Options(string[] args)
+        {
+            this.url = "amqp:tcp:127.0.0.1:5672";
+            this.address = "";
+            this.timeout = 0;
+            this.count = 1;
+            this.id = "";
+            this.replyTo = "";
+            properties = new Collection<string>();
+            entries = new Collection<string>();
+            this.content = "";
+            this.connectionOptions = "";
+            this.forever = false;
+            Parse(args);
+        }
+
+        private void Parse(string[] args)
+        {
+            int argCount = args.Length;
+            int current = 0;
+
+            while ((current + 1) < argCount)
+            {
+                string arg = args[current];
+                if (arg == "--broker")
+                {
+                    this.url = args[++current];
+                }
+                else if (arg == "--address")
+                {
+                    this.address = args[++current];
+                }
+                else if (arg == "--timeout")
+                {
+                    arg = args[++current];
+                    int i = int.Parse(arg);
+                    if (i >= 0)
+                    {
+                        this.timeout = i;
+                    }
+                }
+                else if (arg == "--count")
+                {
+                    arg = args[++current];
+                    int i = int.Parse(arg);
+                    if (i >= 0)
+                    {
+                        this.count = i;
+                    }
+                }
+                else if (arg == "--id")
+                {
+                    this.id = args[++current];
+                }
+                else if (arg == "--reply-to")
+                {
+                    this.replyTo = args[++current];
+                }
+                else if (arg == "--properties")
+                {
+                    this.properties.Add(args[++current]);
+                }
+                else if (arg == "--map")
+                {
+                    this.entries.Add(args[++current]);
+                }
+                else if (arg == "--content")
+                {
+                    this.content = args[++current];
+                }
+                else if (arg == "--connection-options")
+                {
+                    this.connectionOptions = args[++current];
+                }
+                else if (arg == "--forever")
+                {
+                    this.forever = true;
+                }
+                else
+                {
+                    throw new ArgumentException(String.Format("unknown argument \"{0}\"", arg));
+                }
+
+                current++;
+            }
+
+            if (current == argCount)
+            {
+                throw new ArgumentException("missing argument: address");
+            }
+
+            address = args[current];
+        }
+
+        public string Url
+        {
+            get { return this.url; }
+        }
+
+        public string Address
+        {
+            get { return this.address; }
+        }
+
+        public int Timeout
+        {
+            get { return this.timeout; }
+        }
+
+        public int Count
+        {
+            get { return this.count; }
+        }
+
+        public string Id
+        {
+            get { return this.id; }
+        }
+
+        public string ReplyTo
+        {
+            get { return this.replyTo; }
+        }
+
+        public Collection<string> Entries
+        {
+            get { return this.entries; }
+        }
+
+        public string Content
+        {
+            get { return content; }
+        }
+
+        public string ConnectionOptions
+        {
+            get { return this.connectionOptions; }
+        }
+
+        public bool Forever
+        {
+            get { return this.forever; }
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..95433e4
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Properties/AssemblyInfo.cs
@@ -0,0 +1,36 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.direct.receiver")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.direct.receiver")]
+[assembly: AssemblyCopyright("Copyright ?  2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("c60b17ab-a82c-4edf-ba95-1e88bd4c3e75")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs
new file mode 100644
index 0000000..7eeece3
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs
@@ -0,0 +1,117 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using System.Diagnostics;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using Org.Apache.Qpid.Messaging;
+
+namespace Org.Apache.Qpid.Messaging.Examples {
+    class Spout {
+        //
+        // Sample invocation: csharp.example.drain.exe --broker localhost:5672 --timeout 30 my-queue
+        // This pro
+        static bool NameVal(string In, out string nameOut, out string valueOut)
+        {
+            int pos = In.IndexOf("=");
+            if (-1 == pos) {
+                nameOut = In;
+                valueOut = "";
+                return false;
+            } else {
+                nameOut = In.Substring(0, pos);
+                if (pos + 1 < In.Length) {
+                    valueOut = In.Substring(pos + 1);
+                    return true;
+                } else {
+                    valueOut = "";
+                    return false;
+                }
+            }
+        }
+
+        static void SetEntries(Collection<string> entries, Dictionary<string, object> content)
+        {
+            foreach (String entry in entries)
+            {
+                string name = "";
+                string value = "";
+                if (NameVal(entry, out name, out value))
+                    content.Add(name, value);
+                else
+                    content.Add(name, "");
+            }
+        }
+
+        static void Main(string[] args) {
+            Options options = new Options(args);
+
+            Connection connection = null;
+            try
+            {
+                connection = new Connection(options.Url);
+                connection.Open();
+                Session session = connection.CreateSession();
+                Sender sender = session.CreateSender(options.Address);
+                Message message;
+                if (options.Entries.Count > 0)
+                {
+                    Dictionary<string, object> content = new Dictionary<string, object>();
+                    SetEntries(options.Entries, content);
+                    message = new Message(content);
+                }
+                else
+                {
+                    message = new Message(options.Content);
+                    message.SetContentType("text/plain");
+                }
+                Address replyToAddr = new Address(options.ReplyTo);
+
+                Stopwatch stopwatch = new Stopwatch();
+                TimeSpan timespan = new TimeSpan(0,0,options.Timeout);
+                stopwatch.Start();
+                for (int count = 0;
+                    (0 == options.Count || count < options.Count) &&
+                    (0 == options.Timeout || stopwatch.Elapsed <= timespan);
+                    count++) 
+                {
+                    if ("" != options.ReplyTo) message.SetReplyTo(replyToAddr);
+                    string id = options.Id ;
+                    if ("" == id) {
+                        Guid g = Guid.NewGuid();
+                        id = g.ToString();
+                    }
+                    string spoutid = id + ":" + count;
+                    message.SetProperty("spout-id", spoutid);
+                    sender.Send(message);
+                }
+                connection.Close();
+            } catch (Exception e) {
+                Console.WriteLine("Exception {0}.", e);
+                if (null != connection)
+                    connection.Close();
+            }
+        }
+    }
+}
+
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.csproj
new file mode 100644
index 0000000..15fc644
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.csproj
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{EB36626D-36C2-41B3-B65E-762BAF27F137}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.example.spout</RootNamespace>
+    <AssemblyName>csharp.example.spout</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.example.spout.cs" />
+    <Compile Include="Options.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>Org.Apache.Qpid.Messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
index 24b5cd4..c32574a 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{68A43817-2358-4A31-8FDF-FE21722BFBCF}</ProjectGuid>
     <OutputType>Exe</OutputType>
@@ -67,7 +67,7 @@
   <ItemGroup>
     <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
     <ProjectReference Include="..\..\src\sessionreceiver\org.apache.qpid.messaging.sessionreceiver.csproj">
       <Project>{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
index 761ac0a..2b17052 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
@@ -100,20 +100,55 @@ namespace Org.Apache.Qpid.Messaging.Examples
             Dictionary<string, object> subMap = new Dictionary<string, object>();
             Collection<object> colors = new Collection<object>();
 
+            // add simple types
             content["id"] = 987654321;
             content["name"] = "Widget";
             content["percent"] = 0.99;
 
+            // add nested amqp/map
             subMap["name"] = "Smith";
             subMap["number"] = 354;
+            content["nestedMap"] = subMap;
 
-            content["nested"] = subMap;
-
+            // add an amqp/list
             colors.Add("red");
             colors.Add("green");
             colors.Add("white");
+            content["colorsList"] = colors;
+
+            // add one of each supported amqp data type
+            bool mybool = true;
+            content["mybool"] = mybool;
+
+            byte mybyte = 4;
+            content["mybyte"] = mybyte;
+
+            UInt16 myUInt16 = 5;
+            content["myUInt16"] = myUInt16;
+
+            UInt32 myUInt32 = 6;
+            content["myUInt32"] = myUInt32;
+
+            UInt64 myUInt64 = 7;
+            content["myUInt64"] = myUInt64;
+
+            char mychar = 'h';
+            content["mychar"] = mychar;
+
+            Int16 myInt16 = 9;
+            content["myInt16"] = myInt16;
+
+            Int32 myInt32 = 10;
+            content["myInt32"] = myInt32;
+
+            Int64 myInt64 = 11;
+            content["myInt64"] = myInt64;
+
+            Single mySingle = (Single)12.12;
+            content["mySingle"] = mySingle;
 
-            content["colors"] = colors;
+            Double myDouble = 13.13;
+            content["myDouble"] = myDouble;
 
             //
             // Construct a message with the map content and send it synchronously
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
index 26f2c5b..1f37ce8 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{12F1C14F-5C7D-4075-9BAE-C091394FF99A}</ProjectGuid>
     <OutputType>Exe</OutputType>
@@ -69,7 +69,7 @@
   <ItemGroup>
     <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
   </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
index 06017fb..c3d87ee 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}</ProjectGuid>
     <OutputType>Exe</OutputType>
@@ -67,7 +67,7 @@
   <ItemGroup>
     <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
     <ProjectReference Include="..\..\src\sessionreceiver\org.apache.qpid.messaging.sessionreceiver.csproj">
       <Project>{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
index 41ed9f3..242944b 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
@@ -27,6 +27,11 @@ namespace Org.Apache.Qpid.Messaging.examples
 {
     class MapReceiver
     {
+        // csharp.map.receiver example
+        //
+        // Send an amqp/map message to amqp:tcp:localhost:5672 amq.direct/map_example
+        // The map message 
+        //
         static void Main(string[] args)
         {
             string url = "amqp:tcp:localhost:5672";
@@ -47,16 +52,16 @@ namespace Org.Apache.Qpid.Messaging.examples
             Receiver receiver = session.CreateReceiver("amq.direct/map_example");
 
             //
-            // Fetch the message from the broker (wait indefinitely by default)
+            // Fetch the message from the broker
             //
-            Message message = receiver.Fetch(new Duration(60000));
+            Message message = receiver.Fetch(DurationConstants.MINUTE);
 
             //
             // Extract the structured content from the message.
             //
             Dictionary<string, object> content = new Dictionary<string, object>();
             message.GetContent(content);
-            Console.WriteLine("Received: {0}", content);
+            Console.WriteLine("Received: {0}", message.AsString(content));
 
             //
             // Acknowledge the receipt of all received messages.
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
index d1ccc65..5517226 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
@@ -30,6 +30,12 @@ namespace Org.Apache.Qpid.Messaging.examples
 {
     class MapSender
     {
+        // csharp.map.sender example
+        //
+        // Send an amqp/map message to amqp:tcp:localhost:5672 amq.direct/map_example
+        // The map message contains simple types, a nested amqp/map,
+        // an ampq/list, and specific instances of each supported type.
+        //
         static void Main(string[] args)
         {
             string url = "amqp:tcp:localhost:5672";
@@ -57,20 +63,55 @@ namespace Org.Apache.Qpid.Messaging.examples
             Dictionary<string, object> subMap = new Dictionary<string, object>();
             Collection<object> colors = new Collection<object>();
 
+            // add simple types
             content["id"] = 987654321;
             content["name"] = "Widget";
             content["percent"] = 0.99;
 
+            // add nested amqp/map
             subMap["name"] = "Smith";
             subMap["number"] = 354;
+            content["nestedMap"] = subMap;
 
-            content["nested"] = subMap;
-
+            // add an amqp/list
             colors.Add("red");
             colors.Add("green");
             colors.Add("white");
+            content["colorsList"] = colors;
+
+            // add one of each supported amqp data type
+            bool mybool = true;
+            content["mybool"] = mybool;
+
+            byte mybyte = 4;
+            content["mybyte"] = mybyte;
+
+            UInt16 myUInt16 = 5 ;
+            content["myUInt16"] = myUInt16;
+
+            UInt32 myUInt32 = 6;
+            content["myUInt32"] = myUInt32;
+
+            UInt64 myUInt64 = 7;
+            content["myUInt64"] = myUInt64;
+
+            char mychar = 'h';
+            content["mychar"] = mychar;
+
+            Int16 myInt16 = 9;
+            content["myInt16"] = myInt16;
+
+            Int32 myInt32 = 10;
+            content["myInt32"] = myInt32;
+
+            Int64 myInt64 = 11;
+            content["myInt64"] = myInt64;
+
+            Single mySingle = (Single)12.12;
+            content["mySingle"] = mySingle;
 
-            content["colors"] = colors;
+            Double myDouble = 13.13;
+            content["myDouble"] = myDouble;
 
             //
             // Construct a message with the map content and send it synchronously
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
index a3a2ac2..516e7cc 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}</ProjectGuid>
     <OutputType>Exe</OutputType>
@@ -67,7 +67,7 @@
   <ItemGroup>
     <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
   </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
diff --git a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
index 5cd4b1a..7269dad 100644
--- a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
+++ b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
@@ -1,6 +1,6 @@
 Microsoft Visual Studio Solution File, Format Version 10.00
 # Visual Studio 2008
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "org.apache.qpid.messaging", "src\org.apache.qpid.messaging.vcproj", "{AA5A3B83-5F98-406D-A01C-5A921467A57D}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Org.Apache.Qpid.Messaging", "src\org.apache.qpid.messaging.vcproj", "{AA5A3B83-5F98-406D-A01C-5A921467A57D}"
 EndProject
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Examples", "Examples", "{34C477FB-B0CC-4AB9-A346-EA7B055469AC}"
 EndProject
@@ -43,6 +43,20 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.map.callback.receive
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.map.callback.sender", "examples\csharp.map.callback.sender\csharp.map.callback.sender.csproj", "{12F1C14F-5C7D-4075-9BAE-C091394FF99A}"
 EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Client-Server", "Client-Server", "{9232212E-F3C6-4D18-8D25-0C31DD5FF3DB}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.client", "examples\csharp.example.client\csharp.example.client.csproj", "{0DE01712-C2D1-4CA4-B42C-5856456A8696}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.server", "examples\csharp.example.server\csharp.example.server.csproj", "{090A081D-E8B5-4949-AA43-EE182B7101E3}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Drain-Spout", "Drain-Spout", "{89CE04CB-21DE-4ABB-9236-50529DD8C022}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.drain", "examples\csharp.example.drain\csharp.example.drain.csproj", "{C43DEB69-8088-420B-B0CA-C699535E6D08}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.spout", "examples\csharp.example.spout\csharp.example.spout.csproj", "{EB36626D-36C2-41B3-B65E-762BAF27F137}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.declare_queues", "examples\csharp.example.declare_queues\csharp.example.declare_queues.csproj", "{E31B349C-830C-4583-8BD9-30DA4398349F}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -180,6 +194,76 @@ Global
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Win32.ActiveCfg = Release|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|x86.ActiveCfg = Release|x86
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|x86.Build.0 = Release|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Debug|Win32.ActiveCfg = Debug|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Debug|x86.ActiveCfg = Debug|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Debug|x86.Build.0 = Debug|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Release|Any CPU.Build.0 = Release|Any CPU
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Release|Mixed Platforms.Build.0 = Release|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Release|Win32.ActiveCfg = Release|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Release|x86.ActiveCfg = Release|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Release|x86.Build.0 = Release|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Debug|Win32.ActiveCfg = Debug|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Debug|x86.ActiveCfg = Debug|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Debug|x86.Build.0 = Debug|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Release|Any CPU.Build.0 = Release|Any CPU
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Release|Mixed Platforms.Build.0 = Release|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Release|Win32.ActiveCfg = Release|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Release|x86.ActiveCfg = Release|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Release|x86.Build.0 = Release|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Debug|Win32.ActiveCfg = Debug|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Debug|x86.ActiveCfg = Debug|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Debug|x86.Build.0 = Debug|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Release|Any CPU.Build.0 = Release|Any CPU
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Release|Mixed Platforms.Build.0 = Release|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Release|Win32.ActiveCfg = Release|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Release|x86.ActiveCfg = Release|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Release|x86.Build.0 = Release|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Debug|Win32.ActiveCfg = Debug|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Debug|x86.ActiveCfg = Debug|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Debug|x86.Build.0 = Debug|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Release|Any CPU.Build.0 = Release|Any CPU
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Release|Mixed Platforms.Build.0 = Release|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Release|Win32.ActiveCfg = Release|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Release|x86.ActiveCfg = Release|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Release|x86.Build.0 = Release|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Debug|Win32.ActiveCfg = Debug|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Debug|x86.ActiveCfg = Debug|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Debug|x86.Build.0 = Debug|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|Any CPU.Build.0 = Release|Any CPU
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|Mixed Platforms.Build.0 = Release|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|Win32.ActiveCfg = Release|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|x86.ActiveCfg = Release|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|x86.Build.0 = Release|x86
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
@@ -188,6 +272,8 @@ Global
 		{DE58D329-10DC-4C8D-9EFA-230A57314089} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
 		{878FDDF8-A870-41D6-9E36-0A050EC5ACAB} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
 		{E99FEFEE-B866-4BBA-9AA3-79DDF1C92960} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
+		{9232212E-F3C6-4D18-8D25-0C31DD5FF3DB} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
+		{89CE04CB-21DE-4ABB-9236-50529DD8C022} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068} = {DE58D329-10DC-4C8D-9EFA-230A57314089}
 		{52F880E7-D677-4C91-8516-D679CE0F46A8} = {DE58D329-10DC-4C8D-9EFA-230A57314089}
 		{AF2FBC78-266C-430C-BC29-9477AB596A36} = {39E9D1BF-3A0B-4D86-BF6B-F463E1A2245A}
@@ -195,5 +281,10 @@ Global
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696} = {9232212E-F3C6-4D18-8D25-0C31DD5FF3DB}
+		{090A081D-E8B5-4949-AA43-EE182B7101E3} = {9232212E-F3C6-4D18-8D25-0C31DD5FF3DB}
+		{C43DEB69-8088-420B-B0CA-C699535E6D08} = {89CE04CB-21DE-4ABB-9236-50529DD8C022}
+		{EB36626D-36C2-41B3-B65E-762BAF27F137} = {89CE04CB-21DE-4ABB-9236-50529DD8C022}
+		{E31B349C-830C-4583-8BD9-30DA4398349F} = {89CE04CB-21DE-4ABB-9236-50529DD8C022}
 	EndGlobalSection
 EndGlobal
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
index 3f748f1..743afce 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
@@ -24,6 +24,7 @@
 #include <string>
 #include <limits>
 #include <iostream>
+#include <stdlib.h>
 
 #include "qpid/messaging/Message.h"
 #include "qpid/types/Variant.h"
@@ -100,6 +101,25 @@ namespace Messaging {
         }
     }
 
+
+	// Create from bytes
+	Message::Message(array<System::Byte> ^ bytes)
+	{
+		pin_ptr<unsigned char> pBytes = &bytes[0];
+		messagep = new ::qpid::messaging::Message((char *)pBytes, bytes->Length);
+	}
+
+    // Create from byte array slice
+	Message::Message(array<System::Byte> ^ bytes, int offset, int size)
+	{
+        if ((offset + size) > bytes->Length)
+			throw gcnew QpidException("Message::Message Create from byte array slice: buffer length exceeded");
+
+		pin_ptr<unsigned char> pBytes = &bytes[offset];
+		messagep = new ::qpid::messaging::Message((char *)pBytes, size);
+	}
+
+
     // Create from received message
     Message::Message(::qpid::messaging::Message * msgp) :
         messagep(msgp)
@@ -278,7 +298,7 @@ namespace Messaging {
         messagep->setRedelivered(redelivered);
     }
 
-
+	// Properties
     System::Collections::Generic::Dictionary<
             System::String^, System::Object^> ^ Message::GetProperties()
     {
@@ -297,7 +317,29 @@ namespace Messaging {
     }
 
 
-    void Message::SetContent(System::String ^ content)
+	void Message::SetProperty(System::String ^ name, System::Object ^ value)
+	{
+        ::qpid::types::Variant entryValue;
+        TypeTranslator::ManagedToNativeObject(value, entryValue);
+
+		messagep->getProperties()[QpidMarshal::ToNative(name)] = entryValue;
+	}
+
+
+	void Message::SetProperties(System::Collections::Generic::Dictionary<
+            System::String^, System::Object^> ^ properties)
+	{
+		for each (System::Collections::Generic::KeyValuePair
+			     <System::String^, System::Object^> kvp in properties)
+        {
+			SetProperty(kvp.Key, kvp.Value);
+		}
+	}
+
+
+	
+	// Content
+	void Message::SetContent(System::String ^ content)
     {
         messagep->setContent(QpidMarshal::ToNative(content));
     }
@@ -342,8 +384,9 @@ namespace Messaging {
     }
 
     //
-    // User wants content as bytes.
-    // result array must be correct size already
+    // Return message content to raw byte array.
+    // On entry message size must not be zero and
+	// caller's byte array must be equal to message size.
     //
     void Message::GetRaw(array<System::Byte> ^ arr)
     {
@@ -353,16 +396,11 @@ namespace Messaging {
             throw gcnew QpidException("Message::GetRaw - message size is zero");
 
         if (arr->Length != size)
-            throw gcnew QpidException("Message::GetRaw - receive buffer is too small");
+            throw gcnew QpidException("Message::GetRaw - receive buffer is wrong size");
 
-        const char * ptr = messagep->getContentPtr();
-
-        // TODO: System::Runtime::InteropServices::Marshal::Copy(ptr, arr, 0, size);
-
-        for (UInt32 i = 0; i < size; i++)
-        {
-            arr[i] = ptr[i];
-        }
+        const char * pMsgSrc = messagep->getContentPtr();
+		pin_ptr<unsigned char> pArr = &arr[0];
+		memcpy(pArr, pMsgSrc, size);
     }
 
 
@@ -370,4 +408,86 @@ namespace Messaging {
     {
         return messagep->getContentSize();
     }
+
+
+	System::String ^ Message::MapAsString(System::Collections::Generic::Dictionary<
+					           System::String^, System::Object^> ^ dict)
+    {
+		System::String ^ leading = "";
+		System::Text::StringBuilder ^ sb = gcnew System::Text::StringBuilder("{");
+
+		for each (System::Collections::Generic::KeyValuePair
+			     <System::String^, System::Object^> kvp in dict)
+        {
+            sb->Append(leading);
+            leading = ", ";
+
+			if (QpidTypeCheck::ObjectIsMap(kvp.Value))
+            {
+				sb->AppendFormat(
+					"{0}={1}", 
+					kvp.Key,
+					MapAsString((System::Collections::Generic::Dictionary<System::String^, System::Object^> ^)kvp.Value));
+            }
+			else if (QpidTypeCheck::ObjectIsList(kvp.Value))
+            {
+                sb->AppendFormat(
+					"{0}={1}", 
+					kvp.Key,
+					ListAsString((System::Collections::ObjectModel::Collection<
+							System::Object^> ^)kvp.Value));
+            }
+            else
+                sb->AppendFormat("{0}={1}", kvp.Key, kvp.Value);
+        }
+		sb->Append("}");
+
+		System::String ^ result = gcnew System::String(sb->ToString());
+		return result;
+    }
+
+    /// <summary>
+    /// A function to display a ampq/list message packaged as a List.
+    /// </summary>
+    /// <param name="list">The AMQP list</param>
+	System::String ^ Message::ListAsString(System::Collections::ObjectModel::Collection<System::Object^> ^ list)
+    {
+		System::String ^ leading = "";
+		System::Text::StringBuilder ^ sb = gcnew System::Text::StringBuilder("[");
+
+		for each (System::Object ^ obj in list)
+        {
+            sb->Append(leading);
+            leading = ", ";
+
+			if (QpidTypeCheck::ObjectIsMap(obj))
+            {
+                sb->Append(MapAsString((System::Collections::Generic::Dictionary<
+                                System::String^, System::Object^> ^)obj));
+            }
+			else if (QpidTypeCheck::ObjectIsList(obj))
+            {
+                sb->Append(ListAsString((System::Collections::ObjectModel::Collection<
+                                System::Object^> ^)obj));
+            }
+            else
+                sb->Append(obj->ToString());
+        }
+        sb->Append("]");
+
+		System::String ^ result = gcnew System::String(sb->ToString());
+		return result;
+    }
+
+	System::String ^ Message::AsString(System::Object ^ obj)
+	{
+		if (QpidTypeCheck::ObjectIsMap(obj))
+			return MapAsString((System::Collections::Generic::Dictionary<
+                                System::String^, System::Object^> ^)obj);
+		else if (QpidTypeCheck::ObjectIsList(obj))
+			return ListAsString((System::Collections::ObjectModel::Collection<
+                                System::Object^> ^)obj);
+		else
+			return obj->ToString();
+	}
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.h b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
index 0a932a9..99d0b86 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
@@ -58,8 +58,11 @@ namespace Messaging {
         // Create from object
         Message(System::Object ^ theValue);
 
-        // TODO: Create from bytes
-        // Message(System::Byte [] ^ bytes);
+        // Create from byte array
+		Message(array<System::Byte> ^ bytes);
+
+        // Create from byte array slice
+		Message(array<System::Byte> ^ bytes, int offset, int size);
 
         // Create from received message
         Message(::qpid::messaging::Message * msgp);
@@ -108,6 +111,11 @@ namespace Messaging {
         System::Collections::Generic::Dictionary<
             System::String^, System::Object^> ^ GetProperties();
 
+		void SetProperty(System::String ^ name, System::Object ^ value);
+
+		void SetProperties(System::Collections::Generic::Dictionary<
+            System::String^, System::Object^> ^ properties);
+
         void SetContent(System::String ^ content);
 
         //TODO:: void setContent(Bytes{} bytes, offset, length);
@@ -129,6 +137,16 @@ namespace Messaging {
 
         System::UInt64 GetContentSize();
 
+		// A message has been returned to managed code through GetContent().
+		// Display the content of that System::Object as a string.
+		System::String ^ AsString(System::Object ^ obj);
+
+		System::String ^ MapAsString(System::Collections::Generic::Dictionary<
+						System::String^, System::Object^> ^ dict);
+		
+		System::String ^ ListAsString(System::Collections::ObjectModel::Collection<
+			            System::Object^> ^ list);
+
         //TODO: EncodingException
 
         // Note: encode/decode functions are in TypeTranslator
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
index c8d85b0..04fbb61 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
@@ -27,6 +27,7 @@
 #include "qpid/messaging/exceptions.h"
 
 #include "QpidMarshal.h"
+#include "Address.h"
 #include "Session.h"
 #include "Connection.h"
 #include "Duration.h"
@@ -207,6 +208,54 @@ namespace Messaging {
     Sender ^ Session::CreateSender  (System::String ^ address)
     {
         System::Exception          ^ newException = nullptr;
+        ::qpid::messaging::Sender  * senderp      = NULL;
+        Sender                     ^ newSender    = nullptr;
+
+        try
+        {
+            // allocate a native sender
+            ::qpid::messaging::Sender * senderp = new ::qpid::messaging::Sender ;
+
+            // create the sender
+            *senderp = sessionp->::qpid::messaging::Session::createSender(QpidMarshal::ToNative(address));
+
+            // create a managed sender
+            newSender = gcnew Sender(senderp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        finally
+        {
+            if (newException != nullptr)
+            {
+				if (newSender != nullptr)
+				{
+					delete newSender;
+				}
+				else
+				{
+					if (senderp != NULL)
+					{
+						delete senderp;
+					}
+				}
+            }
+        }
+        if (newException != nullptr) 
+		{
+	        throw newException;
+		}
+
+        return newSender;
+    }
+
+
+    Sender ^ Session::CreateSender  (Address ^ address)
+    {
+        System::Exception          ^ newException = nullptr;
         ::qpid::messaging::Sender  * senderp         = NULL;
         Sender                     ^ newSender       = nullptr;
 
@@ -216,7 +265,7 @@ namespace Messaging {
             ::qpid::messaging::Sender * senderp = new ::qpid::messaging::Sender ;
 
             // create the sender
-            *senderp = sessionp->::qpid::messaging::Session::createSender(QpidMarshal::ToNative(address));
+            *senderp = sessionp->::qpid::messaging::Session::createSender(*(address->NativeAddress));
 
             // create a managed sender
             newSender = gcnew Sender(senderp, this);
@@ -251,7 +300,8 @@ namespace Messaging {
         return newSender;
     }
 
-    Receiver ^ Session::CreateReceiver(System::String ^ address)
+
+	Receiver ^ Session::CreateReceiver(System::String ^ address)
     {
         System::Exception           ^ newException = nullptr;
         ::qpid::messaging::Receiver * receiverp    = NULL;
@@ -299,6 +349,54 @@ namespace Messaging {
     }
 
 
+	Receiver ^ Session::CreateReceiver(Address ^ address)
+    {
+        System::Exception           ^ newException = nullptr;
+        ::qpid::messaging::Receiver * receiverp    = NULL;
+        Receiver                    ^ newReceiver  = nullptr;
+
+        try 
+		{
+            // allocate a native receiver
+            receiverp = new ::qpid::messaging::Receiver;
+
+            // create the receiver
+            *receiverp = sessionp->createReceiver(*(address->NativeAddress));
+
+            // create a managed receiver
+            newReceiver = gcnew Receiver(receiverp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+		{
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        finally 
+		{
+            if (newException != nullptr)
+			{
+				if (newReceiver != nullptr)
+				{
+					delete newReceiver;
+				}
+				else
+				{
+					if (receiverp != NULL)
+					{
+						delete receiverp;
+					}
+				}
+            }
+        }
+        if (newException != nullptr) 
+		{
+	        throw newException;
+		}
+
+        return newReceiver;
+    }
+
+
     Receiver ^ Session::CreateReceiver()
     {
         System::Exception           ^ newException = nullptr;
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.h b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
index babb99d..4b84eec 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
@@ -45,6 +45,7 @@ namespace Messaging {
     /// Session is a managed wrapper for a ::qpid::messaging::Session
     /// </summary>
 
+	ref class Address;
     ref class Connection;
     ref class Duration;
     ref class Receiver;
@@ -99,8 +100,11 @@ namespace Messaging {
         Receiver ^ NextReceiver(Duration ^ timeout);
 
 
-        Sender   ^ CreateSender  (System::String ^ address);
+        Sender   ^ CreateSender(System::String ^ address);
+		Sender   ^ CreateSender(Address ^ address);
+
         Receiver ^ CreateReceiver(System::String ^ address);
+		Receiver ^ CreateReceiver(Address ^ address);
         Receiver ^ CreateReceiver();
 
         Sender   ^ GetSender(System::String ^ name);
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
index 04ddc17..8e324a4 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}</ProjectGuid>
     <OutputType>Library</OutputType>
@@ -67,7 +67,7 @@
   <ItemGroup>
     <ProjectReference Include="..\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
   </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
index 923952b..5763077 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
@@ -83,6 +83,37 @@ namespace Org.Apache.Qpid.Messaging
             Console.WriteLine("Got raw array size {0}", m2Size);
             for (UInt64 i = 0; i < m2Size; i++)
                 Console.Write("{0} ", myRaw[i].ToString());
+            Console.WriteLine();
+
+            //
+            // Raw message creation
+            //
+            byte[] rawData = new byte[10];
+            for (byte i=0; i<10; i++)
+                rawData[i] = i;
+            Message m3 = new Message(rawData);
+
+            byte[] rawDataReadback = new byte[m3.GetContentSize()];
+            m3.GetRaw(rawDataReadback);
+            for (UInt64 i = 0; i < m3.GetContentSize(); i++)
+                Console.Write("{0} ", rawDataReadback[i].ToString());
+            Console.WriteLine();
+
+            //
+            // Raw message from array slice
+            //
+            byte[] rawData4 = new byte[256];
+            for (int i = 0; i <= 255; i++)
+                rawData4[i] = (byte)i;
+
+            Message m4 = new Message(rawData4, 246, 10);
+
+            byte[] rawDataReadback4 = new byte[m4.GetContentSize()];
+            m4.GetRaw(rawDataReadback4);
+            for (UInt64 i = 0; i < m4.GetContentSize(); i++)
+                Console.Write("{0} ", rawDataReadback4[i].ToString());
+            Console.WriteLine();
+
         }
     }
 }
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
index 5dddc59..e4f1175 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{AF2FBC78-266C-430C-BC29-9477AB596A36}</ProjectGuid>
     <OutputType>Exe</OutputType>
@@ -67,7 +67,7 @@
   <ItemGroup>
     <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
   </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
-- 
1.5.5.6

From 7ae72bd17b22f6107f6f3e69779a7918fddfd1e3 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Thu, 24 Jun 2010 12:40:11 +0000
Subject: [PATCH] QPID-2589 - Patch from Chuck Rolke
 Visual Basic example added, UUID support added, C# Hello World example added.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@957531 13f79535-47bb-0310-9956-ffa450edef68
---
 .../Properties/AssemblyInfo.cs                     |   36 ++++++
 .../csharp.example.helloworld.cs                   |   55 ++++++++
 .../csharp.example.helloworld.csproj               |   81 ++++++++++++
 .../csharp.map.callback.sender.cs                  |    3 +
 .../csharp.map.sender/csharp.map.sender.cs         |    3 +
 .../MyProject/Application.Designer.vb              |   13 ++
 .../MyProject/Application.myapp                    |   10 ++
 .../MyProject/AssemblyInfo.vb                      |   35 +++++
 .../MyProject/Resources.Designer.vb                |   63 +++++++++
 .../MyProject/Resources.resx                       |  117 +++++++++++++++++
 .../MyProject/Settings.Designer.vb                 |   73 +++++++++++
 .../MyProject/Settings.settings                    |    7 +
 .../visualbasic.example.client.vb                  |   69 ++++++++++
 .../visualbasic.example.client.vbproj              |  134 ++++++++++++++++++++
 .../qpid/dotnet/org.apache.qpid.messaging.sln      |   37 ++++++
 .../bindings/qpid/dotnet/src/TypeTranslator.cpp    |   30 +++++-
 .../dotnet/test/messaging.test/messaging.test.cs   |   14 ++
 17 files changed, 779 insertions(+), 1 deletions(-)
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.Designer.vb
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.myapp
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/AssemblyInfo.vb
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.Designer.vb
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.resx
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.Designer.vb
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.settings
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vbproj

diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..2b96ce9
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/Properties/AssemblyInfo.cs
@@ -0,0 +1,36 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.direct.sender")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.direct.sender")]
+[assembly: AssemblyCopyright("Copyright ?  2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("19ce67e4-db90-4480-88c4-3721f47634c7")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.cs
new file mode 100644
index 0000000..336970a
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.cs
@@ -0,0 +1,55 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using Org.Apache.Qpid.Messaging;
+
+namespace Org.Apache.Qpid.Messaging {
+    class Program {
+        static void Main(string[] args) {
+            String broker = args.Length > 0 ? args[0] : "localhost:5672";
+            String address = args.Length > 1 ? args[1] : "amq.topic";
+
+            Connection connection = null;
+            try {
+                connection = new Connection(broker);
+                connection.Open();
+                Session session = connection.CreateSession();
+
+                Receiver receiver = session.CreateReceiver(address);
+                Sender sender = session.CreateSender(address);
+
+                sender.Send(new Message("Hello world!"));
+
+                Message message = new Message();
+                message = receiver.Fetch(DurationConstants.SECOND * 1);
+                Console.WriteLine("{0}", message.GetContent());
+                session.Acknowledge();
+
+                connection.Close();
+            } catch (Exception e) {
+                Console.WriteLine("Exception {0}.", e);
+                if (null != connection)
+                    connection.Close();
+            }
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.csproj
new file mode 100644
index 0000000..3038ed6
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.csproj
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{8CC1C265-0507-44A3-9483-8FAF48513F4D}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.example.helloworld</RootNamespace>
+    <AssemblyName>csharp.example.helloworld</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.example.helloworld.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>Org.Apache.Qpid.Messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
index 2b17052..c987ad9 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
@@ -150,6 +150,9 @@ namespace Org.Apache.Qpid.Messaging.Examples
             Double myDouble = 13.13;
             content["myDouble"] = myDouble;
 
+            Guid myGuid = new Guid("000102030405060708090a0b0c0d0e0f");
+            content["myGuid"] = myGuid;
+
             //
             // Construct a message with the map content and send it synchronously
             // via the sender.
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
index 5517226..0763b74 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
@@ -113,6 +113,9 @@ namespace Org.Apache.Qpid.Messaging.examples
             Double myDouble = 13.13;
             content["myDouble"] = myDouble;
 
+            Guid myGuid = new Guid("000102030405060708090a0b0c0d0e0f");
+            content["myGuid"] = myGuid;
+
             //
             // Construct a message with the map content and send it synchronously
             // via the sender.
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.Designer.vb b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.Designer.vb
new file mode 100644
index 0000000..0c27414
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.Designer.vb
@@ -0,0 +1,13 @@
+'------------------------------------------------------------------------------
+' <auto-generated>
+'     This code was generated by a tool.
+'     Runtime Version:2.0.50727.4927
+'
+'     Changes to this file may cause incorrect behavior and will be lost if
+'     the code is regenerated.
+' </auto-generated>
+'------------------------------------------------------------------------------
+
+Option Strict On
+Option Explicit On
+
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.myapp b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.myapp
new file mode 100644
index 0000000..44772fe
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.myapp
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<MyApplicationData xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <MySubMain>false</MySubMain>
+  <SingleInstance>false</SingleInstance>
+  <ShutdownMode>0</ShutdownMode>
+  <EnableVisualStyles>true</EnableVisualStyles>
+  <AuthenticationMode>0</AuthenticationMode>
+  <ApplicationType>2</ApplicationType>
+  <SaveMySettingsOnExit>true</SaveMySettingsOnExit>
+</MyApplicationData>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/AssemblyInfo.vb b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/AssemblyInfo.vb
new file mode 100644
index 0000000..100283c
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/AssemblyInfo.vb
@@ -0,0 +1,35 @@
+Imports System
+Imports System.Reflection
+Imports System.Runtime.InteropServices
+
+' General Information about an assembly is controlled through the following 
+' set of attributes. Change these attribute values to modify the information
+' associated with an assembly.
+
+' Review the values of the assembly attributes
+
+<Assembly: AssemblyTitle("visualbasic.example.client")> 
+<Assembly: AssemblyDescription("")> 
+<Assembly: AssemblyCompany("Microsoft")> 
+<Assembly: AssemblyProduct("visualbasic.example.client")> 
+<Assembly: AssemblyCopyright("Copyright  Microsoft 2010")> 
+<Assembly: AssemblyTrademark("")> 
+
+<Assembly: ComVisible(False)>
+
+'The following GUID is for the ID of the typelib if this project is exposed to COM
+<Assembly: Guid("ec9df8cf-c1d4-4938-9e72-93fb81d55700")> 
+
+' Version information for an assembly consists of the following four values:
+'
+'      Major Version
+'      Minor Version 
+'      Build Number
+'      Revision
+'
+' You can specify all the values or you can default the Build and Revision Numbers 
+' by using the '*' as shown below:
+' <Assembly: AssemblyVersion("1.0.*")> 
+
+<Assembly: AssemblyVersion("1.0.0.0")> 
+<Assembly: AssemblyFileVersion("1.0.0.0")> 
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.Designer.vb b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.Designer.vb
new file mode 100644
index 0000000..19d7b32
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.Designer.vb
@@ -0,0 +1,63 @@
+'------------------------------------------------------------------------------
+' <auto-generated>
+'     This code was generated by a tool.
+'     Runtime Version:2.0.50727.4927
+'
+'     Changes to this file may cause incorrect behavior and will be lost if
+'     the code is regenerated.
+' </auto-generated>
+'------------------------------------------------------------------------------
+
+Option Strict On
+Option Explicit On
+
+Imports System
+
+Namespace My.Resources
+    
+    'This class was auto-generated by the StronglyTypedResourceBuilder
+    'class via a tool like ResGen or Visual Studio.
+    'To add or remove a member, edit your .ResX file then rerun ResGen
+    'with the /str option, or rebuild your VS project.
+    '''<summary>
+    '''  A strongly-typed resource class, for looking up localized strings, etc.
+    '''</summary>
+    <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0"),  _
+     Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
+     Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
+     Global.Microsoft.VisualBasic.HideModuleNameAttribute()>  _
+    Friend Module Resources
+        
+        Private resourceMan As Global.System.Resources.ResourceManager
+        
+        Private resourceCulture As Global.System.Globalization.CultureInfo
+        
+        '''<summary>
+        '''  Returns the cached ResourceManager instance used by this class.
+        '''</summary>
+        <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
+        Friend ReadOnly Property ResourceManager() As Global.System.Resources.ResourceManager
+            Get
+                If Object.ReferenceEquals(resourceMan, Nothing) Then
+                    Dim temp As Global.System.Resources.ResourceManager = New Global.System.Resources.ResourceManager("Org.Apache.Qpid.Messaging.Examples.Resources", GetType(Resources).Assembly)
+                    resourceMan = temp
+                End If
+                Return resourceMan
+            End Get
+        End Property
+        
+        '''<summary>
+        '''  Overrides the current thread's CurrentUICulture property for all
+        '''  resource lookups using this strongly typed resource class.
+        '''</summary>
+        <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
+        Friend Property Culture() As Global.System.Globalization.CultureInfo
+            Get
+                Return resourceCulture
+            End Get
+            Set
+                resourceCulture = value
+            End Set
+        End Property
+    End Module
+End Namespace
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.resx b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.resx
new file mode 100644
index 0000000..3a752df
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.resx
@@ -0,0 +1,117 @@
+<?xml version="1.0" encoding="utf-8"?>
+<root>
+  <!-- 
+    Microsoft ResX Schema 
+    
+    Version 2.0
+    
+    The primary goals of this format is to allow a simple XML format 
+    that is mostly human readable. The generation and parsing of the 
+    various data types are done through the TypeConverter classes 
+    associated with the data types.
+    
+    Example:
+    
+    ... ado.net/XML headers & schema ...
+    <resheader name="resmimetype">text/microsoft-resx</resheader>
+    <resheader name="version">2.0</resheader>
+    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
+    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
+    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
+    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
+    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
+        <value>[base64 mime encoded serialized .NET Framework object]</value>
+    </data>
+    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
+        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
+        <comment>This is a comment</comment>
+    </data>
+                
+    There are any number of "resheader" rows that contain simple 
+    name/value pairs.
+    
+    Each data row contains a name, and value. The row also contains a 
+    type or mimetype. Type corresponds to a .NET class that support 
+    text/value conversion through the TypeConverter architecture. 
+    Classes that don't support this are serialized and stored with the 
+    mimetype set.
+    
+    The mimetype is used for serialized objects, and tells the 
+    ResXResourceReader how to depersist the object. This is currently not 
+    extensible. For a given mimetype the value must be set accordingly:
+    
+    Note - application/x-microsoft.net.object.binary.base64 is the format 
+    that the ResXResourceWriter will generate, however the reader can 
+    read any of the formats listed below.
+    
+    mimetype: application/x-microsoft.net.object.binary.base64
+    value   : The object must be serialized with 
+            : System.Serialization.Formatters.Binary.BinaryFormatter
+            : and then encoded with base64 encoding.
+    
+    mimetype: application/x-microsoft.net.object.soap.base64
+    value   : The object must be serialized with 
+            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
+            : and then encoded with base64 encoding.
+
+    mimetype: application/x-microsoft.net.object.bytearray.base64
+    value   : The object must be serialized into a byte array 
+            : using a System.ComponentModel.TypeConverter
+            : and then encoded with base64 encoding.
+    -->
+  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
+    <xsd:element name="root" msdata:IsDataSet="true">
+      <xsd:complexType>
+        <xsd:choice maxOccurs="unbounded">
+          <xsd:element name="metadata">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" />
+              <xsd:attribute name="type" type="xsd:string" />
+              <xsd:attribute name="mimetype" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="assembly">
+            <xsd:complexType>
+              <xsd:attribute name="alias" type="xsd:string" />
+              <xsd:attribute name="name" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="data">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
+              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
+              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="resheader">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" use="required" />
+            </xsd:complexType>
+          </xsd:element>
+        </xsd:choice>
+      </xsd:complexType>
+    </xsd:element>
+  </xsd:schema>
+  <resheader name="resmimetype">
+    <value>text/microsoft-resx</value>
+  </resheader>
+  <resheader name="version">
+    <value>2.0</value>
+  </resheader>
+  <resheader name="reader">
+    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+  <resheader name="writer">
+    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+</root>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.Designer.vb b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.Designer.vb
new file mode 100644
index 0000000..fd9a759
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.Designer.vb
@@ -0,0 +1,73 @@
+'------------------------------------------------------------------------------
+' <auto-generated>
+'     This code was generated by a tool.
+'     Runtime Version:2.0.50727.4927
+'
+'     Changes to this file may cause incorrect behavior and will be lost if
+'     the code is regenerated.
+' </auto-generated>
+'------------------------------------------------------------------------------
+
+Option Strict On
+Option Explicit On
+
+
+Namespace My
+    
+    <Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
+     Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0"),  _
+     Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
+    Partial Friend NotInheritable Class MySettings
+        Inherits Global.System.Configuration.ApplicationSettingsBase
+        
+        Private Shared defaultInstance As MySettings = CType(Global.System.Configuration.ApplicationSettingsBase.Synchronized(New MySettings),MySettings)
+        
+#Region "My.Settings Auto-Save Functionality"
+#If _MyType = "WindowsForms" Then
+    Private Shared addedHandler As Boolean
+
+    Private Shared addedHandlerLockObject As New Object
+
+    <Global.System.Diagnostics.DebuggerNonUserCodeAttribute(), Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _
+    Private Shared Sub AutoSaveSettings(ByVal sender As Global.System.Object, ByVal e As Global.System.EventArgs)
+        If My.Application.SaveMySettingsOnExit Then
+            My.Settings.Save()
+        End If
+    End Sub
+#End If
+#End Region
+        
+        Public Shared ReadOnly Property [Default]() As MySettings
+            Get
+                
+#If _MyType = "WindowsForms" Then
+               If Not addedHandler Then
+                    SyncLock addedHandlerLockObject
+                        If Not addedHandler Then
+                            AddHandler My.Application.Shutdown, AddressOf AutoSaveSettings
+                            addedHandler = True
+                        End If
+                    End SyncLock
+                End If
+#End If
+                Return defaultInstance
+            End Get
+        End Property
+    End Class
+End Namespace
+
+Namespace My
+    
+    <Global.Microsoft.VisualBasic.HideModuleNameAttribute(),  _
+     Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
+     Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute()>  _
+    Friend Module MySettingsProperty
+        
+        <Global.System.ComponentModel.Design.HelpKeywordAttribute("My.Settings")>  _
+        Friend ReadOnly Property Settings() As Global.Org.Apache.Qpid.Messaging.Examples.My.MySettings
+            Get
+                Return Global.Org.Apache.Qpid.Messaging.Examples.My.MySettings.Default
+            End Get
+        End Property
+    End Module
+End Namespace
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.settings b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.settings
new file mode 100644
index 0000000..73b4a10
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.settings
@@ -0,0 +1,7 @@
+<?xml version='1.0' encoding='utf-8'?>
+<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)" UseMySettingsClassName="true">
+  <Profiles>
+    <Profile Name="(Default)" />
+  </Profiles>
+  <Settings />
+</SettingsFile>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb
new file mode 100644
index 0000000..96300ec
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb
@@ -0,0 +1,69 @@
+'
+'
+' Licensed to the Apache Software Foundation (ASF) under one
+' or more contributor license agreements.  See the NOTICE file
+' distributed with this work for additional information
+' regarding copyright ownership.  The ASF licenses this file
+' to you under the Apache License, Version 2.0 (the
+' "License"); you may not use this file except in compliance
+' with the License.  You may obtain a copy of the License at
+' 
+'   http://www.apache.org/licenses/LICENSE-2.0
+' 
+' Unless required by applicable law or agreed to in writing,
+' software distributed under the License is distributed on an
+' "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+' KIND, either express or implied.  See the License for the
+' specific language governing permissions and limitations
+' under the License.
+'
+'
+
+Imports System
+Imports Org.Apache.Qpid.Messaging
+Namespace Org.Apache.Qpid.Messaging.Examples
+    Module Module1
+        Class Client
+            Public Shared Sub Main(ByVal args() As String)
+                Dim url As String = "amqp:tcp:127.0.0.1:5672"
+
+                If args.Length > 0 Then url = args(0)
+
+                Dim connection As Connection
+                Try
+                    connection = New Connection(url)
+                    connection.Open()
+
+                    Dim session As Session = connection.CreateSession()
+
+                    Dim sender As Sender = session.CreateSender("service_queue")
+
+                    Dim responseQueue As Address = New Address("#response-queue; {create:always, delete:always}")
+                    Dim receiver As Receiver = session.CreateReceiver(responseQueue)
+
+                    Dim s(3) As String
+                    s(0) = "Twas brillig, and the slithy toves"
+                    s(1) = "Did gire and gymble in the wabe."
+                    s(2) = "All mimsy were the borogroves,"
+                    s(3) = "And the mome raths outgrabe."
+
+                    Dim request As Message = New Message("")
+                    request.SetReplyTo(responseQueue)
+
+                    Dim i As Integer
+                    For i = 0 To s.Length - 1
+                        request.SetContent(s(i))
+                        sender.Send(request)
+                        Dim response As Message = receiver.Fetch()
+                        Console.WriteLine("{0} -> {1}", request.GetContent(), response.GetContent())
+                    Next i
+                    connection.Close()
+
+                Catch e As Exception
+                    Console.WriteLine("Exception {0}.", e)
+                    connection.Close()
+                End Try
+            End Sub
+        End Class
+    End Module
+End Namespace
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vbproj b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vbproj
new file mode 100644
index 0000000..ae1c012
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vbproj
@@ -0,0 +1,134 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{CFEA696E-115B-4AD1-AB56-804E360EDD51}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <StartupObject>Sub Main</StartupObject>
+    <RootNamespace>Org.Apache.Qpid.Messaging.Examples</RootNamespace>
+    <AssemblyName>visualbasic.example.client</AssemblyName>
+    <FileAlignment>512</FileAlignment>
+    <MyType>Console</MyType>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <OptionExplicit>On</OptionExplicit>
+    <OptionCompare>Binary</OptionCompare>
+    <OptionStrict>Off</OptionStrict>
+    <OptionInfer>On</OptionInfer>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DocumentationFile>visualbasic.example.client.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <DefineDebug>false</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DocumentationFile>visualbasic.example.client.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DocumentationFile>visualbasic.example.client.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>bin\x86\Release\</OutputPath>
+    <DocumentationFile>visualbasic.example.client.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Data" />
+    <Reference Include="System.Deployment" />
+    <Reference Include="System.Xml" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+  </ItemGroup>
+  <ItemGroup>
+    <Import Include="Microsoft.VisualBasic" />
+    <Import Include="System" />
+    <Import Include="System.Collections" />
+    <Import Include="System.Collections.Generic" />
+    <Import Include="System.Data" />
+    <Import Include="System.Diagnostics" />
+    <Import Include="System.Linq" />
+    <Import Include="System.Xml.Linq" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="visualbasic.example.client.vb" />
+    <Compile Include="MyProject\AssemblyInfo.vb" />
+    <Compile Include="MyProject\Application.Designer.vb">
+      <AutoGen>True</AutoGen>
+      <DependentUpon>Application.myapp</DependentUpon>
+    </Compile>
+    <Compile Include="MyProject\Resources.Designer.vb">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>Resources.resx</DependentUpon>
+    </Compile>
+    <Compile Include="MyProject\Settings.Designer.vb">
+      <AutoGen>True</AutoGen>
+      <DependentUpon>Settings.settings</DependentUpon>
+      <DesignTimeSharedInput>True</DesignTimeSharedInput>
+    </Compile>
+  </ItemGroup>
+  <ItemGroup>
+    <EmbeddedResource Include="MyProject\Resources.resx">
+      <Generator>VbMyResourcesResXFileCodeGenerator</Generator>
+      <LastGenOutput>Resources.Designer.vb</LastGenOutput>
+      <CustomToolNamespace>My.Resources</CustomToolNamespace>
+      <SubType>Designer</SubType>
+    </EmbeddedResource>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="MyProject\Application.myapp">
+      <Generator>MyApplicationCodeGenerator</Generator>
+      <LastGenOutput>Application.Designer.vb</LastGenOutput>
+    </None>
+    <None Include="MyProject\Settings.settings">
+      <Generator>SettingsSingleFileGenerator</Generator>
+      <CustomToolNamespace>My</CustomToolNamespace>
+      <LastGenOutput>Settings.Designer.vb</LastGenOutput>
+    </None>
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>Org.Apache.Qpid.Messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.VisualBasic.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
index 7269dad..8df1ea6 100644
--- a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
+++ b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
@@ -57,6 +57,12 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.spout", "exa
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.declare_queues", "examples\csharp.example.declare_queues\csharp.example.declare_queues.csproj", "{E31B349C-830C-4583-8BD9-30DA4398349F}"
 EndProject
+Project("{F184B08F-C81C-45F6-A57F-5ABD9991F28F}") = "visualbasic.example.client", "examples\visualbasic.example.client\visualbasic.example.client.vbproj", "{CFEA696E-115B-4AD1-AB56-804E360EDD51}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Hello World", "Hello World", "{4408A2DA-ED2D-44AE-A465-0B6D75E1FF86}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.helloworld", "examples\csharp.example.helloworld\csharp.example.helloworld.csproj", "{8CC1C265-0507-44A3-9483-8FAF48513F4D}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -264,6 +270,34 @@ Global
 		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|Win32.ActiveCfg = Release|x86
 		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|x86.ActiveCfg = Release|x86
 		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|x86.Build.0 = Release|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Debug|Win32.ActiveCfg = Debug|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Debug|x86.ActiveCfg = Debug|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Debug|x86.Build.0 = Debug|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Release|Any CPU.Build.0 = Release|Any CPU
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Release|Mixed Platforms.Build.0 = Release|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Release|Win32.ActiveCfg = Release|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Release|x86.ActiveCfg = Release|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Release|x86.Build.0 = Release|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Debug|Win32.ActiveCfg = Debug|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Debug|x86.ActiveCfg = Debug|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Debug|x86.Build.0 = Debug|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Release|Any CPU.Build.0 = Release|Any CPU
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Release|Mixed Platforms.Build.0 = Release|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Release|Win32.ActiveCfg = Release|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Release|x86.ActiveCfg = Release|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Release|x86.Build.0 = Release|x86
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
@@ -274,6 +308,7 @@ Global
 		{E99FEFEE-B866-4BBA-9AA3-79DDF1C92960} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
 		{9232212E-F3C6-4D18-8D25-0C31DD5FF3DB} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
 		{89CE04CB-21DE-4ABB-9236-50529DD8C022} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
+		{4408A2DA-ED2D-44AE-A465-0B6D75E1FF86} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068} = {DE58D329-10DC-4C8D-9EFA-230A57314089}
 		{52F880E7-D677-4C91-8516-D679CE0F46A8} = {DE58D329-10DC-4C8D-9EFA-230A57314089}
 		{AF2FBC78-266C-430C-BC29-9477AB596A36} = {39E9D1BF-3A0B-4D86-BF6B-F463E1A2245A}
@@ -281,10 +316,12 @@ Global
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
 		{0DE01712-C2D1-4CA4-B42C-5856456A8696} = {9232212E-F3C6-4D18-8D25-0C31DD5FF3DB}
 		{090A081D-E8B5-4949-AA43-EE182B7101E3} = {9232212E-F3C6-4D18-8D25-0C31DD5FF3DB}
 		{C43DEB69-8088-420B-B0CA-C699535E6D08} = {89CE04CB-21DE-4ABB-9236-50529DD8C022}
 		{EB36626D-36C2-41B3-B65E-762BAF27F137} = {89CE04CB-21DE-4ABB-9236-50529DD8C022}
 		{E31B349C-830C-4583-8BD9-30DA4398349F} = {89CE04CB-21DE-4ABB-9236-50529DD8C022}
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D} = {4408A2DA-ED2D-44AE-A465-0B6D75E1FF86}
 	EndGlobalSection
 EndGlobal
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
index d463e66..c4587fe 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
@@ -221,7 +221,25 @@ namespace Messaging {
             }
             break;
 
-            
+        case System::TypeCode::Object :
+            {
+                //
+                // Derived classes
+                //
+                if ("System.Guid" == typeP->ToString())
+                {
+                    cli::array<System::Byte> ^ guidBytes = ((System::Guid)managedValue).ToByteArray();
+                    pin_ptr<unsigned char> pinnedBuf = &guidBytes[0];
+                    ::qpid::types::Uuid newUuid = ::qpid::types::Uuid(pinnedBuf);
+                    qpidVariant = newUuid;
+                }
+                else
+                {
+                    throw gcnew System::NotImplementedException();
+                }
+            }
+            break;
+
         default:
 
             throw gcnew System::NotImplementedException();
@@ -318,6 +336,11 @@ namespace Messaging {
                 }
                 
             case ::qpid::types::VAR_UUID:
+                {
+                    System::String ^ elementValue = gcnew System::String(variant.asUuid().str().c_str());
+                    System::Guid ^ newGuid = System::Guid(elementValue);
+                    dict[elementName] = newGuid;
+                }
                 break;
             }
         }
@@ -406,6 +429,11 @@ namespace Messaging {
                 }
                 
             case ::qpid::types::VAR_UUID:
+                {
+                    System::String ^ elementValue = gcnew System::String(variant.asUuid().str().c_str());
+                    System::Guid ^ newGuid = System::Guid(elementValue);
+                    (*managedList).Add(newGuid);
+                }
                 break;
             }
         }
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
index 5763077..2e0e481 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
@@ -114,6 +114,20 @@ namespace Org.Apache.Qpid.Messaging
                 Console.Write("{0} ", rawDataReadback4[i].ToString());
             Console.WriteLine();
 
+            //
+            // Guid factoids
+            //
+            Guid myGuid = new Guid("000102030405060708090a0b0c0d0e0f");
+            System.Type typeP = myGuid.GetType();
+            System.TypeCode typeCode = System.Type.GetTypeCode(typeP);
+
+            Console.WriteLine("Guid Type = {0}, TypeCode = {1}",
+                typeP.ToString(), typeCode.ToString());
+            // typeP="System.Guid", typeCode="Object"
+            byte[] guidReadback;
+            guidReadback = myGuid.ToByteArray();
+
+            Console.WriteLine("GuidReadback len = {0}", guidReadback.Length);
         }
     }
 }
-- 
1.5.5.6

From 55095229ebc4764c1add9810ea41a76296656c23 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Fri, 25 Jun 2010 17:55:46 +0000
Subject: [PATCH] QPID-2589 - Patch from Chuck Rolke
 * Convert c-style Get() functions to c#-style properties.
 * Add powershell helloworld example.
 * Fix message SetContent to accept byte array or byte array slice.
 * Re-code Session GetReceiver and GetSender not to malloc new objects but to create the objects on the stack.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958052 13f79535-47bb-0310-9956-ffa450edef68
---
 .../csharp.direct.receiver.cs                      |    2 +-
 .../csharp.direct.sender/csharp.direct.sender.cs   |    2 +-
 .../csharp.example.client/csharp.example.client.cs |    2 +-
 .../csharp.example.drain/csharp.example.drain.cs   |    6 +-
 .../csharp.example.server/csharp.example.server.cs |    2 +-
 .../csharp.example.spout/csharp.example.spout.cs   |    8 +-
 .../csharp.map.callback.receiver.cs                |    8 +-
 .../powershell.example.helloworld.ps1              |   34 +++
 .../visualbasic.example.client.vb                  |    2 +-
 .../qpid/dotnet/org.apache.qpid.messaging.sln      |    3 +
 qpid/cpp/bindings/qpid/dotnet/src/Address.cpp      |   81 +------
 qpid/cpp/bindings/qpid/dotnet/src/Address.h        |   90 ++++++-
 qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp   |    5 -
 qpid/cpp/bindings/qpid/dotnet/src/Connection.h     |    9 +-
 qpid/cpp/bindings/qpid/dotnet/src/Message.cpp      |  194 ++--------------
 qpid/cpp/bindings/qpid/dotnet/src/Message.h        |  254 +++++++++++++++++---
 qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp     |   32 +---
 qpid/cpp/bindings/qpid/dotnet/src/Receiver.h       |   66 +++++-
 qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp       |    7 +-
 qpid/cpp/bindings/qpid/dotnet/src/Sender.h         |   11 +-
 qpid/cpp/bindings/qpid/dotnet/src/Session.cpp      |   22 +-
 qpid/cpp/bindings/qpid/dotnet/src/Session.h        |    9 +-
 .../dotnet/test/messaging.test/messaging.test.cs   |   27 ++-
 23 files changed, 498 insertions(+), 378 deletions(-)
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/powershell.example.helloworld/powershell.example.helloworld.ps1

diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
index af0b398..69f7a0d 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
@@ -58,7 +58,7 @@ namespace CSharpDirect
             {
                 connection = new Connection(host);
                 connection.Open();
-                if (!connection.IsOpen()) {
+                if (!connection.IsOpen) {
                     Console.WriteLine("Failed to open connection to host : {0}", host);
                 } else {
                     Session session = connection.CreateSession();
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
index b287af2..2e80e8c 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
@@ -59,7 +59,7 @@ namespace csharp.direct.sender
                 connection = new Connection(host);
                 connection.Open();
 
-                if (!connection.IsOpen()) {
+                if (!connection.IsOpen) {
                     Console.WriteLine("Failed to open connection to host : {0}", host);
                 } else {
                     Session session = connection.CreateSession();
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs
index 93459b6..79b798e 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs
@@ -50,7 +50,7 @@ namespace Org.Apache.Qpid.Messaging.Examples {
                 };
 
                 Message request = new Message("");
-                request.SetReplyTo(responseQueue);
+                request.ReplyTo = responseQueue;
 
                 for (int i = 0; i < s.Length; i++) {
                     request.SetContent(s[i]);
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs
index 6740e6a..2d763a3 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs
@@ -47,17 +47,17 @@ namespace Org.Apache.Qpid.Messaging.Examples {
                 while (receiver.Fetch(message, timeout))
                 {
                     Dictionary<string, object> properties = new Dictionary<string, object>();
-                    properties = message.GetProperties();
+                    properties = message.Properties;
                     Console.Write("Message(properties={0}, content='", 
                                   message.MapAsString(properties));
 
-                    if ("amqp/map" == message.GetContentType())
+                    if ("amqp/map" == message.ContentType)
                     {
                         Dictionary<string, object> content = new Dictionary<string, object>();
                         message.GetContent(content);
                         Console.Write(message.MapAsString(content));
                     }
-                    else if ("amqp/list" == message.GetContentType())
+                    else if ("amqp/list" == message.ContentType)
                     {
                         Collection<object> content = new Collection<object>();
                         message.GetContent(content);
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs
index af01e4b..4ec5649 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs
@@ -38,7 +38,7 @@ namespace Org.Apache.Qpid.Messaging.Examples {
 
                 while (true) {
                     Message request = receiver.Fetch();
-                    Address address = request.GetReplyTo();
+                    Address address = request.ReplyTo;
 
                     if (null != address) {
                         Sender sender = session.CreateSender(address);
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs
index 7eeece3..59ba35f 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs
@@ -29,8 +29,8 @@ using Org.Apache.Qpid.Messaging;
 namespace Org.Apache.Qpid.Messaging.Examples {
     class Spout {
         //
-        // Sample invocation: csharp.example.drain.exe --broker localhost:5672 --timeout 30 my-queue
-        // This pro
+        // Sample invocation: csharp.example.spout.exe --broker localhost:5672 my-queue
+        // 
         static bool NameVal(string In, out string nameOut, out string valueOut)
         {
             int pos = In.IndexOf("=");
@@ -83,7 +83,7 @@ namespace Org.Apache.Qpid.Messaging.Examples {
                 else
                 {
                     message = new Message(options.Content);
-                    message.SetContentType("text/plain");
+                    message.ContentType = "text/plain";
                 }
                 Address replyToAddr = new Address(options.ReplyTo);
 
@@ -95,7 +95,7 @@ namespace Org.Apache.Qpid.Messaging.Examples {
                     (0 == options.Timeout || stopwatch.Elapsed <= timespan);
                     count++) 
                 {
-                    if ("" != options.ReplyTo) message.SetReplyTo(replyToAddr);
+                    if ("" != options.ReplyTo) message.ReplyTo = replyToAddr;
                     string id = options.Id ;
                     if ("" == id) {
                         Guid g = Guid.NewGuid();
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
index 2ef7854..965b494 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
@@ -93,14 +93,14 @@ namespace Org.Apache.Qpid.Messaging.Examples
         /// <param name="message">The Message</param>
         public static void ShowMessage(Message message)
         {
-            if ("amqp/map" == message.GetContentType())
+            if ("amqp/map" == message.ContentType)
             {
                 Console.WriteLine("Received a Dictionary");
                 Dictionary<string, object> content = new Dictionary<string, object>();
                 message.GetContent(content);
                 ShowDictionary(content, 0);
             }
-            else if ("amqp/list" == message.GetContentType())
+            else if ("amqp/list" == message.ContentType)
             {
                 Console.WriteLine("Received a List");
                 Collection<object> content = new Collection<object>();
@@ -148,7 +148,7 @@ namespace Org.Apache.Qpid.Messaging.Examples
             //
             // Acknowledge the receipt of all received messages.
             //
-            receiver.GetSession().Acknowledge();
+            receiver.Session.Acknowledge();
         }
 
 
@@ -241,7 +241,7 @@ namespace Org.Apache.Qpid.Messaging.Examples
             //
             // Establish a capacity
             //
-            receiver.SetCapacity(100);
+            receiver.Capacity = 100;
 
             //
             // Wait so many seconds for messages to arrive.
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/powershell.example.helloworld/powershell.example.helloworld.ps1 b/qpid/cpp/bindings/qpid/dotnet/examples/powershell.example.helloworld/powershell.example.helloworld.ps1
new file mode 100644
index 0000000..e8c21bc
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/powershell.example.helloworld/powershell.example.helloworld.ps1
@@ -0,0 +1,34 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+#
+# Script for 32-bit powershell
+#
+
+[Reflection.Assembly]::LoadFile('W:\cpp\src\Debug\org.apache.qpid.messagingd.dll')
+$conn = new-object Org.Apache.Qpid.Messaging.Connection("localhost:5672")
+$conn.Open()
+$sess = $conn.CreateSession()
+$rcvr = $sess.CreateReceiver("amq.topic")
+$sender = $sess.CreateSender("amq.topic")
+$msg1 = new-object Org.Apache.Qpid.Messaging.Message("Hello world!")
+$sender.Send($msg1)
+$dur = new-object Org.Apache.Qpid.Messaging.Duration(1000)
+$msg2 = $rcvr.Fetch($dur)
+$msg2.GetContent()
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb
index 96300ec..ccdc0d6 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb
@@ -48,7 +48,7 @@ Namespace Org.Apache.Qpid.Messaging.Examples
                     s(3) = "And the mome raths outgrabe."
 
                     Dim request As Message = New Message("")
-                    request.SetReplyTo(responseQueue)
+                    request.ReplyTo = responseQueue
 
                     Dim i As Integer
                     For i = 0 To s.Length - 1
diff --git a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
index 8df1ea6..38fd6dc 100644
--- a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
+++ b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
@@ -60,6 +60,9 @@ EndProject
 Project("{F184B08F-C81C-45F6-A57F-5ABD9991F28F}") = "visualbasic.example.client", "examples\visualbasic.example.client\visualbasic.example.client.vbproj", "{CFEA696E-115B-4AD1-AB56-804E360EDD51}"
 EndProject
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Hello World", "Hello World", "{4408A2DA-ED2D-44AE-A465-0B6D75E1FF86}"
+	ProjectSection(SolutionItems) = preProject
+		examples\powershell.example.helloworld\powershell.example.helloworld.ps1 = examples\powershell.example.helloworld\powershell.example.helloworld.ps1
+	EndProjectSection
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.helloworld", "examples\csharp.example.helloworld\csharp.example.helloworld.csproj", "{8CC1C265-0507-44A3-9483-8FAF48513F4D}"
 EndProject
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
index f0bbe13..2da40e6 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
@@ -58,10 +58,10 @@ namespace Messaging {
                          System::String ^, System::Object ^> ^ options) :
         addressp(new ::qpid::messaging::Address())
     {
-        SetName(name);
-        SetSubject(subject);
-        SetOptions(options);
-        SetType("");
+        Name = name;
+        Subject = subject;
+        Options = options;
+        Type = "";
     }
 
 
@@ -72,10 +72,10 @@ namespace Messaging {
                      System::String ^ type) :
         addressp(new ::qpid::messaging::Address())
     {
-        SetName(name);
-        SetSubject(subject);
-        SetOptions(options);
-        SetType(type);
+        Name = name;
+        Subject = subject;
+        Options = options;
+        Type = type;
     }
 
 
@@ -112,71 +112,6 @@ namespace Messaging {
 
 
     //
-    // name
-    //
-    System::String ^ Address::GetName()
-    {
-        return gcnew System::String(addressp->getName().c_str());
-    }
-
-    void Address::SetName(System::String ^ name)
-    {
-        addressp->::qpid::messaging::Address::setName(QpidMarshal::ToNative(name));
-    }
-
-    //
-    // subject
-    //
-    System::String ^ Address::GetSubject()
-    {
-        return gcnew System::String(addressp->getSubject().c_str());
-    }
-
-    void Address::SetSubject(System::String ^ subject)
-    {
-        addressp->setSubject(QpidMarshal::ToNative(subject));
-    }
-
-    //
-    // options
-    //
-    System::Collections::Generic::Dictionary<
-        System::String ^, System::Object ^> ^ Address::GetOptions()
-    {
-        ::qpid::types::Variant::Map map;
-        System::Collections::Generic::Dictionary<
-            System::String ^, System::Object ^> ^ newMap = 
-            gcnew System::Collections::Generic::Dictionary<
-                  System::String ^, System::Object ^>;
-        map = addressp->getOptions();
-        TypeTranslator::NativeToManaged(map, newMap);
-        return newMap;
-    }
-
-
-    void Address::SetOptions(System::Collections::Generic::Dictionary<
-                        System::String ^, System::Object ^> ^ options)
-    {
-        ::qpid::types::Variant::Map map;
-        TypeTranslator::ManagedToNative(options, map);
-        addressp->setOptions(map);
-    }
-
-    //
-    // type
-    //
-    System::String ^ Address::GetType()
-    {
-        return gcnew System::String(addressp->getType().c_str());
-    }
-
-
-    void Address::SetType(System::String ^ type)
-    {
-        addressp->setName(QpidMarshal::ToNative(type));
-    }
-
-    //
     // ToString
     //
     System::String ^ Address::ToStr()
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Address.h b/qpid/cpp/bindings/qpid/dotnet/src/Address.h
index 60e24da..9f940d6 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Address.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Address.h
@@ -27,6 +27,10 @@
 
 #include "qpid/messaging/Address.h"
 
+#include "QpidMarshal.h"
+#include "QpidTypeCheck.h"
+#include "TypeTranslator.h"
+
 namespace Org {
 namespace Apache {
 namespace Qpid {
@@ -73,20 +77,86 @@ namespace Messaging {
             ::qpid::messaging::Address * get () { return addressp; }
         }
 
-        System::String ^ GetName();
-        void SetName(System::String ^ name);
+        //
+        // name
+        //
+        property System::String ^ Name
+        {
+            System::String ^ get ()
+            {
+                return gcnew System::String(addressp->getName().c_str());
+            }
+
+            void set (System::String ^ name)
+            {
+                addressp->::qpid::messaging::Address::setName(QpidMarshal::ToNative(name));
+            }
+        }
+
+
+        //
+        // subject
+        //
+        property System::String ^ Subject
+        {
+            System::String ^ get ()
+            {
+                return gcnew System::String(addressp->getSubject().c_str());
+            }
+
+            void set (System::String ^ subject)
+            {
+                addressp->setSubject(QpidMarshal::ToNative(subject));
+            }
+        }
+
 
-        System::String ^ GetSubject();
-        void SetSubject(System::String ^ subject);
+        //
+        // options
+        //
+        property  System::Collections::Generic::Dictionary<
+            System::String ^, System::Object ^> ^ Options
+        {
+            System::Collections::Generic::Dictionary<
+                System::String ^, System::Object ^> ^ get ()
+            {
+                ::qpid::types::Variant::Map map;
+                System::Collections::Generic::Dictionary<
+                    System::String ^, System::Object ^> ^ newMap = 
+                    gcnew System::Collections::Generic::Dictionary<
+                          System::String ^, System::Object ^>;
+                map = addressp->getOptions();
+                TypeTranslator::NativeToManaged(map, newMap);
+                return newMap;
+            }
+
+
+            void set (System::Collections::Generic::Dictionary<
+                                System::String ^, System::Object ^> ^ options)
+            {
+                ::qpid::types::Variant::Map map;
+                TypeTranslator::ManagedToNative(options, map);
+                addressp->setOptions(map);
+            }
+        }
 
-        System::Collections::Generic::Dictionary<
-            System::String ^, System::Object ^> ^ GetOptions();
 
-        void SetOptions(System::Collections::Generic::Dictionary<
-                            System::String ^, System::Object ^> ^ options);
+        //
+        // type
+        //
+        property System::String ^ Type
+        {
+            System::String ^ get ()
+            {
+                return gcnew System::String(addressp->getType().c_str());
+            }
+
 
-        System::String ^ GetType();
-        void SetType(System::String ^ type);
+            void set (System::String ^ type)
+            {
+                addressp->setName(QpidMarshal::ToNative(type));
+            }
+        }
 
         System::String ^ ToStr();
     };
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
index 590cc5e..0e59c41 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
@@ -107,11 +107,6 @@ namespace Messaging {
         connectionp->open();
     }
 
-    System::Boolean Connection::IsOpen()
-    {
-        return connectionp->isOpen();
-    }
-
     void Connection::Close()
     {
         connectionp->close();
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Connection.h b/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
index e93e078..8e0f40f 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
@@ -62,9 +62,16 @@ namespace Messaging {
         void SetOption(System::String ^ name, System::Object ^ value);
 
         void Open();
-        System::Boolean IsOpen();
         void Close();
 
+        property System::Boolean IsOpen
+        {
+            System::Boolean get ()
+            {
+                return connectionp->isOpen();
+            }
+        }
+
         // CreateTransactionalSession()
         Session ^ CreateTransactionalSession();
         Session ^ CreateTransactionalSession(System::String ^ name);
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
index 743afce..f620a09 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
@@ -158,190 +158,36 @@ namespace Messaging {
         }
     }
 
-
-    //
-    // ReplyTo
-    //
-    void Message::SetReplyTo(Address ^ address)
-    {
-        messagep->setReplyTo(*(address->NativeAddress));
-    }
-
-    Address ^ Message::GetReplyTo()
-    {
-        const ::qpid::messaging::Address & addrp =
-            messagep->::qpid::messaging::Message::getReplyTo();
-
-        return gcnew Address(const_cast<::qpid::messaging::Address *>(&addrp));
-    }
-
-
-    //
-    // Subject
-    //
-    void Message::SetSubject(System::String ^ subject)
-    {
-        messagep->setSubject(QpidMarshal::ToNative(subject));
-    }
-    
-    System::String ^ Message::GetSubject()
-    {
-        return gcnew String(messagep->getSubject().c_str());
-    }
-    
-
-    //
-    // ContentType
-    //
-    void Message::SetContentType(System::String ^ ct)
-    {
-        messagep->setContentType(QpidMarshal::ToNative(ct));
-    }
-    
-	System::String ^ Message::GetContentType()
-    {
-		return gcnew String(messagep->::qpid::messaging::Message::getContentType().c_str());
-    }
-    
-    
-    //
-    // MessageId
-    //
-    void Message::SetMessageId(System::String ^ messageId)
-    {
-        messagep->setMessageId(QpidMarshal::ToNative(messageId));
-    }
-    
-    System::String ^ Message::GetMessageId()
-    {
-        return gcnew String(messagep->getMessageId().c_str());
-    }
-    
-    
-    //
-    // UserId
-    //
-    void Message::SetUserId(System::String ^ uId)
-    {
-        messagep->setUserId(QpidMarshal::ToNative(uId));
-    }
-    
-    System::String ^ Message::GetUserId()
-    {
-        return gcnew String(messagep->getUserId().c_str());
-    }
-    
-    
-    //
-    // CorrelationId
-    //
-    void Message::SetCorrelationId(System::String ^ correlationId)
-    {
-        messagep->setCorrelationId(QpidMarshal::ToNative(correlationId));
-    }
-    
-    System::String ^ Message::GetCorrelationId()
-    {
-        return gcnew String(messagep->getCorrelationId().c_str());
-    }
-    
-
-    //
-    // Priority
-    //
-    void Message::SetPriority(unsigned char priority)
-    {
-        messagep->setPriority(priority);
-    }
-    
-    unsigned char Message::GetPriority()
-    {
-        return messagep->getPriority();
-    }
-    
-
-    //
-    // Ttl
-    //
-    void Message::SetTtl(Duration ^ ttl)
-    {
-        ::qpid::messaging::Duration dur(ttl->Milliseconds);
-
-        messagep->setTtl(dur);
-    }
-    
-    Duration ^ Message::GetTtl()
+	// Property
+    void Message::SetProperty(System::String ^ name, System::Object ^ value)
     {
-        Duration ^ dur = gcnew Duration(messagep->getTtl().getMilliseconds());
+        ::qpid::types::Variant entryValue;
+        TypeTranslator::ManagedToNativeObject(value, entryValue);
 
-        return dur;
+        messagep->getProperties()[QpidMarshal::ToNative(name)] = entryValue;
     }
 
-    void Message::SetDurable(bool durable)
-    {
-        messagep->setDurable(durable);
-    }
-    
-    bool Message::GetDurable()
+	// Content
+	void Message::SetContent(System::String ^ content)
     {
-        return messagep->getDurable();
+        messagep->setContent(QpidMarshal::ToNative(content));
     }
 
 
-    bool Message::GetRedelivered()
+    void Message::SetContent(cli::array<System::Byte> ^ bytes)
     {
-        return messagep->getRedelivered();
+		pin_ptr<unsigned char> pBytes = &bytes[0];
+		messagep->setContent((char *)pBytes, bytes->Length);
     }
 
-    void Message::SetRedelivered(bool redelivered)
-    {
-        messagep->setRedelivered(redelivered);
-    }
 
-	// Properties
-    System::Collections::Generic::Dictionary<
-            System::String^, System::Object^> ^ Message::GetProperties()
+    void Message::SetContent(cli::array<System::Byte> ^ bytes, int offset, int size)
     {
-        ::qpid::types::Variant::Map map;
-
-        map = messagep->getProperties();
-
-        System::Collections::Generic::Dictionary<
-            System::String^, System::Object^> ^ dict =
-            gcnew System::Collections::Generic::Dictionary<
-                      System::String^, System::Object^> ;
-
-        TypeTranslator::NativeToManaged(map, dict);
-
-        return dict;
-    }
-
-
-	void Message::SetProperty(System::String ^ name, System::Object ^ value)
-	{
-        ::qpid::types::Variant entryValue;
-        TypeTranslator::ManagedToNativeObject(value, entryValue);
-
-		messagep->getProperties()[QpidMarshal::ToNative(name)] = entryValue;
-	}
-
-
-	void Message::SetProperties(System::Collections::Generic::Dictionary<
-            System::String^, System::Object^> ^ properties)
-	{
-		for each (System::Collections::Generic::KeyValuePair
-			     <System::String^, System::Object^> kvp in properties)
-        {
-			SetProperty(kvp.Key, kvp.Value);
-		}
-	}
-
+        if ((offset + size) > bytes->Length)
+			throw gcnew QpidException("Message::SetContent from byte array slice: buffer length exceeded");
 
-	
-	// Content
-	void Message::SetContent(System::String ^ content)
-    {
-        messagep->setContent(QpidMarshal::ToNative(content));
+		pin_ptr<unsigned char> pBytes = &bytes[offset];
+		messagep->setContent((char *)pBytes, size);
     }
 
 
@@ -388,7 +234,7 @@ namespace Messaging {
     // On entry message size must not be zero and
 	// caller's byte array must be equal to message size.
     //
-    void Message::GetRaw(array<System::Byte> ^ arr)
+    void Message::GetContent(array<System::Byte> ^ arr)
     {
         System::UInt32 size = messagep->getContentSize();
      
@@ -404,12 +250,6 @@ namespace Messaging {
     }
 
 
-    System::UInt64 Message::GetContentSize()
-    {
-        return messagep->getContentSize();
-    }
-
-
 	System::String ^ Message::MapAsString(System::Collections::Generic::Dictionary<
 					           System::String^, System::Object^> ^ dict)
     {
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.h b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
index 99d0b86..d5b4beb 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
@@ -26,6 +26,11 @@
 
 #include "qpid/messaging/Message.h"
 
+#include "QpidMarshal.h"
+#include "Address.h"
+#include "Duration.h"
+#include "TypeTranslator.h"
+
 namespace Org {
 namespace Apache {
 namespace Qpid {
@@ -78,46 +83,227 @@ namespace Messaging {
             ::qpid::messaging::Message * get () { return messagep; }
         }
 
-        void SetReplyTo(Address ^ address);
-        Address ^ GetReplyTo();
+        //
+        // ReplyTo
+        //
+        property Address ^ ReplyTo 
+        {
+            void set (Address ^ address)
+            {
+                 messagep->setReplyTo(*(address->NativeAddress));
+            }
+
+            Address ^ get () 
+            {
+                const ::qpid::messaging::Address & addrp =
+                    messagep->::qpid::messaging::Message::getReplyTo();
+
+                return gcnew Address(const_cast<::qpid::messaging::Address *>(&addrp));
+            }
+        }
+
+        //
+        // Subject
+        //
+        property System::String ^ Subject
+        {
+            void set (System::String ^ subject)
+            {
+                messagep->setSubject(QpidMarshal::ToNative(subject));
+            }
+            
+            
+            System::String ^ get ()
+            {
+                return gcnew String(messagep->getSubject().c_str());
+            }
+        }
 
-        void SetSubject(System::String ^ subject);
-        System::String ^ GetSubject();
 
-        void SetContentType(System::String ^ ct);
-        System::String ^ GetContentType();
-        
-        void SetMessageId(System::String ^ messageId);
-        System::String ^ GetMessageId();
-        
-        void SetUserId(System::String ^ uId);
-        System::String ^ GetUserId();
+        //
+        // ContentType
+        //
+        property System::String ^ ContentType
+        {
+            void set (System::String ^ ct)
+            {
+                messagep->setContentType(QpidMarshal::ToNative(ct));
+            }
+            
+	        System::String ^ get ()
+            {
+		        return gcnew String(messagep->::qpid::messaging::Message::getContentType().c_str());
+            }
+        }
+    
+
+        //
+        // MessageId
+        //
+        property System::String ^ MessageId
+        {
+            void set (System::String ^ messageId)
+            {
+                messagep->setMessageId(QpidMarshal::ToNative(messageId));
+            }
+
+            System::String ^ get ()
+            {
+                return gcnew String(messagep->getMessageId().c_str());
+            }
+        }
+
         
-        void SetCorrelationId(System::String ^ correlationId);
-        System::String ^ GetCorrelationId();
+        //
+        // UserId
+        //
+        property System::String ^ UserId
+        {
+            void set (System::String ^ uId)
+            {
+                messagep->setUserId(QpidMarshal::ToNative(uId));
+            }
+            
+            System::String ^ get ()
+            {
+                return gcnew String(messagep->getUserId().c_str());
+            }
+        }
 
-        void SetPriority(unsigned char priority);
-        unsigned char GetPriority();
+            
+        //
+        // CorrelationId
+        //
+        property System::String ^ CorrelationId
+        {
+            void set (System::String ^ correlationId)
+            {
+                messagep->setCorrelationId(QpidMarshal::ToNative(correlationId));
+            }
+            
+            System::String ^ get ()
+            {
+                return gcnew String(messagep->getCorrelationId().c_str());
+            }
+        }
 
-        void SetTtl(Duration ^ ttl);
-        Duration ^ GetTtl();
 
-        void SetDurable(bool durable);
-        bool GetDurable();
+        //
+        // Priority
+        //
+        property unsigned char Priority
+        {
+            void set (unsigned char priority)
+            {
+                messagep->setPriority(priority);
+            }
+            
+            unsigned char get ()
+            {
+                return messagep->getPriority();
+            }
+        }   
+
+
+        //
+        // Ttl
+        //
+        property Duration ^ Ttl
+        {
+            void set (Duration ^ ttl)
+            {
+                ::qpid::messaging::Duration dur(ttl->Milliseconds);
+
+                messagep->setTtl(dur);
+            }
+            
+            Duration ^ get ()
+            {
+                Duration ^ dur = gcnew Duration(messagep->getTtl().getMilliseconds());
+
+                return dur;
+            }
+        }
+
+        //
+        // Durable
+        //
+        property bool Durable
+        {
+            void set (bool durable)
+            {
+                messagep->setDurable(durable);
+            }
+            
+            bool get ()
+            {
+                return messagep->getDurable();
+            }
+        }
+
+        //
+        // Redelivered
+        //
+        property bool Redelivered
+        {
+            bool get ()
+            {
+                return messagep->getRedelivered();
+            }
+
+            void set (bool redelivered)
+            {
+                messagep->setRedelivered(redelivered);
+            }
+        }
+
+        //
+        // Property
+        //
+        void Message::SetProperty(System::String ^ name, System::Object ^ value);
+
+        //
+        // Properties
+        //
+        property System::Collections::Generic::Dictionary<
+                    System::String^, System::Object^> ^ Properties
+        {
+            System::Collections::Generic::Dictionary<
+                    System::String^, System::Object^> ^ get ()
+            {
+                ::qpid::types::Variant::Map map;
 
-        bool GetRedelivered();
-        void SetRedelivered(bool redelivered);
+                map = messagep->getProperties();
 
-        System::Collections::Generic::Dictionary<
-            System::String^, System::Object^> ^ GetProperties();
+                System::Collections::Generic::Dictionary<
+                    System::String^, System::Object^> ^ dict =
+                    gcnew System::Collections::Generic::Dictionary<
+                              System::String^, System::Object^> ;
 
-		void SetProperty(System::String ^ name, System::Object ^ value);
+                TypeTranslator::NativeToManaged(map, dict);
+
+                return dict;
+            }
+
+
+	        void set (System::Collections::Generic::Dictionary<
+                    System::String^, System::Object^> ^ properties)
+	        {
+		        for each (System::Collections::Generic::KeyValuePair
+			             <System::String^, System::Object^> kvp in properties)
+                {
+			        SetProperty(kvp.Key, kvp.Value);
+		        }
+	        }
+        }
 
-		void SetProperties(System::Collections::Generic::Dictionary<
-            System::String^, System::Object^> ^ properties);
 
         void SetContent(System::String ^ content);
 
+        void SetContent(cli::array<System::Byte> ^ bytes);
+
+        void SetContent(cli::array<System::Byte> ^ bytes, int offset, int size);
+
         //TODO:: void setContent(Bytes{} bytes, offset, length);
 
         // get content as string
@@ -133,9 +319,19 @@ namespace Messaging {
                             System::Object^> ^);
 
         // get content as bytes
-        void GetRaw(cli::array<System::Byte> ^ arr);
+        void GetContent(cli::array<System::Byte> ^ arr);
+
+        //
+        // ContentSize
+        //
+        property System::UInt64 ContentSize
+        {
+            System::UInt64 get ()
+            {
+                return messagep->getContentSize();
+            }
+        }
 
-        System::UInt64 GetContentSize();
 
 		// A message has been returned to managed code through GetContent().
 		// Display the content of that System::Object as a string.
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
index 15f8572..96df8cc 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
@@ -44,7 +44,7 @@ namespace Messaging {
     /// </summary>
 
     Receiver::Receiver(::qpid::messaging::Receiver * r,
-                       Session ^ sessRef) :
+                       Org::Apache::Qpid::Messaging::Session ^ sessRef) :
         receiverp(r),
         parentSession(sessRef)
     {
@@ -227,38 +227,8 @@ namespace Messaging {
         return newMessage;
     }
 
-    void Receiver::SetCapacity(System::UInt32 capacity)
-    {
-        receiverp->setCapacity(capacity);
-    }
-
-    System::UInt32 Receiver::GetCapacity()
-    {
-        return receiverp->getCapacity();
-    }
-
-    System::UInt32 Receiver::GetAvailable()
-    {
-        return receiverp->getAvailable();
-    }
-
-    System::UInt32 Receiver::GetUnsettled()
-    {
-        return receiverp->getUnsettled();
-    }
-
     void Receiver::Close()
     {
         receiverp->close();
     }
-
-    System::String ^ Receiver::GetName()
-    {
-        return gcnew System::String(receiverp->getName().c_str());
-    }
-
-    Session ^ Receiver::GetSession()
-    {
-        return parentSession;
-    }
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
index 0dc2f61..436f3f2 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
@@ -88,12 +88,66 @@ namespace Messaging {
         Message ^ Fetch();
         Message ^ Fetch(Duration ^ durationp);
 
-        void SetCapacity(System::UInt32 capacity);
-        System::UInt32 GetCapacity();
-        System::UInt32 GetAvailable();
-        System::UInt32 GetUnsettled();
+        //
+        // Capacity
+        //
+        property System::UInt32 Capacity
+        {
+            void set (System::UInt32 capacity)
+            {
+                receiverp->setCapacity(capacity);
+            }
+
+            System::UInt32 get ()
+            {
+                return receiverp->getCapacity();
+            }
+        }
+
+        //
+        // Available
+        //
+        property System::UInt32 Available
+        {
+            System::UInt32 get ()
+            {
+                return receiverp->getAvailable();
+            }
+        }
+
+        //
+        // Unsettled
+        //
+        property System::UInt32 Unsettled
+        {
+            System::UInt32 get ()
+            {
+                return receiverp->getUnsettled();
+            }
+        }
+
         void Close();
-        System::String ^ GetName();
-        Session ^ GetSession();
+        
+        //
+        // Name
+        //
+        property System::String ^ Name
+        {
+            System::String ^ get ()
+            {
+                return gcnew System::String(receiverp->getName().c_str());
+            }
+        }
+
+        //
+        // Session
+        //
+        property Org::Apache::Qpid::Messaging::Session ^ Session
+        {
+            Org::Apache::Qpid::Messaging::Session ^ get ()
+            {
+                return parentSession;
+            }
+        }
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
index e0911b3..0d394f8 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
@@ -40,7 +40,7 @@ namespace Messaging {
     /// </summary>
 
     Sender::Sender(::qpid::messaging::Sender * s,
-                     Session ^ sessRef) :
+                     Org::Apache::Qpid::Messaging::Session ^ sessRef) :
         senderp(s),
         parentSession(sessRef)
     {
@@ -96,9 +96,4 @@ namespace Messaging {
     {
         senderp->close();
     }
-
-    Session ^ Sender::GetSession()
-    {
-        return parentSession;
-    }
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Sender.h b/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
index 705c7d5..de114ab 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
@@ -95,6 +95,15 @@ namespace Messaging {
             }
         }
 
-        Session ^ GetSession();
+        //
+        // Session
+        //
+        property Org::Apache::Qpid::Messaging::Session ^ Session
+        {
+            Org::Apache::Qpid::Messaging::Session ^ get ()
+            {
+                return parentSession;
+            }
+        }
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
index 04fbb61..d5f4584 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
@@ -46,7 +46,8 @@ namespace Messaging {
     /// </summary>
 
     // constructor
-    Session::Session(::qpid::messaging::Session * sp, Connection ^ connRef) :
+    Session::Session(::qpid::messaging::Session * sp, 
+                     Org::Apache::Qpid::Messaging::Connection ^ connRef) :
         sessionp(sp),
         parentConnectionp(connRef)
     {
@@ -444,11 +445,10 @@ namespace Messaging {
 
     Sender ^ Session::GetSender(System::String ^ name)
     {
-        ::qpid::messaging::Sender * sender = new ::qpid::messaging::Sender;
+        ::qpid::messaging::Sender sender = ::qpid::messaging::Sender(
+            sessionp->::qpid::messaging::Session::getSender(QpidMarshal::ToNative(name)) );
 
-        *sender = sessionp->::qpid::messaging::Session::getSender(QpidMarshal::ToNative(name));
-
-        Sender ^ newSender = gcnew Sender(sender, this);
+        Sender ^ newSender = gcnew Sender(&sender, this);
 
         return newSender;
     }
@@ -457,22 +457,16 @@ namespace Messaging {
 
     Receiver ^ Session::GetReceiver(System::String ^ name)
     {
-        ::qpid::messaging::Receiver * receiver = new ::qpid::messaging::Receiver;
-
-        *receiver = sessionp->::qpid::messaging::Session::getReceiver(QpidMarshal::ToNative(name));
+        ::qpid::messaging::Receiver receiver = ::qpid::messaging::Receiver(
+            sessionp->::qpid::messaging::Session::getReceiver(QpidMarshal::ToNative(name)) );
 
-        Receiver ^ newReceiver = gcnew Receiver(receiver, this);
+        Receiver ^ newReceiver = gcnew Receiver(&receiver, this);
 
         return newReceiver;
     }
 
 
 
-    Connection ^ Session::GetConnection()
-    {
-        return parentConnectionp;
-    }
-
     void Session::CheckError()
     {
         sessionp->checkError();
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.h b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
index 4b84eec..a5affc6 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
@@ -110,7 +110,14 @@ namespace Messaging {
         Sender   ^ GetSender(System::String ^ name);
         Receiver ^ GetReceiver(System::String ^ name);
 
-        Connection ^ GetConnection();
+        property Org::Apache::Qpid::Messaging::Connection ^ Connection
+        {
+            Org::Apache::Qpid::Messaging::Connection ^ get ()
+            {
+                return parentConnectionp;
+            }
+        }
+
 
         property System::Boolean HasError
         {
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
index 2e0e481..c1b3035 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
@@ -74,12 +74,12 @@ namespace Org.Apache.Qpid.Messaging
             //
 
             Message m2 = new Message("rarey");
-            UInt64 m2Size = m2.GetContentSize();
+            UInt64 m2Size = m2.ContentSize;
 
 
             byte[] myRaw = new byte [m2Size];
 
-            m2.GetRaw(myRaw);
+            m2.GetContent(myRaw);
             Console.WriteLine("Got raw array size {0}", m2Size);
             for (UInt64 i = 0; i < m2Size; i++)
                 Console.Write("{0} ", myRaw[i].ToString());
@@ -93,9 +93,9 @@ namespace Org.Apache.Qpid.Messaging
                 rawData[i] = i;
             Message m3 = new Message(rawData);
 
-            byte[] rawDataReadback = new byte[m3.GetContentSize()];
-            m3.GetRaw(rawDataReadback);
-            for (UInt64 i = 0; i < m3.GetContentSize(); i++)
+            byte[] rawDataReadback = new byte[m3.ContentSize];
+            m3.GetContent(rawDataReadback);
+            for (UInt64 i = 0; i < m3.ContentSize; i++)
                 Console.Write("{0} ", rawDataReadback[i].ToString());
             Console.WriteLine();
 
@@ -108,13 +108,24 @@ namespace Org.Apache.Qpid.Messaging
 
             Message m4 = new Message(rawData4, 246, 10);
 
-            byte[] rawDataReadback4 = new byte[m4.GetContentSize()];
-            m4.GetRaw(rawDataReadback4);
-            for (UInt64 i = 0; i < m4.GetContentSize(); i++)
+            byte[] rawDataReadback4 = new byte[m4.ContentSize];
+            m4.GetContent(rawDataReadback4);
+            for (UInt64 i = 0; i < m4.ContentSize; i++)
                 Console.Write("{0} ", rawDataReadback4[i].ToString());
             Console.WriteLine();
 
             //
+            // Set content from array slice
+            //
+            m4.SetContent(rawData4, 100, 5);
+
+            byte[] rawDataReadback4a = new byte[m4.ContentSize];
+            m4.GetContent(rawDataReadback4a);
+            for (UInt64 i = 0; i < m4.ContentSize; i++)
+                Console.Write("{0} ", rawDataReadback4a[i].ToString());
+            Console.WriteLine();
+
+            //
             // Guid factoids
             //
             Guid myGuid = new Guid("000102030405060708090a0b0c0d0e0f");
-- 
1.5.5.6

From 0d9a38bd4ec42aeaf7f05035483f8227f8b72cdd Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Fri, 25 Jun 2010 22:35:28 +0000
Subject: [PATCH] QPID-2589 - Patch from Chuck Rolke
 Re-do changes to Session.cpp.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958141 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/bindings/qpid/dotnet/src/Session.cpp |   80 +++++++++++++++++++++++--
 1 files changed, 74 insertions(+), 6 deletions(-)

diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
index d5f4584..bafc9b3 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
@@ -445,10 +445,44 @@ namespace Messaging {
 
     Sender ^ Session::GetSender(System::String ^ name)
     {
-        ::qpid::messaging::Sender sender = ::qpid::messaging::Sender(
-            sessionp->::qpid::messaging::Session::getSender(QpidMarshal::ToNative(name)) );
+        System::Exception           ^ newException = nullptr;
+        ::qpid::messaging::Sender   * senderp      = NULL;
+        Sender                      ^ newSender    = nullptr;
 
-        Sender ^ newSender = gcnew Sender(&sender, this);
+        try
+        {
+            senderp = new ::qpid::messaging::Sender;
+
+            *senderp = sessionp->::qpid::messaging::Session::getSender(QpidMarshal::ToNative(name));
+
+            newSender = gcnew Sender(senderp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        finally 
+		{
+            if (newException != nullptr)
+			{
+				if (newSender != nullptr)
+				{
+					delete newSender;
+				}
+				else
+				{
+					if (senderp != NULL)
+					{
+						delete senderp;
+					}
+				}
+            }
+        }
+        if (newException != nullptr) 
+		{
+	        throw newException;
+		}
 
         return newSender;
     }
@@ -457,10 +491,44 @@ namespace Messaging {
 
     Receiver ^ Session::GetReceiver(System::String ^ name)
     {
-        ::qpid::messaging::Receiver receiver = ::qpid::messaging::Receiver(
-            sessionp->::qpid::messaging::Session::getReceiver(QpidMarshal::ToNative(name)) );
+        System::Exception           ^ newException = nullptr;
+        ::qpid::messaging::Receiver * receiverp    = NULL;
+        Receiver                    ^ newReceiver  = nullptr;
+
+        try
+        {
+            receiverp = new ::qpid::messaging::Receiver;
 
-        Receiver ^ newReceiver = gcnew Receiver(&receiver, this);
+            *receiverp = sessionp->::qpid::messaging::Session::getReceiver(QpidMarshal::ToNative(name));
+
+            newReceiver = gcnew Receiver(receiverp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        finally 
+		{
+            if (newException != nullptr)
+			{
+				if (newReceiver != nullptr)
+				{
+					delete newReceiver;
+				}
+				else
+				{
+					if (receiverp != NULL)
+					{
+						delete receiverp;
+					}
+				}
+            }
+        }
+        if (newException != nullptr) 
+		{
+	        throw newException;
+		}
 
         return newReceiver;
     }
-- 
1.5.5.6

From 500df302fb0bdad8eb1f0b3ad9253d379bb1c7e1 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 28 Jun 2010 20:22:25 +0000
Subject: [PATCH] Bug 603085: Install and package Visual Studio debugging symbols (.pdb) files,
 in the windows sdk zip package.

A Modified version of a patch from Chuck Rolke

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958703 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/bld-winsdk.ps1     |  278 ++++++++++++++++++++++---------------------
 qpid/cpp/src/CMakeLists.txt |   81 +++++++------
 2 files changed, 191 insertions(+), 168 deletions(-)

diff --git a/qpid/cpp/bld-winsdk.ps1 b/qpid/cpp/bld-winsdk.ps1
index 8618160..7aa6df8 100644
--- a/qpid/cpp/bld-winsdk.ps1
+++ b/qpid/cpp/bld-winsdk.ps1
@@ -1,133 +1,145 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-# This script requires cmake, and 7z to be already on the path devenv should be on the path as
-# a result of installing Visual Studio
-
-Set-PSDebug -strict
-$ErrorActionPreference='Stop'
-
-if ($args.length -lt 1) {
-  Write-Host 'Need to specify location of qpid src tree'
-  exit
-}
-
-$qpid_src=$args[0]
-$ver=$args[1]
-if ($ver -eq $null) {
-  $qpid_version_file="$qpid_src\QPID_VERSION.txt"
-
-  if ( !(Test-Path $qpid_version_file)) {
-    Write-Host "Path doesn't seem to be a qpid src tree (no QPID_VERSION.txt)"
-    exit
-  }
-  $ver=Get-Content $qpid_version_file
-}
-
-$randomness=[System.IO.Path]::GetRandomFileName()
-
-$qpid_cpp_src="$qpid_src\cpp"
-$install_dir="install_$randomness"
-$preserve_dir="preserve_$randomness"
-$zipfile="qpid-cpp-$ver.zip"
-
-# This assumes Visual Studio 2008
-cmake -G "Visual Studio 9 2008" "-DCMAKE_INSTALL_PREFIX=$install_dir" $qpid_cpp_src
-
-# Need to build doxygen api docs separately as nothing depends on them
-devenv qpid-cpp.sln /build "Release|Win32" /project docs-user-api
-
-# Build both debug and release so we can ship both sets of libs
-# (Do release after debug  so that the release executables overwrite the
-# debug executables)
-devenv qpid-cpp.sln /build "Debug|Win32" /project INSTALL
-devenv qpid-cpp.sln /build "Release|Win32" /project INSTALL
-
-# This would be kludgy if we have only one entry as the array declaration syntax
-# can't cope with just one nested array
-# Target must be a directory
-$move=(
-	('bin/*.lib','lib'),
-	('bin/boost/*.dll','bin')
-)
-
-$preserve=(
-	'include/qpid/agent',
-	'include/qpid/amqp_0_10',
-	'include/qpid/management',
-	'include/qpid/messaging',
-	'include/qpid/sys/IntegerTypes.h',
-	'include/qpid/sys/windows/IntegerTypes.h', 'include/qpid/sys/posix/IntegerTypes.h',
-	'include/qpid/types',
-	'include/qpid/CommonImportExport.h')
-$remove=(
-	'bin/qpidd.exe', 'bin/qpidbroker*.*',
-	'bin/qmfengine*.*', 'bin/qpidxarm*.*',
-	'bin/boost_regex*.*',
-	'bin/boost',
-	'conf',
-	'examples/direct',
-	'examples/failover',
-	'examples/fanout',
-	'examples/pub-sub',
-	'examples/qmf-console',
-	'examples/request-response',
-	'examples/tradedemo',
-	'examples/old-examples.sln',
-	'examples/README.*',
-	'examples/verify*',
-	'include',
-	'plugins')
-
-# Move some files around in the install tree
-foreach ($pattern in $move) {
-	$target = Join-Path $install_dir $pattern[1]
-	New-Item -force -type directory $target
-	Move-Item -force -path "$install_dir/$($pattern[0])" -destination "$install_dir/$($pattern[1])"
-}
-# Copy aside the files to preserve
-New-Item -path $preserve_dir -type directory
-foreach ($pattern in $preserve) {
-	$target = Join-Path $preserve_dir $pattern
-	$tparent = Split-Path -parent $target
-	New-Item -force -type directory $tparent
-	Move-Item -force -path "$install_dir/$pattern" -destination "$preserve_dir/$pattern"
-}
-# Remove everything to remove
-foreach ($pattern in $remove) {
-	Remove-Item -recurse "$install_dir/$pattern"
-}
-# Copy back the preserved things
-foreach ($pattern in $preserve) {
-	$target = Join-Path $install_dir $pattern
-	$tparent = Split-Path -parent $target
-	New-Item -force -type directory $tparent
-	Move-Item -force -path "$preserve_dir/$pattern" -destination "$install_dir/$pattern"
-}
-Remove-Item -recurse $preserve_dir
-
-# It would be very good to cut down on the shipped boost include files too, ideally by
-# starting with the qpid files and recursively noting all boost headers actually needed
-
-# Create a new zip
-if (Test-Path $zipfile) {Remove-Item $zipfile}
-&'7z' a $zipfile ".\$install_dir\*"
-
-# Remove temporary install area
-# Remove-Item -recurse $install_dir
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+# This script requires cmake, and 7z to be already on the path devenv should be on the path as
+# a result of installing Visual Studio
+
+Set-PSDebug -strict
+$ErrorActionPreference='Stop'
+
+if ($args.length -lt 1) {
+  Write-Host 'Need to specify location of qpid src tree'
+  exit
+}
+
+$qpid_src=$args[0]
+$ver=$args[1]
+if ($ver -eq $null) {
+  $qpid_version_file="$qpid_src\QPID_VERSION.txt"
+
+  if ( !(Test-Path $qpid_version_file)) {
+    Write-Host "Path doesn't seem to be a qpid src tree (no QPID_VERSION.txt)"
+    exit
+  }
+  $ver=Get-Content $qpid_version_file
+}
+
+$randomness=[System.IO.Path]::GetRandomFileName()
+
+$qpid_cpp_src="$qpid_src\cpp"
+$install_dir="install_$randomness"
+$preserve_dir="preserve_$randomness"
+$zipfile="qpid-cpp-$ver.zip"
+
+# This assumes Visual Studio 2008
+cmake -G "Visual Studio 9 2008" "-DCMAKE_INSTALL_PREFIX=$install_dir" $qpid_cpp_src
+
+# Need to build doxygen api docs separately as nothing depends on them
+devenv qpid-cpp.sln /build "Release|Win32" /project docs-user-api
+
+# Build both Debug and Release builds so we can ship both sets of libs:
+# Make RelWithDebInfo for debuggable release code.
+# (Do Release after Debug so that the release executables overwrite the
+# debug executables. Don't skip Debug as it creates some needed content.)
+devenv qpid-cpp.sln /build "Debug|Win32" /project INSTALL
+devenv qpid-cpp.sln /build "RelWithDebInfo|Win32" /project INSTALL
+
+# This would be kludgy if we have only one entry as the array declaration syntax
+# can't cope with just one nested array
+# Target must be a directory
+$move=(
+	('bin/*.lib','lib'),
+	('bin/boost/*.dll','bin')
+)
+
+$preserve=(
+	'include/qpid/agent',
+	'include/qpid/amqp_0_10',
+	'include/qpid/management',
+	'include/qpid/messaging',
+	'include/qpid/sys/IntegerTypes.h',
+	'include/qpid/sys/windows/IntegerTypes.h', 'include/qpid/sys/posix/IntegerTypes.h',
+	'include/qpid/types',
+	'include/qpid/CommonImportExport.h')
+$remove=(
+	'bin/qpidd.exe', 'bin/qpidbroker*.*',
+	'bin/*PDB/qpidd.exe', 'bin/*PDB/qpidbroker*.*',
+	'bin/qmfengine*.*', 'bin/qpidxarm*.*',
+	'bin/*PDB/qmfengine*.*', 'bin/*PDB/qpidxarm*.*',
+	'bin/boost_regex*.*',
+	'bin/boost',
+	'conf',
+	'examples/direct',
+	'examples/failover',
+	'examples/fanout',
+	'examples/pub-sub',
+	'examples/qmf-console',
+	'examples/request-response',
+	'examples/tradedemo',
+	'examples/old-examples.sln',
+	'examples/README.*',
+	'examples/verify*',
+	'include',
+	'plugins')
+
+# Move some files around in the install tree
+foreach ($pattern in $move) {
+	$target = Join-Path $install_dir $pattern[1]
+	New-Item -force -type directory $target
+	Move-Item -force -path "$install_dir/$($pattern[0])" -destination "$install_dir/$($pattern[1])"
+}
+
+# Copy aside the files to preserve
+New-Item -path $preserve_dir -type directory
+foreach ($pattern in $preserve) {
+	$target = Join-Path $preserve_dir $pattern
+	$tparent = Split-Path -parent $target
+	New-Item -force -type directory $tparent
+	Move-Item -force -path "$install_dir/$pattern" -destination "$preserve_dir/$pattern"
+}
+# Remove everything to remove
+foreach ($pattern in $remove) {
+	Remove-Item -recurse "$install_dir/$pattern"
+}
+# Copy back the preserved things
+foreach ($pattern in $preserve) {
+	$target = Join-Path $install_dir $pattern
+	$tparent = Split-Path -parent $target
+	New-Item -force -type directory $tparent
+	Move-Item -force -path "$preserve_dir/$pattern" -destination "$install_dir/$pattern"
+}
+Remove-Item -recurse $preserve_dir
+
+# Zip the /bin PDB files into two zip files.
+# we previously arranged that the Debug pdbs go in the DebugPDB subdirectory
+# and the Release pdbs go in the ReleasePDB subdirectory
+&'7z' a -mx9 ".\$install_dir\bin\symbols-debug.zip" ".\$install_dir\bin\DebugPDB\*.pdb"
+&'7z' a -mx9 ".\$install_dir\bin\symbols-release.zip" ".\$install_dir\bin\ReleasePDB\*.pdb"
+
+# It would be very good to cut down on the shipped boost include files too, ideally by
+# starting with the qpid files and recursively noting all boost headers actually needed
+
+
+# Create a new zip for the whole kit.
+# Exclude *.pdb so as not include the debug symbols twice
+if (Test-Path $zipfile) {Remove-Item $zipfile}
+&'7z' a $zipfile ".\$install_dir\*" -xr!*pdb
+
+# Remove temporary install area
+# Remove-Item -recurse $install_dir
diff --git a/qpid/cpp/src/CMakeLists.txt b/qpid/cpp/src/CMakeLists.txt
index 7083574..cf9161d 100644
--- a/qpid/cpp/src/CMakeLists.txt
+++ b/qpid/cpp/src/CMakeLists.txt
@@ -34,6 +34,37 @@ include(FindDoxygen)
 
 #set (CMAKE_VERBOSE_MAKEFILE ON)  # for debugging
 
+#
+# Set up installation of .pdb files if the compiler is Visual Studio
+#
+# Sample: install_pdb (qpidcommon ${QPID_COMPONENT_COMMON})
+#
+MACRO (install_pdb theLibrary theComponent)
+    if (MSVC)
+        get_target_property(library_dll ${theLibrary} LOCATION)
+        string(REPLACE .dll .pdb library_pdb ${library_dll})
+        string(REPLACE $(OutDir) \${CMAKE_INSTALL_CONFIG_NAME} library_pdb ${library_pdb})
+        string(REPLACE .pdb d.pdb libraryd_pdb ${library_pdb})
+        #message(STATUS "_pdb: ${library_pdb}, ${libraryd_pdb}")
+        install (PROGRAMS
+                ${library_pdb}
+                DESTINATION ${QPID_INSTALL_LIBDIR}/ReleasePDB
+                COMPONENT ${theComponent}
+				OPTIONAL
+                CONFIGURATIONS Release|MinSizeRel)
+        install (PROGRAMS
+                ${library_pdb}
+                DESTINATION ${QPID_INSTALL_LIBDIR}/ReleasePDB
+                COMPONENT ${theComponent}
+                CONFIGURATIONS RelWithDebInfo)
+        install (PROGRAMS
+                ${libraryd_pdb}
+                DESTINATION ${QPID_INSTALL_LIBDIR}/DebugPDB
+                COMPONENT ${theComponent}
+                CONFIGURATIONS Debug)
+    endif (MSVC)
+ENDMACRO (install_pdb)
+
 # check if we generate source as part of the build
 #   - rubygen generates the amqp spec and clustering
 #   - managementgen generates the broker management code
@@ -460,6 +491,10 @@ if (CMAKE_SYSTEM_NAME STREQUAL Windows)
     if (MSVC80)
       add_definitions(/D "_WIN32_WINNT=0x0501")
     endif (MSVC80)
+
+    # set the RelWithDebInfo compile/link switchs to equal Release
+    set (CMAKE_CXX_FLAGS_RELWITHDEBINFO "/MD /O2 /Ob2 /D NDEBUG")
+    set (CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO "/debug /INCREMENTAL:NO")
   endif (MSVC)
 
   set (qpidcommon_platform_SOURCES
@@ -544,7 +579,7 @@ else (CMAKE_SYSTEM_NAME STREQUAL Windows)
 
     ${qpid_poller_module}
   )
-  set (qpidcommon_platform_LIBS      
+  set (qpidcommon_platform_LIBS
     ${Boost_PROGRAM_OPTIONS_LIBRARY}
     ${Boost_FILESYSTEM_LIBRARY}
     uuid
@@ -646,19 +681,8 @@ set_target_properties (qpidcommon PROPERTIES
 install (TARGETS qpidcommon
          DESTINATION ${QPID_INSTALL_LIBDIR}
          COMPONENT ${QPID_COMPONENT_COMMON})
+install_pdb (qpidcommon ${QPID_COMPONENT_COMMON})
 
-if (WIN32)
-    # Need the .pdb file, which isn't installed with the .dll/.lib
-    # Not built... if needed, add the build option then uncomment this.
-    #get_target_property(qpidcommon_dll qpidcommon LOCATION)
-    #string(REPLACE .dll .pdb qpidcommon_pdb ${qpidcommon_dll})
-    #string(REPLACE $(OutDir) \${CMAKE_INSTALL_CONFIG_NAME} qpidcommon_pdb ${qpidcommon_pdb})
-    #message(STATUS "_pdb: ${qpidcommon_pdb}")
-    #install (PROGRAMS
-    #         ${qpidcommon_pdb}
-    #         DESTINATION ${QPID_INSTALL_LIBDIR}
-    #         COMPONENT ${QPID_COMPONENT_CLIENT})
-endif (WIN32)
 
 set (qpidclient_SOURCES
      ${rgen_client_srcs}
@@ -709,6 +733,8 @@ install (DIRECTORY ../include/qpid
          DESTINATION ${QPID_INSTALL_INCLUDEDIR}
          COMPONENT ${QPID_COMPONENT_CLIENT_INCLUDE}
          PATTERN ".svn" EXCLUDE)
+install_pdb (qpidclient ${QPID_COMPONENT_CLIENT})
+
 
 set (qpidmessaging_SOURCES
      qpid/messaging/Address.cpp
@@ -756,6 +782,7 @@ set_target_properties (qpidmessaging PROPERTIES VERSION ${qpidc_version})
 install (TARGETS qpidmessaging
          DESTINATION ${QPID_INSTALL_LIBDIR}
          COMPONENT ${QPID_COMPONENT_CLIENT})
+install_pdb (qpidmessaging ${QPID_COMPONENT_CLIENT})
 
 # Released source artifacts from Apache have the generated headers included in
 # the source tree, not the binary tree. So don't attempt to grab them when
@@ -766,17 +793,6 @@ if (NOT QPID_GENERATED_HEADERS_IN_SOURCE)
            COMPONENT ${QPID_COMPONENT_CLIENT_INCLUDE})
 endif (NOT QPID_GENERATED_HEADERS_IN_SOURCE)
 
-if (WIN32)
-    # Need the .pdb file, which isn't installed with the .dll/.lib
-    #get_target_property(qpidclient_dll qpidclient LOCATION)
-    #string(REPLACE .dll .pdb qpidclient_pdb ${qpidclient_dll})
-    #string(REPLACE $(OutDir) \${CMAKE_INSTALL_CONFIG_NAME} qpidclient_pdb ${qpidclient_pdb})
-    #message(STATUS "_pdb: ${qpidclient_pdb}")
-    #install (PROGRAMS
-    #         ${qpidclient_pdb}
-    #         DESTINATION ${QPID_INSTALL_LIBDIR}
-    #         COMPONENT ${QPID_COMPONENT_CLIENT})
-endif (WIN32)
 
 if (WIN32)
     set(AMQP_WCF_DIR ${qpid-cpp_SOURCE_DIR}/../wcf)
@@ -787,6 +803,7 @@ if (WIN32)
         install (TARGETS qpidxarm
                  DESTINATION ${QPID_INSTALL_LIBDIR}
                  COMPONENT ${QPID_COMPONENT_CLIENT})
+        install_pdb (qpidxarm ${QPID_COMPONENT_CLIENT})
     endif (EXISTS ${DTC_PLUGIN_SOURCE})
 endif (WIN32)
 
@@ -867,6 +884,8 @@ endif (MSVC)
 install (TARGETS qpidbroker
          DESTINATION ${QPID_INSTALL_LIBDIR}
          COMPONENT ${QPID_COMPONENT_BROKER})
+install_pdb (qpidbroker ${QPID_COMPONENT_BROKER})
+
 
 set (qpidd_SOURCES
      ${qpidd_platform_SOURCES}
@@ -905,6 +924,7 @@ set_target_properties (qmf PROPERTIES
 install (TARGETS qmf OPTIONAL
          DESTINATION ${QPID_INSTALL_LIBDIR}
          COMPONENT ${QPID_COMPONENT_QMF})
+install_pdb (qmf ${QPID_COMPONENT_QMF})
 
 set (qmfengine_SOURCES
      qmf/engine/Agent.cpp
@@ -944,6 +964,7 @@ set_target_properties (qmfengine PROPERTIES
 install (TARGETS qmfengine OPTIONAL
          DESTINATION ${QPID_INSTALL_LIBDIR}
          COMPONENT ${QPID_COMPONENT_QMF})
+install_pdb (qmfengine ${QPID_COMPONENT_QMF})
 
 # QMF console library
 #module_hdr += \
@@ -993,17 +1014,7 @@ set_target_properties (qmfconsole PROPERTIES
 install (TARGETS qmfconsole
          DESTINATION ${QPID_INSTALL_LIBDIR}
          COMPONENT ${QPID_COMPONENT_QMF})
-if (WIN32)
-    # Need the .pdb file, which isn't installed with the .dll/.lib
-    #get_target_property(qmfconsole_dll qmfconsole LOCATION)
-    #string(REPLACE .dll .pdb qmfconsole_pdb ${qmfconsole_dll})
-    #string(REPLACE $(OutDir) \${CMAKE_INSTALL_CONFIG_NAME} qmfconsole_pdb ${qmfconsole_pdb})
-    #message(STATUS "_pdb: ${qmfconsole_pdb}")
-    #install (PROGRAMS
-    #         ${qmfconsole_pdb}
-    #         DESTINATION ${QPID_INSTALL_LIBDIR}
-    #         COMPONENT ${QPID_COMPONENT_QMF})
-endif (WIN32)
+install_pdb (qmfconsole ${QPID_COMPONENT_QMF})
 
 # A queue event listener plugin that creates messages on a replication
 # queue corresponding to enqueue and dequeue events:
-- 
1.5.5.6

