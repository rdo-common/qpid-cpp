--- cpp/src/qpid/xml/XmlExchange.cpp	2010-02-08 10:08:03.000000000 +0000
+++ cpp/src/qpid/xml/XmlExchange.cpp	2010-02-08 10:17:33.000000000 +0000
@@ -38,6 +38,8 @@ 
 
 #include <xqilla/context/ItemFactory.hpp>
 #include <xqilla/xqilla-simple.hpp>
+#include <xqilla/utils/XPath2Utils.hpp>
+#include <xqilla/exceptions/XPath2TypeMatchException.hpp>
 
 #include <iostream>
 #include <sstream>
@@ -133,6 +135,46 @@ 
     }
 }
 
+namespace
+{
+	static bool getEffectiveBooleanValueInternal(const Item::Ptr &first, const Item::Ptr &second, DynamicContext* context, const LocationInfo *info)
+	{
+	  // If its operand is a singleton value ...
+	  if(second == NULLRCP && first->isAtomicValue()) {
+		const AnyAtomicType::Ptr atom=first;
+		// ... of type xs:boolean or derived from xs:boolean, fn:boolean returns the value of its operand unchanged.
+		if(atom->getPrimitiveTypeIndex() == AnyAtomicType::BOOLEAN)
+			return ((const ATBooleanOrDerived::Ptr)atom)->isTrue();
+
+		// ... of type xs:string, xdt:untypedAtomic, or a type derived from one of these, fn:boolean returns false 
+		// if the operand value has zero length; otherwise it returns true.
+		if((atom->getPrimitiveTypeIndex() == AnyAtomicType::STRING || 
+			atom->getPrimitiveTypeIndex() == AnyAtomicType::ANY_URI || 
+			atom->getPrimitiveTypeIndex() == AnyAtomicType::UNTYPED_ATOMIC))
+		  return !XPath2Utils::equals(atom->asString(context), XERCES_CPP_NAMESPACE_QUALIFIER XMLUni::fgZeroLenString);
+
+		// ... of any numeric type or derived from a numeric type, fn:boolean returns false if the operand value is 
+		// NaN or is numerically equal to zero; otherwise it returns true.
+		if(atom->isNumericValue()) {
+		  const Numeric::Ptr number=atom;
+		  return (!number->isZero() && !number->isNaN());
+		}
+	  }
+
+	  // In all other cases, fn:boolean raises a type error. 
+	  XQThrow3(XPath2TypeMatchException,X("ResultImpl::getEffectiveBooleanValue"), X("Effective Boolean Value cannot be extracted from this type [err:FORG0006]"), info);
+	  return true;
+	}
+
+	bool getEffectiveBooleanValue(Result &result, DynamicContext* context, const LocationInfo *info)
+	{
+	  const Item::Ptr first = result->next(context);
+	  if(first == NULLRCP) return false;
+	  if(first->isNode()) return true;
+	  return getEffectiveBooleanValueInternal(first, result->next(context), context, info);
+	}
+}
+
 bool XmlExchange::matches(Query& query, Deliverable& msg, const qpid::framing::FieldTable* args, bool parse_message_content) 
 {
   string msgContent;
@@ -179,7 +221,7 @@ 
       }
 
       Result result = query->execute(context.get());
-      return result->getEffectiveBooleanValue(context.get(), 0);
+      return getEffectiveBooleanValue(result, context.get(), 0);
   }
   catch (XQException& e) {
       QPID_LOG(warning, "Could not parse XML content (or message headers):" << msgContent);
